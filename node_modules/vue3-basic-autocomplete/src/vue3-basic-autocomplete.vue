<template>
  <div class="autocomplete">
    <input class="autocomplete-input" :class="inputClass" ref="inputAutocomplete" :value="typeof modelValue == 'string' || !modelValue
        ? modelValue
        : modelValue[trackby]
      " @input="updateData()" @paste="updateData()" @keydown="dropSelection($event)" @blur="onBlur()"
      :placeholder="placeholder" :disabled="disabled" />
    <span v-if="clearBtn" class="close-mark" @click="clear">&#10006;</span>
    <div class="autocomplete-list" v-if="filteredItems">
      <ul v-if="filteredItems.length > 0" :style="`max-height: ${listMaxHeight}px`">
        <li v-for="(item, index) in filteredItems" :key="index" :class="highlight == index ? 'highlight-class' : ''"
          @mousedown="sendValue(item)" @mouseenter="highlight = index" @mouseleave="highlight = -1">
          <span v-if="trackby != ''">{{ item[trackby] }}</span>
          <span v-if="trackby == ''">{{ item }}</span>
        </li>
      </ul>
      <ul v-if="filteredItems.length === 0">
        <li class="text-muted">{{ noneFind }}</li>
      </ul>
    </div>
  </div>
</template>

<script>
import { ref, reactive, toRefs } from "vue";
export default {
  props: {
    modelValue: {
      default: "",
    },
    options: {
      type: Array,
      required: true,
    },
    trackby: {
      type: String,
      default: "",
    },
    minlength: {
      type: Number,
      default: 1,
    },
    "none-find": {
      type: String,
      default: "No matching results",
    },
    "input-class": {
      type: String,
      default: "",
    },
    placeholder: {
      type: String,
      default: "",
    },
    disabled: {
      type: Boolean,
      default: false,
    },
    "list-max-height": {
      type: String,
      default: "300",
    },
    "clear-btn": {
      type: Boolean,
      default: false,
    },
  },
  emits: ["update:modelValue", "selected"],
  setup(props, { emit }) {
    const inputAutocomplete = ref(null);
    const data = reactive({
      highlight: -1,
      filteredItems: false,
    });

    const updateData = () => {
      const input = inputAutocomplete.value.value;
      emit("update:modelValue", input);
      if (input.length == 0 && props.minlength == 0) {
        data.filteredItems = props.options;
        return;
      }
      if (input.length >= props.minlength) {
        let result;
        props.trackby != ""
          ? (result = props.options.filter((i) => i[props.trackby] == input))
          : (result = props.options.filter((i) => i == input));

        result.length == 0 ? filterItems() : sendValue(result[0]);
      } else {
        data.filteredItems = false;
      }
    };

    const filterItems = () => {
      let result;
      let reg = new RegExp(
        inputAutocomplete.value.value.split("").join("\\w*").replace(/\W/, ""),
        "i"
      );
      props.trackby != ""
        ? (result = props.options.filter((i) => {
          if (i[props.trackby].match(reg)) return i;
        }))
        : (result = props.options.filter((i) => {
          if (i.match(reg)) return i;
        }));
      data.filteredItems = result;
    };

    const onBlur = () => {
      let result;
      props.trackby != ""
        ? (result = props.options.filter(
          (i) => i[props.trackby] == inputAutocomplete.value.value
        ))
        : (result = props.options.filter(
          (i) => i == inputAutocomplete.value.value
        ));
      if (result.length === 0) {
        inputAutocomplete.value.value = "";
        data.filteredItems = false;
        emit("update:modelValue", "");
      }
    };

    const sendValue = (sendData) => {
      data.highlight = -1;
      data.filteredItems = false;
      emit("update:modelValue", sendData);
      emit("selected", data);
    };

    const clear = () => {
      inputAutocomplete.value.value = "";
      data.filteredItems = false;
      emit("update:modelValue", "");
    };

    const dropSelection = (e) => {
      if (e.keyCode == 38) previous();
      if (e.keyCode == 40) next();
      if (e.keyCode == 13) enterClick();
    };

    const enterClick = () => {
      if (data.filteredItems != false && data.filteredItems.length > 0)
        sendValue(data.filteredItems[data.highlight]);
    };

    const previous = () => {
      if (data.filteredItems != false && data.highlight > 0) --data.highlight;
    };

    const next = () => {
      let s = data.highlight,
        l = parseInt(data.filteredItems.length);
      if (data.filteredItems != false && s < l) data.highlight++;
    };

    return {
      inputAutocomplete,
      ...toRefs(data),
      updateData,
      filterItems,
      onBlur,
      sendValue,
      clear,
      dropSelection,
      enterClick,
    };
  },
};
</script>

<style>
.autocomplete {
  position: relative;
}

.autocomplete-input {
  overflow: hidden;
  width: 100%;
  position: relative;
  box-sizing: border-box;
}

.close-mark {
  color: #808080ad;
  position: absolute;
  right: 2px;
  top: 8px;
  padding: 0 8px;
  font-style: normal;
  user-select: none;
  cursor: pointer;
}

.close-mark:hover {
  color: #9e9c9cad;
}

.autocomplete-list {
  z-index: 9999;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  border: 1px solid #ced4da;
  border-top: none;
  background-color: white;
}

.autocomplete-list ul {
  overflow: auto;
  list-style-type: none;
  margin: 0;
  padding: 0;
}

.autocomplete-list ul li {
  padding: 6px;
  cursor: default;
  font-size: 0.92rem;
  display: list-item;
  text-align: left;
}

.highlight-class {
  background-color: #efefef;
  font-weight: bold;
}

.text-muted {
  color: #6c757d !important;
}
</style>