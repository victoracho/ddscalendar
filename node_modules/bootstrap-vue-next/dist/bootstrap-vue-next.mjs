var Tn = Object.defineProperty;
var Sn = (t, e, l) => e in t ? Tn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: l }) : t[e] = l;
var ze = (t, e, l) => (Sn(t, typeof e != "symbol" ? e + "" : e, l), l);
import { computed as B, toValue as Se, unref as O, ref as x, shallowRef as bt, watch as ue, getCurrentScope as Ml, onScopeDispose as xl, shallowReadonly as kt, isRef as Vn, toRef as $, readonly as qe, customRef as _n, onMounted as Xe, nextTick as _e, getCurrentInstance as gt, reactive as nl, defineComponent as H, watchEffect as Rt, mergeModels as pe, useModel as he, onBeforeUnmount as La, openBlock as b, createElementBlock as V, Fragment as de, createElementVNode as Z, renderSlot as T, createBlock as I, Teleport as ht, mergeProps as X, normalizeClass as D, normalizeStyle as Ee, createTextVNode as se, toDisplayString as Y, createCommentVNode as ae, render as Dl, h as Ne, inject as Ve, onActivated as An, Transition as On, withCtx as P, useAttrs as Mt, resolveDynamicComponent as re, provide as tt, createVNode as ve, useSlots as Fe, normalizeProps as me, guardReactiveProps as we, withDirectives as ut, vShow as xt, renderList as Ce, TransitionGroup as jl, withModifiers as ft, vModelCheckbox as Nn, vModelRadio as In, vModelSelect as Pn, createSlots as Fa, onUnmounted as En, withKeys as Wt } from "vue";
const Dt = (t) => B(() => {
  const e = Se(t);
  return e ? `justify-content-${e}` : "";
}), ua = (t, e) => B(() => {
  const l = Se(t), a = Se(e);
  return l === !0 ? "true" : typeof l == "string" ? l : a === !1 ? "true" : l === !1 ? "false" : void 0;
});
class nt {
  constructor(e, l = {}) {
    ze(this, "cancelable", !0);
    ze(this, "componentId", null);
    ze(this, "_defaultPrevented", !1);
    ze(this, "eventType", "");
    ze(this, "nativeEvent", null);
    ze(this, "_preventDefault");
    ze(this, "relatedTarget", null);
    ze(this, "target", null);
    if (!e)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, nt.Defaults, l, { eventType: e }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(e) {
    this._defaultPrevented = e;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(e) {
    this._preventDefault = e;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class Bt extends nt {
  constructor(l, a = {}) {
    super(l, a);
    ze(this, "trigger", null);
    Object.assign(this, nt.Defaults, a, { eventType: l });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class ql extends nt {
  constructor(l, a) {
    super(l, a);
    ze(this, "from");
    ze(this, "to");
    ze(this, "direction");
    Object.assign(this, nt.Defaults, a, { eventType: l });
    const { from: o, direction: r, to: n } = a;
    this.from = o, this.to = n, this.direction = r;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const Ln = (t, e = {}) => {
  const l = (o = []) => {
    const { activeElement: r } = document;
    return r && !o.some((n) => n === r) ? r : null;
  }, a = (o) => o === l();
  try {
    t.focus(e);
  } catch (o) {
    console.error(o);
  }
  return a(t);
}, Ae = (t) => ((t == null ? void 0 : t()) ?? []).length === 0, Fn = (t) => {
  if (t.getAttribute("display") === "none")
    return !1;
  const e = t.getBoundingClientRect();
  return !!(e && e.height > 0 && e.width > 0);
}, wa = (t) => {
  const e = window.getComputedStyle(t), l = e.transitionDelay.split(",")[0] || "", a = e.transitionDuration.split(",")[0] || "", o = Number(l.slice(0, -1)) * 1e3, r = Number(a.slice(0, -1)) * 1e3;
  return o + r;
}, za = typeof window < "u" && typeof document < "u" && typeof navigator < "u", zn = (t) => (() => {
  let l = !1;
  if (za)
    try {
      const a = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          l = !0;
        }
      };
      WINDOW.addEventListener("test", a, a), WINDOW.removeEventListener("test", a, a);
    } catch {
      l = !1;
    }
  return l;
})() ? typeof t == "object" ? t : { capture: !!t || !1 } : typeof t == "object" ? t.capture : t, Hn = (t, e, l, a) => {
  t && t.addEventListener && t.addEventListener(e, l, zn(a));
}, Rn = (t, e, l, a) => {
  t && t.removeEventListener && t.removeEventListener(e, l, a);
}, sl = (t, e) => {
  (t ? Hn : Rn)(...e);
}, Mn = ["TD", "TH", "TR"], xn = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Gt = (t) => {
  if (!t || !t.target)
    return !1;
  const e = t.target;
  if ("disabled" in e && e.disabled || Mn.indexOf(e.tagName) !== -1)
    return !1;
  if (e.closest(".dropdown-menu"))
    return !0;
  const l = e.tagName === "LABEL" ? e : e.closest("label");
  if (l) {
    const a = l.getAttribute("for"), o = a ? document.getElementById(a) : l.querySelector("input, select, textarea");
    if (o && !o.disabled)
      return !0;
  }
  return e.matches(xn);
}, Wl = ["top", "right", "bottom", "left"], rl = ["start", "end"], il = /* @__PURE__ */ Wl.reduce((t, e) => t.concat(e, e + "-" + rl[0], e + "-" + rl[1]), []), et = Math.min, Ie = Math.max, ea = Math.round, Ut = Math.floor, pt = (t) => ({
  x: t,
  y: t
}), Dn = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, jn = {
  start: "end",
  end: "start"
};
function Ca(t, e, l) {
  return Ie(t, et(e, l));
}
function dt(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Ge(t) {
  return t.split("-")[0];
}
function Ze(t) {
  return t.split("-")[1];
}
function Gl(t) {
  return t === "x" ? "y" : "x";
}
function Ha(t) {
  return t === "y" ? "height" : "width";
}
function Nt(t) {
  return ["top", "bottom"].includes(Ge(t)) ? "y" : "x";
}
function Ra(t) {
  return Gl(Nt(t));
}
function Ul(t, e, l) {
  l === void 0 && (l = !1);
  const a = Ze(t), o = Ra(t), r = Ha(o);
  let n = o === "x" ? a === (l ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return e.reference[r] > e.floating[r] && (n = aa(n)), [n, aa(n)];
}
function qn(t) {
  const e = aa(t);
  return [ta(t), e, ta(e)];
}
function ta(t) {
  return t.replace(/start|end/g, (e) => jn[e]);
}
function Wn(t, e, l) {
  const a = ["left", "right"], o = ["right", "left"], r = ["top", "bottom"], n = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return l ? e ? o : a : e ? a : o;
    case "left":
    case "right":
      return e ? r : n;
    default:
      return [];
  }
}
function Gn(t, e, l, a) {
  const o = Ze(t);
  let r = Wn(Ge(t), l === "start", a);
  return o && (r = r.map((n) => n + "-" + o), e && (r = r.concat(r.map(ta)))), r;
}
function aa(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Dn[e]);
}
function Un(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Ma(t) {
  return typeof t != "number" ? Un(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function _t(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}
function ul(t, e, l) {
  let {
    reference: a,
    floating: o
  } = t;
  const r = Nt(e), n = Ra(e), s = Ha(n), i = Ge(e), u = r === "y", d = a.x + a.width / 2 - o.width / 2, p = a.y + a.height / 2 - o.height / 2, f = a[s] / 2 - o[s] / 2;
  let m;
  switch (i) {
    case "top":
      m = {
        x: d,
        y: a.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: d,
        y: a.y + a.height
      };
      break;
    case "right":
      m = {
        x: a.x + a.width,
        y: p
      };
      break;
    case "left":
      m = {
        x: a.x - o.width,
        y: p
      };
      break;
    default:
      m = {
        x: a.x,
        y: a.y
      };
  }
  switch (Ze(e)) {
    case "start":
      m[n] -= f * (l && u ? -1 : 1);
      break;
    case "end":
      m[n] += f * (l && u ? -1 : 1);
      break;
  }
  return m;
}
const Xn = async (t, e, l) => {
  const {
    placement: a = "bottom",
    strategy: o = "absolute",
    middleware: r = [],
    platform: n
  } = l, s = r.filter(Boolean), i = await (n.isRTL == null ? void 0 : n.isRTL(e));
  let u = await n.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: d,
    y: p
  } = ul(u, a, i), f = a, m = {}, y = 0;
  for (let c = 0; c < s.length; c++) {
    const {
      name: g,
      fn: v
    } = s[c], {
      x: h,
      y: k,
      data: C,
      reset: w
    } = await v({
      x: d,
      y: p,
      initialPlacement: a,
      placement: f,
      strategy: o,
      middlewareData: m,
      rects: u,
      platform: n,
      elements: {
        reference: t,
        floating: e
      }
    });
    d = h ?? d, p = k ?? p, m = {
      ...m,
      [g]: {
        ...m[g],
        ...C
      }
    }, w && y <= 50 && (y++, typeof w == "object" && (w.placement && (f = w.placement), w.rects && (u = w.rects === !0 ? await n.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : w.rects), {
      x: d,
      y: p
    } = ul(u, f, i)), c = -1);
  }
  return {
    x: d,
    y: p,
    placement: f,
    strategy: o,
    middlewareData: m
  };
};
async function At(t, e) {
  var l;
  e === void 0 && (e = {});
  const {
    x: a,
    y: o,
    platform: r,
    rects: n,
    elements: s,
    strategy: i
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: p = "floating",
    altBoundary: f = !1,
    padding: m = 0
  } = dt(e, t), y = Ma(m), g = s[f ? p === "floating" ? "reference" : "floating" : p], v = _t(await r.getClippingRect({
    element: (l = await (r.isElement == null ? void 0 : r.isElement(g))) == null || l ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: d,
    strategy: i
  })), h = p === "floating" ? {
    ...n.floating,
    x: a,
    y: o
  } : n.reference, k = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(s.floating)), C = await (r.isElement == null ? void 0 : r.isElement(k)) ? await (r.getScale == null ? void 0 : r.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = _t(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: h,
    offsetParent: k,
    strategy: i
  }) : h);
  return {
    top: (v.top - w.top + y.top) / C.y,
    bottom: (w.bottom - v.bottom + y.bottom) / C.y,
    left: (v.left - w.left + y.left) / C.x,
    right: (w.right - v.right + y.right) / C.x
  };
}
const Kn = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: l,
      y: a,
      placement: o,
      rects: r,
      platform: n,
      elements: s,
      middlewareData: i
    } = e, {
      element: u,
      padding: d = 0
    } = dt(t, e) || {};
    if (u == null)
      return {};
    const p = Ma(d), f = {
      x: l,
      y: a
    }, m = Ra(o), y = Ha(m), c = await n.getDimensions(u), g = m === "y", v = g ? "top" : "left", h = g ? "bottom" : "right", k = g ? "clientHeight" : "clientWidth", C = r.reference[y] + r.reference[m] - f[m] - r.floating[y], w = f[m] - r.reference[m], _ = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(u));
    let F = _ ? _[k] : 0;
    (!F || !await (n.isElement == null ? void 0 : n.isElement(_))) && (F = s.floating[k] || r.floating[y]);
    const Q = C / 2 - w / 2, W = F / 2 - c[y] / 2 - 1, L = et(p[v], W), J = et(p[h], W), R = L, le = F - c[y] - J, N = F / 2 - c[y] / 2 + Q, S = Ca(R, N, le), E = !i.arrow && Ze(o) != null && N !== S && r.reference[y] / 2 - (N < R ? L : J) - c[y] / 2 < 0, M = E ? N < R ? N - R : N - le : 0;
    return {
      [m]: f[m] + M,
      data: {
        [m]: S,
        centerOffset: N - S - M,
        ...E && {
          alignmentOffset: M
        }
      },
      reset: E
    };
  }
});
function Yn(t, e, l) {
  return (t ? [...l.filter((o) => Ze(o) === t), ...l.filter((o) => Ze(o) !== t)] : l.filter((o) => Ge(o) === o)).filter((o) => t ? Ze(o) === t || (e ? ta(o) !== o : !1) : !0);
}
const Jn = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var l, a, o;
      const {
        rects: r,
        middlewareData: n,
        placement: s,
        platform: i,
        elements: u
      } = e, {
        crossAxis: d = !1,
        alignment: p,
        allowedPlacements: f = il,
        autoAlignment: m = !0,
        ...y
      } = dt(t, e), c = p !== void 0 || f === il ? Yn(p || null, m, f) : f, g = await At(e, y), v = ((l = n.autoPlacement) == null ? void 0 : l.index) || 0, h = c[v];
      if (h == null)
        return {};
      const k = Ul(h, r, await (i.isRTL == null ? void 0 : i.isRTL(u.floating)));
      if (s !== h)
        return {
          reset: {
            placement: c[0]
          }
        };
      const C = [g[Ge(h)], g[k[0]], g[k[1]]], w = [...((a = n.autoPlacement) == null ? void 0 : a.overflows) || [], {
        placement: h,
        overflows: C
      }], _ = c[v + 1];
      if (_)
        return {
          data: {
            index: v + 1,
            overflows: w
          },
          reset: {
            placement: _
          }
        };
      const F = w.map((L) => {
        const J = Ze(L.placement);
        return [L.placement, J && d ? (
          // Check along the mainAxis and main crossAxis side.
          L.overflows.slice(0, 2).reduce((R, le) => R + le, 0)
        ) : (
          // Check only the mainAxis.
          L.overflows[0]
        ), L.overflows];
      }).sort((L, J) => L[1] - J[1]), W = ((o = F.filter((L) => L[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        Ze(L[0]) ? 2 : 3
      ).every((J) => J <= 0))[0]) == null ? void 0 : o[0]) || F[0][0];
      return W !== s ? {
        data: {
          index: v + 1,
          overflows: w
        },
        reset: {
          placement: W
        }
      } : {};
    }
  };
}, Zn = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var l, a;
      const {
        placement: o,
        middlewareData: r,
        rects: n,
        initialPlacement: s,
        platform: i,
        elements: u
      } = e, {
        mainAxis: d = !0,
        crossAxis: p = !0,
        fallbackPlacements: f,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: y = "none",
        flipAlignment: c = !0,
        ...g
      } = dt(t, e);
      if ((l = r.arrow) != null && l.alignmentOffset)
        return {};
      const v = Ge(o), h = Ge(s) === s, k = await (i.isRTL == null ? void 0 : i.isRTL(u.floating)), C = f || (h || !c ? [aa(s)] : qn(s));
      !f && y !== "none" && C.push(...Gn(s, c, y, k));
      const w = [s, ...C], _ = await At(e, g), F = [];
      let Q = ((a = r.flip) == null ? void 0 : a.overflows) || [];
      if (d && F.push(_[v]), p) {
        const R = Ul(o, n, k);
        F.push(_[R[0]], _[R[1]]);
      }
      if (Q = [...Q, {
        placement: o,
        overflows: F
      }], !F.every((R) => R <= 0)) {
        var W, L;
        const R = (((W = r.flip) == null ? void 0 : W.index) || 0) + 1, le = w[R];
        if (le)
          return {
            data: {
              index: R,
              overflows: Q
            },
            reset: {
              placement: le
            }
          };
        let N = (L = Q.filter((S) => S.overflows[0] <= 0).sort((S, E) => S.overflows[1] - E.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!N)
          switch (m) {
            case "bestFit": {
              var J;
              const S = (J = Q.map((E) => [E.placement, E.overflows.filter((M) => M > 0).reduce((M, j) => M + j, 0)]).sort((E, M) => E[1] - M[1])[0]) == null ? void 0 : J[0];
              S && (N = S);
              break;
            }
            case "initialPlacement":
              N = s;
              break;
          }
        if (o !== N)
          return {
            reset: {
              placement: N
            }
          };
      }
      return {};
    }
  };
};
function dl(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function cl(t) {
  return Wl.some((e) => t[e] >= 0);
}
const Qn = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: l
      } = e, {
        strategy: a = "referenceHidden",
        ...o
      } = dt(t, e);
      switch (a) {
        case "referenceHidden": {
          const r = await At(e, {
            ...o,
            elementContext: "reference"
          }), n = dl(r, l.reference);
          return {
            data: {
              referenceHiddenOffsets: n,
              referenceHidden: cl(n)
            }
          };
        }
        case "escaped": {
          const r = await At(e, {
            ...o,
            altBoundary: !0
          }), n = dl(r, l.floating);
          return {
            data: {
              escapedOffsets: n,
              escaped: cl(n)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function Xl(t) {
  const e = et(...t.map((r) => r.left)), l = et(...t.map((r) => r.top)), a = Ie(...t.map((r) => r.right)), o = Ie(...t.map((r) => r.bottom));
  return {
    x: e,
    y: l,
    width: a - e,
    height: o - l
  };
}
function es(t) {
  const e = t.slice().sort((o, r) => o.y - r.y), l = [];
  let a = null;
  for (let o = 0; o < e.length; o++) {
    const r = e[o];
    !a || r.y - a.y > a.height / 2 ? l.push([r]) : l[l.length - 1].push(r), a = r;
  }
  return l.map((o) => _t(Xl(o)));
}
const ts = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(e) {
      const {
        placement: l,
        elements: a,
        rects: o,
        platform: r,
        strategy: n
      } = e, {
        padding: s = 2,
        x: i,
        y: u
      } = dt(t, e), d = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(a.reference)) || []), p = es(d), f = _t(Xl(d)), m = Ma(s);
      function y() {
        if (p.length === 2 && p[0].left > p[1].right && i != null && u != null)
          return p.find((g) => i > g.left - m.left && i < g.right + m.right && u > g.top - m.top && u < g.bottom + m.bottom) || f;
        if (p.length >= 2) {
          if (Nt(l) === "y") {
            const L = p[0], J = p[p.length - 1], R = Ge(l) === "top", le = L.top, N = J.bottom, S = R ? L.left : J.left, E = R ? L.right : J.right, M = E - S, j = N - le;
            return {
              top: le,
              bottom: N,
              left: S,
              right: E,
              width: M,
              height: j,
              x: S,
              y: le
            };
          }
          const g = Ge(l) === "left", v = Ie(...p.map((L) => L.right)), h = et(...p.map((L) => L.left)), k = p.filter((L) => g ? L.left === h : L.right === v), C = k[0].top, w = k[k.length - 1].bottom, _ = h, F = v, Q = F - _, W = w - C;
          return {
            top: C,
            bottom: w,
            left: _,
            right: F,
            width: Q,
            height: W,
            x: _,
            y: C
          };
        }
        return f;
      }
      const c = await r.getElementRects({
        reference: {
          getBoundingClientRect: y
        },
        floating: a.floating,
        strategy: n
      });
      return o.reference.x !== c.reference.x || o.reference.y !== c.reference.y || o.reference.width !== c.reference.width || o.reference.height !== c.reference.height ? {
        reset: {
          rects: c
        }
      } : {};
    }
  };
};
async function as(t, e) {
  const {
    placement: l,
    platform: a,
    elements: o
  } = t, r = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)), n = Ge(l), s = Ze(l), i = Nt(l) === "y", u = ["left", "top"].includes(n) ? -1 : 1, d = r && i ? -1 : 1, p = dt(e, t);
  let {
    mainAxis: f,
    crossAxis: m,
    alignmentAxis: y
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...p
  };
  return s && typeof y == "number" && (m = s === "end" ? y * -1 : y), i ? {
    x: m * d,
    y: f * u
  } : {
    x: f * u,
    y: m * d
  };
}
const Kl = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var l, a;
      const {
        x: o,
        y: r,
        placement: n,
        middlewareData: s
      } = e, i = await as(e, t);
      return n === ((l = s.offset) == null ? void 0 : l.placement) && (a = s.arrow) != null && a.alignmentOffset ? {} : {
        x: o + i.x,
        y: r + i.y,
        data: {
          ...i,
          placement: n
        }
      };
    }
  };
}, ls = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: l,
        y: a,
        placement: o
      } = e, {
        mainAxis: r = !0,
        crossAxis: n = !1,
        limiter: s = {
          fn: (g) => {
            let {
              x: v,
              y: h
            } = g;
            return {
              x: v,
              y: h
            };
          }
        },
        ...i
      } = dt(t, e), u = {
        x: l,
        y: a
      }, d = await At(e, i), p = Nt(Ge(o)), f = Gl(p);
      let m = u[f], y = u[p];
      if (r) {
        const g = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", h = m + d[g], k = m - d[v];
        m = Ca(h, m, k);
      }
      if (n) {
        const g = p === "y" ? "top" : "left", v = p === "y" ? "bottom" : "right", h = y + d[g], k = y - d[v];
        y = Ca(h, y, k);
      }
      const c = s.fn({
        ...e,
        [f]: m,
        [p]: y
      });
      return {
        ...c,
        data: {
          x: c.x - l,
          y: c.y - a
        }
      };
    }
  };
}, os = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      const {
        placement: l,
        rects: a,
        platform: o,
        elements: r
      } = e, {
        apply: n = () => {
        },
        ...s
      } = dt(t, e), i = await At(e, s), u = Ge(l), d = Ze(l), p = Nt(l) === "y", {
        width: f,
        height: m
      } = a.floating;
      let y, c;
      u === "top" || u === "bottom" ? (y = u, c = d === (await (o.isRTL == null ? void 0 : o.isRTL(r.floating)) ? "start" : "end") ? "left" : "right") : (c = u, y = d === "end" ? "top" : "bottom");
      const g = m - i[y], v = f - i[c], h = !e.middlewareData.shift;
      let k = g, C = v;
      if (p) {
        const _ = f - i.left - i.right;
        C = d || h ? et(v, _) : _;
      } else {
        const _ = m - i.top - i.bottom;
        k = d || h ? et(g, _) : _;
      }
      if (h && !d) {
        const _ = Ie(i.left, 0), F = Ie(i.right, 0), Q = Ie(i.top, 0), W = Ie(i.bottom, 0);
        p ? C = f - 2 * (_ !== 0 || F !== 0 ? _ + F : Ie(i.left, i.right)) : k = m - 2 * (Q !== 0 || W !== 0 ? Q + W : Ie(i.top, i.bottom));
      }
      await n({
        ...e,
        availableWidth: C,
        availableHeight: k
      });
      const w = await o.getDimensions(r.floating);
      return f !== w.width || m !== w.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function st(t) {
  return xa(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function xe(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ct(t) {
  var e;
  return (e = (xa(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function xa(t) {
  return t instanceof Node || t instanceof xe(t).Node;
}
function rt(t) {
  return t instanceof Element || t instanceof xe(t).Element;
}
function at(t) {
  return t instanceof HTMLElement || t instanceof xe(t).HTMLElement;
}
function fl(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof xe(t).ShadowRoot;
}
function jt(t) {
  const {
    overflow: e,
    overflowX: l,
    overflowY: a,
    display: o
  } = Ue(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + a + l) && !["inline", "contents"].includes(o);
}
function ns(t) {
  return ["table", "td", "th"].includes(st(t));
}
function Da(t) {
  const e = ja(), l = Ue(t);
  return l.transform !== "none" || l.perspective !== "none" || (l.containerType ? l.containerType !== "normal" : !1) || !e && (l.backdropFilter ? l.backdropFilter !== "none" : !1) || !e && (l.filter ? l.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((a) => (l.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some((a) => (l.contain || "").includes(a));
}
function Yl(t) {
  let e = Ot(t);
  for (; at(e) && !da(e); ) {
    if (Da(e))
      return e;
    e = Ot(e);
  }
  return null;
}
function ja() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function da(t) {
  return ["html", "body", "#document"].includes(st(t));
}
function Ue(t) {
  return xe(t).getComputedStyle(t);
}
function ca(t) {
  return rt(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function Ot(t) {
  if (st(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    fl(t) && t.host || // Fallback.
    ct(t)
  );
  return fl(e) ? e.host : e;
}
function Jl(t) {
  const e = Ot(t);
  return da(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : at(e) && jt(e) ? e : Jl(e);
}
function Ft(t, e, l) {
  var a;
  e === void 0 && (e = []), l === void 0 && (l = !0);
  const o = Jl(t), r = o === ((a = t.ownerDocument) == null ? void 0 : a.body), n = xe(o);
  return r ? e.concat(n, n.visualViewport || [], jt(o) ? o : [], n.frameElement && l ? Ft(n.frameElement) : []) : e.concat(o, Ft(o, [], l));
}
function Zl(t) {
  const e = Ue(t);
  let l = parseFloat(e.width) || 0, a = parseFloat(e.height) || 0;
  const o = at(t), r = o ? t.offsetWidth : l, n = o ? t.offsetHeight : a, s = ea(l) !== r || ea(a) !== n;
  return s && (l = r, a = n), {
    width: l,
    height: a,
    $: s
  };
}
function qa(t) {
  return rt(t) ? t : t.contextElement;
}
function Vt(t) {
  const e = qa(t);
  if (!at(e))
    return pt(1);
  const l = e.getBoundingClientRect(), {
    width: a,
    height: o,
    $: r
  } = Zl(e);
  let n = (r ? ea(l.width) : l.width) / a, s = (r ? ea(l.height) : l.height) / o;
  return (!n || !Number.isFinite(n)) && (n = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: n,
    y: s
  };
}
const ss = /* @__PURE__ */ pt(0);
function Ql(t) {
  const e = xe(t);
  return !ja() || !e.visualViewport ? ss : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function rs(t, e, l) {
  return e === void 0 && (e = !1), !l || e && l !== xe(t) ? !1 : e;
}
function yt(t, e, l, a) {
  e === void 0 && (e = !1), l === void 0 && (l = !1);
  const o = t.getBoundingClientRect(), r = qa(t);
  let n = pt(1);
  e && (a ? rt(a) && (n = Vt(a)) : n = Vt(t));
  const s = rs(r, l, a) ? Ql(r) : pt(0);
  let i = (o.left + s.x) / n.x, u = (o.top + s.y) / n.y, d = o.width / n.x, p = o.height / n.y;
  if (r) {
    const f = xe(r), m = a && rt(a) ? xe(a) : a;
    let y = f.frameElement;
    for (; y && a && m !== f; ) {
      const c = Vt(y), g = y.getBoundingClientRect(), v = Ue(y), h = g.left + (y.clientLeft + parseFloat(v.paddingLeft)) * c.x, k = g.top + (y.clientTop + parseFloat(v.paddingTop)) * c.y;
      i *= c.x, u *= c.y, d *= c.x, p *= c.y, i += h, u += k, y = xe(y).frameElement;
    }
  }
  return _t({
    width: d,
    height: p,
    x: i,
    y: u
  });
}
const is = [":popover-open", ":modal"];
function eo(t) {
  let e = !1, l = 0, a = 0;
  function o(r) {
    try {
      e = e || t.matches(r);
    } catch {
    }
  }
  if (is.forEach((r) => {
    o(r);
  }), e) {
    const r = Yl(t);
    if (r) {
      const n = r.getBoundingClientRect();
      l = n.x, a = n.y;
    }
  }
  return [e, l, a];
}
function us(t) {
  let {
    elements: e,
    rect: l,
    offsetParent: a,
    strategy: o
  } = t;
  const r = ct(a), [n] = e ? eo(e.floating) : [!1];
  if (a === r || n)
    return l;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, i = pt(1);
  const u = pt(0), d = at(a);
  if ((d || !d && o !== "fixed") && ((st(a) !== "body" || jt(r)) && (s = ca(a)), at(a))) {
    const p = yt(a);
    i = Vt(a), u.x = p.x + a.clientLeft, u.y = p.y + a.clientTop;
  }
  return {
    width: l.width * i.x,
    height: l.height * i.y,
    x: l.x * i.x - s.scrollLeft * i.x + u.x,
    y: l.y * i.y - s.scrollTop * i.y + u.y
  };
}
function ds(t) {
  return Array.from(t.getClientRects());
}
function to(t) {
  return yt(ct(t)).left + ca(t).scrollLeft;
}
function cs(t) {
  const e = ct(t), l = ca(t), a = t.ownerDocument.body, o = Ie(e.scrollWidth, e.clientWidth, a.scrollWidth, a.clientWidth), r = Ie(e.scrollHeight, e.clientHeight, a.scrollHeight, a.clientHeight);
  let n = -l.scrollLeft + to(t);
  const s = -l.scrollTop;
  return Ue(a).direction === "rtl" && (n += Ie(e.clientWidth, a.clientWidth) - o), {
    width: o,
    height: r,
    x: n,
    y: s
  };
}
function fs(t, e) {
  const l = xe(t), a = ct(t), o = l.visualViewport;
  let r = a.clientWidth, n = a.clientHeight, s = 0, i = 0;
  if (o) {
    r = o.width, n = o.height;
    const u = ja();
    (!u || u && e === "fixed") && (s = o.offsetLeft, i = o.offsetTop);
  }
  return {
    width: r,
    height: n,
    x: s,
    y: i
  };
}
function vs(t, e) {
  const l = yt(t, !0, e === "fixed"), a = l.top + t.clientTop, o = l.left + t.clientLeft, r = at(t) ? Vt(t) : pt(1), n = t.clientWidth * r.x, s = t.clientHeight * r.y, i = o * r.x, u = a * r.y;
  return {
    width: n,
    height: s,
    x: i,
    y: u
  };
}
function vl(t, e, l) {
  let a;
  if (e === "viewport")
    a = fs(t, l);
  else if (e === "document")
    a = cs(ct(t));
  else if (rt(e))
    a = vs(e, l);
  else {
    const o = Ql(t);
    a = {
      ...e,
      x: e.x - o.x,
      y: e.y - o.y
    };
  }
  return _t(a);
}
function ao(t, e) {
  const l = Ot(t);
  return l === e || !rt(l) || da(l) ? !1 : Ue(l).position === "fixed" || ao(l, e);
}
function ps(t, e) {
  const l = e.get(t);
  if (l)
    return l;
  let a = Ft(t, [], !1).filter((s) => rt(s) && st(s) !== "body"), o = null;
  const r = Ue(t).position === "fixed";
  let n = r ? Ot(t) : t;
  for (; rt(n) && !da(n); ) {
    const s = Ue(n), i = Da(n);
    !i && s.position === "fixed" && (o = null), (r ? !i && !o : !i && s.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || jt(n) && !i && ao(t, n)) ? a = a.filter((d) => d !== n) : o = s, n = Ot(n);
  }
  return e.set(t, a), a;
}
function ms(t) {
  let {
    element: e,
    boundary: l,
    rootBoundary: a,
    strategy: o
  } = t;
  const n = [...l === "clippingAncestors" ? ps(e, this._c) : [].concat(l), a], s = n[0], i = n.reduce((u, d) => {
    const p = vl(e, d, o);
    return u.top = Ie(p.top, u.top), u.right = et(p.right, u.right), u.bottom = et(p.bottom, u.bottom), u.left = Ie(p.left, u.left), u;
  }, vl(e, s, o));
  return {
    width: i.right - i.left,
    height: i.bottom - i.top,
    x: i.left,
    y: i.top
  };
}
function bs(t) {
  const {
    width: e,
    height: l
  } = Zl(t);
  return {
    width: e,
    height: l
  };
}
function ys(t, e, l, a) {
  const o = at(e), r = ct(e), n = l === "fixed", s = yt(t, !0, n, e);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = pt(0);
  if (o || !o && !n)
    if ((st(e) !== "body" || jt(r)) && (i = ca(e)), o) {
      const c = yt(e, !0, n, e);
      u.x = c.x + e.clientLeft, u.y = c.y + e.clientTop;
    } else
      r && (u.x = to(r));
  let d = s.left + i.scrollLeft - u.x, p = s.top + i.scrollTop - u.y;
  const [f, m, y] = eo(a);
  return f && (d += m, p += y, o && (d += e.clientLeft, p += e.clientTop)), {
    x: d,
    y: p,
    width: s.width,
    height: s.height
  };
}
function pl(t, e) {
  return !at(t) || Ue(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function lo(t, e) {
  const l = xe(t);
  if (!at(t))
    return l;
  let a = pl(t, e);
  for (; a && ns(a) && Ue(a).position === "static"; )
    a = pl(a, e);
  return a && (st(a) === "html" || st(a) === "body" && Ue(a).position === "static" && !Da(a)) ? l : a || Yl(t) || l;
}
const gs = async function(t) {
  const e = this.getOffsetParent || lo, l = this.getDimensions;
  return {
    reference: ys(t.reference, await e(t.floating), t.strategy, t.floating),
    floating: {
      x: 0,
      y: 0,
      ...await l(t.floating)
    }
  };
};
function hs(t) {
  return Ue(t).direction === "rtl";
}
const Bs = {
  convertOffsetParentRelativeRectToViewportRelativeRect: us,
  getDocumentElement: ct,
  getClippingRect: ms,
  getOffsetParent: lo,
  getElementRects: gs,
  getClientRects: ds,
  getDimensions: bs,
  getScale: Vt,
  isElement: rt,
  isRTL: hs
};
function ws(t, e) {
  let l = null, a;
  const o = ct(t);
  function r() {
    var s;
    clearTimeout(a), (s = l) == null || s.disconnect(), l = null;
  }
  function n(s, i) {
    s === void 0 && (s = !1), i === void 0 && (i = 1), r();
    const {
      left: u,
      top: d,
      width: p,
      height: f
    } = t.getBoundingClientRect();
    if (s || e(), !p || !f)
      return;
    const m = Ut(d), y = Ut(o.clientWidth - (u + p)), c = Ut(o.clientHeight - (d + f)), g = Ut(u), h = {
      rootMargin: -m + "px " + -y + "px " + -c + "px " + -g + "px",
      threshold: Ie(0, et(1, i)) || 1
    };
    let k = !0;
    function C(w) {
      const _ = w[0].intersectionRatio;
      if (_ !== i) {
        if (!k)
          return n();
        _ ? n(!1, _) : a = setTimeout(() => {
          n(!1, 1e-7);
        }, 100);
      }
      k = !1;
    }
    try {
      l = new IntersectionObserver(C, {
        ...h,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      l = new IntersectionObserver(C, h);
    }
    l.observe(t);
  }
  return n(!0), r;
}
function oo(t, e, l, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: r = !0,
    elementResize: n = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: i = !1
  } = a, u = qa(t), d = o || r ? [...u ? Ft(u) : [], ...Ft(e)] : [];
  d.forEach((v) => {
    o && v.addEventListener("scroll", l, {
      passive: !0
    }), r && v.addEventListener("resize", l);
  });
  const p = u && s ? ws(u, l) : null;
  let f = -1, m = null;
  n && (m = new ResizeObserver((v) => {
    let [h] = v;
    h && h.target === u && m && (m.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var k;
      (k = m) == null || k.observe(e);
    })), l();
  }), u && !i && m.observe(u), m.observe(e));
  let y, c = i ? yt(t) : null;
  i && g();
  function g() {
    const v = yt(t);
    c && (v.x !== c.x || v.y !== c.y || v.width !== c.width || v.height !== c.height) && l(), c = v, y = requestAnimationFrame(g);
  }
  return l(), () => {
    var v;
    d.forEach((h) => {
      o && h.removeEventListener("scroll", l), r && h.removeEventListener("resize", l);
    }), p == null || p(), (v = m) == null || v.disconnect(), m = null, i && cancelAnimationFrame(y);
  };
}
const Cs = Jn, no = ls, so = Zn, ro = os, ks = Qn, $s = Kn, Ts = ts, Ss = (t, e, l) => {
  const a = /* @__PURE__ */ new Map(), o = {
    platform: Bs,
    ...l
  }, r = {
    ...o.platform,
    _c: a
  };
  return Xn(t, e, {
    ...o,
    platform: r
  });
};
function Vs(t) {
  return t != null && typeof t == "object" && "$el" in t;
}
function ka(t) {
  if (Vs(t)) {
    const e = t.$el;
    return xa(e) && st(e) === "#comment" ? null : e;
  }
  return t;
}
function _s(t) {
  return {
    name: "arrow",
    options: t,
    fn(e) {
      const l = ka(O(t.element));
      return l == null ? {} : $s({
        element: l,
        padding: t.padding
      }).fn(e);
    }
  };
}
function io(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function ml(t, e) {
  const l = io(t);
  return Math.round(e * l) / l;
}
function uo(t, e, l) {
  l === void 0 && (l = {});
  const a = l.whileElementsMounted, o = B(() => {
    var F;
    return (F = O(l.open)) != null ? F : !0;
  }), r = B(() => O(l.middleware)), n = B(() => {
    var F;
    return (F = O(l.placement)) != null ? F : "bottom";
  }), s = B(() => {
    var F;
    return (F = O(l.strategy)) != null ? F : "absolute";
  }), i = B(() => {
    var F;
    return (F = O(l.transform)) != null ? F : !0;
  }), u = B(() => ka(t.value)), d = B(() => ka(e.value)), p = x(0), f = x(0), m = x(s.value), y = x(n.value), c = bt({}), g = x(!1), v = B(() => {
    const F = {
      position: m.value,
      left: "0",
      top: "0"
    };
    if (!d.value)
      return F;
    const Q = ml(d.value, p.value), W = ml(d.value, f.value);
    return i.value ? {
      ...F,
      transform: "translate(" + Q + "px, " + W + "px)",
      ...io(d.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: m.value,
      left: Q + "px",
      top: W + "px"
    };
  });
  let h;
  function k() {
    u.value == null || d.value == null || Ss(u.value, d.value, {
      middleware: r.value,
      placement: n.value,
      strategy: s.value
    }).then((F) => {
      p.value = F.x, f.value = F.y, m.value = F.strategy, y.value = F.placement, c.value = F.middlewareData, g.value = !0;
    });
  }
  function C() {
    typeof h == "function" && (h(), h = void 0);
  }
  function w() {
    if (C(), a === void 0) {
      k();
      return;
    }
    if (u.value != null && d.value != null) {
      h = a(u.value, d.value, k);
      return;
    }
  }
  function _() {
    o.value || (g.value = !1);
  }
  return ue([r, n, s], k, {
    flush: "sync"
  }), ue([u, d], w, {
    flush: "sync"
  }), ue(o, _, {
    flush: "sync"
  }), Ml() && xl(C), {
    x: kt(p),
    y: kt(f),
    strategy: kt(m),
    placement: kt(y),
    middlewareData: kt(c),
    isPositioned: kt(g),
    floatingStyles: v,
    update: k
  };
}
const As = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Os = /^aria-[\w-]*$/i, Ns = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Is = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Ps = (t, e) => {
  const l = t.nodeName.toLowerCase();
  return e.includes(l) ? As.has(l) ? !!(Ns.test(t.nodeValue || "") || Is.test(t.nodeValue || "")) : !0 : e.filter((a) => a instanceof RegExp).some((a) => a.test(l));
}, $t = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Os],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, Tt = (t, e, l) => {
  if (!t.length)
    return t;
  if (l && typeof l == "function")
    return l(t);
  const o = new window.DOMParser().parseFromString(t, "text/html"), r = o.body.querySelectorAll("*");
  for (const n of r) {
    const s = n.nodeName.toLowerCase();
    if (!Object.keys(e).includes(s)) {
      n.remove();
      continue;
    }
    const i = n.attributes, u = [...e["*"] || [], ...e[s] || []];
    for (const d of i)
      Ps(d, u) || n.removeAttribute(d.nodeName);
  }
  return o.body.innerHTML;
};
function it(t) {
  return Ml() ? (xl(t), !0) : !1;
}
function Es(t, e) {
  if (typeof Symbol < "u") {
    const l = { ...t };
    return Object.defineProperty(l, Symbol.iterator, {
      enumerable: !1,
      value() {
        let a = 0;
        return {
          next: () => ({
            value: e[a++],
            done: a > e.length
          })
        };
      }
    }), l;
  } else
    return Object.assign([...e], t);
}
function Le(t) {
  return typeof t == "function" ? t() : O(t);
}
const la = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Ls = (t) => typeof t < "u", co = (t) => t != null, Fs = Object.prototype.toString, zs = (t) => Fs.call(t) === "[object Object]", We = () => {
}, $a = /* @__PURE__ */ Hs();
function Hs() {
  var t, e;
  return la && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function fo(t, e) {
  function l(...a) {
    return new Promise((o, r) => {
      Promise.resolve(t(() => e.apply(this, a), { fn: e, thisArg: this, args: a })).then(o).catch(r);
    });
  }
  return l;
}
const vo = (t) => t();
function Rs(t, e = {}) {
  let l, a, o = We;
  const r = (s) => {
    clearTimeout(s), o(), o = We;
  };
  return (s) => {
    const i = Le(t), u = Le(e.maxWait);
    return l && r(l), i <= 0 || u !== void 0 && u <= 0 ? (a && (r(a), a = null), Promise.resolve(s())) : new Promise((d, p) => {
      o = e.rejectOnCancel ? p : d, u && !a && (a = setTimeout(() => {
        l && r(l), a = null, d(s());
      }, u)), l = setTimeout(() => {
        a && r(a), a = null, d(s());
      }, i);
    });
  };
}
function Ms(t = vo) {
  const e = x(!0);
  function l() {
    e.value = !1;
  }
  function a() {
    e.value = !0;
  }
  const o = (...r) => {
    e.value && t(...r);
  };
  return { isActive: qe(e), pause: l, resume: a, eventFilter: o };
}
function xs(t) {
  const e = /* @__PURE__ */ Object.create(null);
  return (l) => e[l] || (e[l] = t(l));
}
const Ds = /-(\w)/g, js = xs((t) => t.replace(Ds, (e, l) => l ? l.toUpperCase() : ""));
function qs(t) {
  return t || gt();
}
function po(...t) {
  if (t.length !== 1)
    return $(...t);
  const e = t[0];
  return typeof e == "function" ? qe(_n(() => ({ get: e, set: We }))) : x(e);
}
function Ws(t, e = 200, l = {}) {
  return fo(
    Rs(e, l),
    t
  );
}
function Gs(t, e, l = {}) {
  const {
    eventFilter: a = vo,
    ...o
  } = l;
  return ue(
    t,
    fo(
      a,
      e
    ),
    o
  );
}
function Ta(t, e, l = {}) {
  const {
    eventFilter: a,
    ...o
  } = l, { eventFilter: r, pause: n, resume: s, isActive: i } = Ms(a);
  return { stop: Gs(
    t,
    e,
    {
      ...o,
      eventFilter: r
    }
  ), pause: n, resume: s, isActive: i };
}
function Sa(t, e, ...[l]) {
  const {
    flush: a = "sync",
    deep: o = !1,
    immediate: r = !0,
    direction: n = "both",
    transform: s = {}
  } = l || {}, i = [], u = "ltr" in s && s.ltr || ((f) => f), d = "rtl" in s && s.rtl || ((f) => f);
  return (n === "both" || n === "ltr") && i.push(Ta(
    t,
    (f) => {
      i.forEach((m) => m.pause()), e.value = u(f), i.forEach((m) => m.resume());
    },
    { flush: a, deep: o, immediate: r }
  )), (n === "both" || n === "rtl") && i.push(Ta(
    e,
    (f) => {
      i.forEach((m) => m.pause()), t.value = d(f), i.forEach((m) => m.resume());
    },
    { flush: a, deep: o, immediate: r }
  )), () => {
    i.forEach((f) => f.stop());
  };
}
function mo(t, e = !0, l) {
  qs() ? Xe(t, l) : e ? t() : _e(t);
}
function bo(t, e = 1e3, l = {}) {
  const {
    immediate: a = !0,
    immediateCallback: o = !1
  } = l;
  let r = null;
  const n = x(!1);
  function s() {
    r && (clearInterval(r), r = null);
  }
  function i() {
    n.value = !1, s();
  }
  function u() {
    const d = Le(e);
    d <= 0 || (n.value = !0, o && t(), s(), r = setInterval(t, d));
  }
  if (a && la && u(), Vn(e) || typeof e == "function") {
    const d = ue(e, () => {
      n.value && la && u();
    });
    it(d);
  }
  return it(i), {
    isActive: n,
    pause: i,
    resume: u
  };
}
function be(t, e = {}) {
  const {
    method: l = "parseFloat",
    radix: a,
    nanToZero: o
  } = e;
  return B(() => {
    let r = Le(t);
    return typeof r == "string" && (r = Number[l](r, a)), o && Number.isNaN(r) && (r = 0), r;
  });
}
function zt(t = {}) {
  const {
    inheritAttrs: e = !0
  } = t, l = bt(), a = /* @__PURE__ */ H({
    setup(r, { slots: n }) {
      return () => {
        l.value = n.default;
      };
    }
  }), o = /* @__PURE__ */ H({
    inheritAttrs: e,
    setup(r, { attrs: n, slots: s }) {
      return () => {
        var i;
        if (!l.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const u = (i = l.value) == null ? void 0 : i.call(l, { ...Us(n), $slots: s });
        return e && (u == null ? void 0 : u.length) === 1 ? u[0] : u;
      };
    }
  });
  return Es(
    { define: a, reuse: o },
    [a, o]
  );
}
function Us(t) {
  const e = {};
  for (const l in t)
    e[js(l)] = t[l];
  return e;
}
function Me(t) {
  var e;
  const l = Le(t);
  return (e = l == null ? void 0 : l.$el) != null ? e : l;
}
const De = la ? window : void 0;
function ke(...t) {
  let e, l, a, o;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([l, a, o] = t, e = De) : [e, l, a, o] = t, !e)
    return We;
  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);
  const r = [], n = () => {
    r.forEach((d) => d()), r.length = 0;
  }, s = (d, p, f, m) => (d.addEventListener(p, f, m), () => d.removeEventListener(p, f, m)), i = ue(
    () => [Me(e), Le(o)],
    ([d, p]) => {
      if (n(), !d)
        return;
      const f = zs(p) ? { ...p } : p;
      r.push(
        ...l.flatMap((m) => a.map((y) => s(d, m, y, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    i(), n();
  };
  return it(u), u;
}
let bl = !1;
function yo(t, e, l = {}) {
  const { window: a = De, ignore: o = [], capture: r = !0, detectIframe: n = !1 } = l;
  if (!a)
    return We;
  $a && !bl && (bl = !0, Array.from(a.document.body.children).forEach((f) => f.addEventListener("click", We)), a.document.documentElement.addEventListener("click", We));
  let s = !0;
  const i = (f) => o.some((m) => {
    if (typeof m == "string")
      return Array.from(a.document.querySelectorAll(m)).some((y) => y === f.target || f.composedPath().includes(y));
    {
      const y = Me(m);
      return y && (f.target === y || f.composedPath().includes(y));
    }
  }), d = [
    ke(a, "click", (f) => {
      const m = Me(t);
      if (!(!m || m === f.target || f.composedPath().includes(m))) {
        if (f.detail === 0 && (s = !i(f)), !s) {
          s = !0;
          return;
        }
        e(f);
      }
    }, { passive: !0, capture: r }),
    ke(a, "pointerdown", (f) => {
      const m = Me(t);
      s = !i(f) && !!(m && !f.composedPath().includes(m));
    }, { passive: !0 }),
    n && ke(a, "blur", (f) => {
      setTimeout(() => {
        var m;
        const y = Me(t);
        ((m = a.document.activeElement) == null ? void 0 : m.tagName) === "IFRAME" && !(y != null && y.contains(a.document.activeElement)) && e(f);
      }, 0);
    })
  ].filter(Boolean);
  return () => d.forEach((f) => f());
}
function Xs(t) {
  return typeof t == "function" ? t : typeof t == "string" ? (e) => e.key === t : Array.isArray(t) ? (e) => t.includes(e.key) : () => !0;
}
function Re(...t) {
  let e, l, a = {};
  t.length === 3 ? (e = t[0], l = t[1], a = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = !0, l = t[0], a = t[1]) : (e = t[0], l = t[1]) : (e = !0, l = t[0]);
  const {
    target: o = De,
    eventName: r = "keydown",
    passive: n = !1,
    dedupe: s = !1
  } = a, i = Xs(e);
  return ke(o, r, (d) => {
    d.repeat && Le(s) || i(d) && l(d);
  }, n);
}
function Ks() {
  const t = x(!1), e = gt();
  return e && Xe(() => {
    t.value = !0;
  }, e), t;
}
function Wa(t) {
  const e = Ks();
  return B(() => (e.value, !!t()));
}
function Ys(t, e = {}) {
  const { window: l = De } = e, a = Wa(() => l && "matchMedia" in l && typeof l.matchMedia == "function");
  let o;
  const r = x(!1), n = (u) => {
    r.value = u.matches;
  }, s = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", n) : o.removeListener(n));
  }, i = Rt(() => {
    a.value && (s(), o = l.matchMedia(Le(t)), "addEventListener" in o ? o.addEventListener("change", n) : o.addListener(n), r.value = o.matches);
  });
  return it(() => {
    i(), s(), o = void 0;
  }), r;
}
function Js(t) {
  return JSON.parse(JSON.stringify(t));
}
const Xt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Kt = "__vueuse_ssr_handlers__", Zs = /* @__PURE__ */ Qs();
function Qs() {
  return Kt in Xt || (Xt[Kt] = Xt[Kt] || {}), Xt[Kt];
}
function Ga(t, e) {
  return Zs[t] || e;
}
function er(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
const tr = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, yl = "vueuse-storage";
function ar(t, e, l, a = {}) {
  var o;
  const {
    flush: r = "pre",
    deep: n = !0,
    listenToStorageChanges: s = !0,
    writeDefaults: i = !0,
    mergeDefaults: u = !1,
    shallow: d,
    window: p = De,
    eventFilter: f,
    onError: m = (L) => {
      console.error(L);
    },
    initOnMounted: y
  } = a, c = (d ? bt : x)(typeof e == "function" ? e() : e);
  if (!l)
    try {
      l = Ga("getDefaultStorage", () => {
        var L;
        return (L = De) == null ? void 0 : L.localStorage;
      })();
    } catch (L) {
      m(L);
    }
  if (!l)
    return c;
  const g = Le(e), v = er(g), h = (o = a.serializer) != null ? o : tr[v], { pause: k, resume: C } = Ta(
    c,
    () => _(c.value),
    { flush: r, deep: n, eventFilter: f }
  );
  p && s && mo(() => {
    ke(p, "storage", Q), ke(p, yl, W), y && Q();
  }), y || Q();
  function w(L, J) {
    p && p.dispatchEvent(new CustomEvent(yl, {
      detail: {
        key: t,
        oldValue: L,
        newValue: J,
        storageArea: l
      }
    }));
  }
  function _(L) {
    try {
      const J = l.getItem(t);
      if (L == null)
        w(J, null), l.removeItem(t);
      else {
        const R = h.write(L);
        J !== R && (l.setItem(t, R), w(J, R));
      }
    } catch (J) {
      m(J);
    }
  }
  function F(L) {
    const J = L ? L.newValue : l.getItem(t);
    if (J == null)
      return i && g != null && l.setItem(t, h.write(g)), g;
    if (!L && u) {
      const R = h.read(J);
      return typeof u == "function" ? u(R, g) : v === "object" && !Array.isArray(R) ? { ...g, ...R } : R;
    } else
      return typeof J != "string" ? J : h.read(J);
  }
  function Q(L) {
    if (!(L && L.storageArea !== l)) {
      if (L && L.key == null) {
        c.value = g;
        return;
      }
      if (!(L && L.key !== t)) {
        k();
        try {
          (L == null ? void 0 : L.newValue) !== h.write(c.value) && (c.value = F(L));
        } catch (J) {
          m(J);
        } finally {
          L ? _e(C) : C();
        }
      }
    }
  }
  function W(L) {
    Q(L.detail);
  }
  return c;
}
function lr(t) {
  return Ys("(prefers-color-scheme: dark)", t);
}
function or(t = {}) {
  const {
    selector: e = "html",
    attribute: l = "class",
    initialValue: a = "auto",
    window: o = De,
    storage: r,
    storageKey: n = "vueuse-color-scheme",
    listenToStorageChanges: s = !0,
    storageRef: i,
    emitAuto: u,
    disableTransition: d = !0
  } = t, p = {
    auto: "",
    light: "light",
    dark: "dark",
    ...t.modes || {}
  }, f = lr({ window: o }), m = B(() => f.value ? "dark" : "light"), y = i || (n == null ? po(a) : ar(n, a, r, { window: o, listenToStorageChanges: s })), c = B(() => y.value === "auto" ? m.value : y.value), g = Ga(
    "updateHTMLAttrs",
    (C, w, _) => {
      const F = typeof C == "string" ? o == null ? void 0 : o.document.querySelector(C) : Me(C);
      if (!F)
        return;
      let Q;
      if (d && (Q = o.document.createElement("style"), Q.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), o.document.head.appendChild(Q)), w === "class") {
        const W = _.split(/\s/g);
        Object.values(p).flatMap((L) => (L || "").split(/\s/g)).filter(Boolean).forEach((L) => {
          W.includes(L) ? F.classList.add(L) : F.classList.remove(L);
        });
      } else
        F.setAttribute(w, _);
      d && (o.getComputedStyle(Q).opacity, document.head.removeChild(Q));
    }
  );
  function v(C) {
    var w;
    g(e, l, (w = p[C]) != null ? w : C);
  }
  function h(C) {
    t.onChanged ? t.onChanged(C, v) : v(C);
  }
  ue(c, h, { flush: "post", immediate: !0 }), mo(() => h(c.value));
  const k = B({
    get() {
      return u ? y.value : c.value;
    },
    set(C) {
      y.value = C;
    }
  });
  try {
    return Object.assign(k, { store: y, system: m, state: c });
  } catch {
    return k;
  }
}
function nr(t, e, l = {}) {
  const { window: a = De, ...o } = l;
  let r;
  const n = Wa(() => a && "MutationObserver" in a), s = () => {
    r && (r.disconnect(), r = void 0);
  }, i = B(() => {
    const f = Le(t), m = (Array.isArray(f) ? f : [f]).map(Me).filter(co);
    return new Set(m);
  }), u = ue(
    () => i.value,
    (f) => {
      s(), n.value && a && f.size && (r = new MutationObserver(e), f.forEach((m) => r.observe(m, o)));
    },
    { immediate: !0, flush: "post" }
  ), d = () => r == null ? void 0 : r.takeRecords(), p = () => {
    s(), u();
  };
  return it(p), {
    isSupported: n,
    stop: p,
    takeRecords: d
  };
}
function Ua(t, e = {}) {
  const {
    delayEnter: l = 0,
    delayLeave: a = 0,
    window: o = De
  } = e, r = x(!1);
  let n;
  const s = (i) => {
    const u = i ? l : a;
    n && (clearTimeout(n), n = void 0), u ? n = setTimeout(() => r.value = i, u) : r.value = i;
  };
  return o && (ke(t, "mouseenter", () => s(!0), { passive: !0 }), ke(t, "mouseleave", () => s(!1), { passive: !0 })), r;
}
function sr(t, e, l = {}) {
  const {
    root: a,
    rootMargin: o = "0px",
    threshold: r = 0.1,
    window: n = De,
    immediate: s = !0
  } = l, i = Wa(() => n && "IntersectionObserver" in n), u = B(() => {
    const y = Le(t);
    return (Array.isArray(y) ? y : [y]).map(Me).filter(co);
  });
  let d = We;
  const p = x(s), f = i.value ? ue(
    () => [u.value, Me(a), p.value],
    ([y, c]) => {
      if (d(), !p.value || !y.length)
        return;
      const g = new IntersectionObserver(
        e,
        {
          root: Me(c),
          rootMargin: o,
          threshold: r
        }
      );
      y.forEach((v) => v && g.observe(v)), d = () => {
        g.disconnect(), d = We;
      };
    },
    { immediate: s, flush: "post" }
  ) : We, m = () => {
    d(), f(), p.value = !1;
  };
  return it(m), {
    isSupported: i,
    isActive: p,
    pause() {
      d(), p.value = !1;
    },
    resume() {
      p.value = !0;
    },
    stop: m
  };
}
function Pe(t, e = {}) {
  const { initialValue: l = !1, focusVisible: a = !1 } = e, o = x(!1), r = B(() => Me(t));
  ke(r, "focus", (s) => {
    var i, u;
    (!a || (u = (i = s.target).matches) != null && u.call(i, ":focus-visible")) && (o.value = !0);
  }), ke(r, "blur", () => o.value = !1);
  const n = B({
    get: () => o.value,
    set(s) {
      var i, u;
      !s && o.value ? (i = r.value) == null || i.blur() : s && !o.value && ((u = r.value) == null || u.focus());
    }
  });
  return ue(
    r,
    () => {
      n.value = l;
    },
    { immediate: !0, flush: "post" }
  ), { focused: n };
}
function ba(t) {
  return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t;
}
const rr = {
  page: (t) => [t.pageX, t.pageY],
  client: (t) => [t.clientX, t.clientY],
  screen: (t) => [t.screenX, t.screenY],
  movement: (t) => t instanceof Touch ? null : [t.movementX, t.movementY]
};
function ir(t = {}) {
  const {
    type: e = "page",
    touch: l = !0,
    resetOnTouchEnds: a = !1,
    initialValue: o = { x: 0, y: 0 },
    window: r = De,
    target: n = r,
    scroll: s = !0,
    eventFilter: i
  } = t;
  let u = null;
  const d = x(o.x), p = x(o.y), f = x(null), m = typeof e == "function" ? e : rr[e], y = (w) => {
    const _ = m(w);
    u = w, _ && ([d.value, p.value] = _, f.value = "mouse");
  }, c = (w) => {
    if (w.touches.length > 0) {
      const _ = m(w.touches[0]);
      _ && ([d.value, p.value] = _, f.value = "touch");
    }
  }, g = () => {
    if (!u || !r)
      return;
    const w = m(u);
    u instanceof MouseEvent && w && (d.value = w[0] + r.scrollX, p.value = w[1] + r.scrollY);
  }, v = () => {
    d.value = o.x, p.value = o.y;
  }, h = i ? (w) => i(() => y(w), {}) : (w) => y(w), k = i ? (w) => i(() => c(w), {}) : (w) => c(w), C = i ? () => i(() => g(), {}) : () => g();
  if (n) {
    const w = { passive: !0 };
    ke(n, ["mousemove", "dragover"], h, w), l && e !== "movement" && (ke(n, ["touchstart", "touchmove"], k, w), a && ke(n, "touchend", v, w)), s && e === "page" && ke(r, "scroll", C, { passive: !0 });
  }
  return {
    x: d,
    y: p,
    sourceType: f
  };
}
function gl(t, e = {}) {
  const {
    handleOutside: l = !0,
    window: a = De
  } = e, o = e.type || "page", { x: r, y: n, sourceType: s } = ir(e), i = x(t ?? (a == null ? void 0 : a.document.body)), u = x(0), d = x(0), p = x(0), f = x(0), m = x(0), y = x(0), c = x(!0);
  let g = () => {
  };
  return a && (g = ue(
    [i, r, n],
    () => {
      const v = Me(i);
      if (!v)
        return;
      const {
        left: h,
        top: k,
        width: C,
        height: w
      } = v.getBoundingClientRect();
      p.value = h + (o === "page" ? a.pageXOffset : 0), f.value = k + (o === "page" ? a.pageYOffset : 0), m.value = w, y.value = C;
      const _ = r.value - p.value, F = n.value - f.value;
      c.value = C === 0 || w === 0 || _ < 0 || F < 0 || _ > C || F > w, (l || !c.value) && (u.value = _, d.value = F);
    },
    { immediate: !0 }
  ), ke(document, "mouseleave", () => {
    c.value = !0;
  })), {
    x: r,
    y: n,
    sourceType: s,
    elementX: u,
    elementY: d,
    elementPositionX: p,
    elementPositionY: f,
    elementHeight: m,
    elementWidth: y,
    isOutside: c,
    stop: g
  };
}
function go(t) {
  const e = window.getComputedStyle(t);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight)
    return !0;
  {
    const l = t.parentNode;
    return !l || l.tagName === "BODY" ? !1 : go(l);
  }
}
function ur(t) {
  const e = t || window.event, l = e.target;
  return go(l) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1);
}
const Yt = /* @__PURE__ */ new WeakMap();
function dr(t, e = !1) {
  const l = x(e);
  let a = null;
  ue(po(t), (n) => {
    const s = ba(Le(n));
    if (s) {
      const i = s;
      Yt.get(i) || Yt.set(i, i.style.overflow), l.value && (i.style.overflow = "hidden");
    }
  }, {
    immediate: !0
  });
  const o = () => {
    const n = ba(Le(t));
    !n || l.value || ($a && (a = ke(
      n,
      "touchmove",
      (s) => {
        ur(s);
      },
      { passive: !1 }
    )), n.style.overflow = "hidden", l.value = !0);
  }, r = () => {
    var n;
    const s = ba(Le(t));
    !s || !l.value || ($a && (a == null || a()), s.style.overflow = (n = Yt.get(s)) != null ? n : "", Yt.delete(s), l.value = !1);
  };
  return it(r), B({
    get() {
      return l.value;
    },
    set(n) {
      n ? o() : r();
    }
  });
}
function cr(t, e = {}) {
  const {
    threshold: l = 50,
    onSwipe: a,
    onSwipeEnd: o,
    onSwipeStart: r,
    passive: n = !0,
    window: s = De
  } = e, i = nl({ x: 0, y: 0 }), u = nl({ x: 0, y: 0 }), d = B(() => i.x - u.x), p = B(() => i.y - u.y), { max: f, abs: m } = Math, y = B(() => f(m(d.value), m(p.value)) >= l), c = x(!1), g = B(() => y.value ? m(d.value) > m(p.value) ? d.value > 0 ? "left" : "right" : p.value > 0 ? "up" : "down" : "none"), v = (W) => [W.touches[0].clientX, W.touches[0].clientY], h = (W, L) => {
    i.x = W, i.y = L;
  }, k = (W, L) => {
    u.x = W, u.y = L;
  };
  let C;
  const w = fr(s == null ? void 0 : s.document);
  n ? C = w ? { passive: !0 } : { capture: !1 } : C = w ? { passive: !1, capture: !0 } : { capture: !0 };
  const _ = (W) => {
    c.value && (o == null || o(W, g.value)), c.value = !1;
  }, F = [
    ke(t, "touchstart", (W) => {
      if (W.touches.length !== 1)
        return;
      C.capture && !C.passive && W.preventDefault();
      const [L, J] = v(W);
      h(L, J), k(L, J), r == null || r(W);
    }, C),
    ke(t, "touchmove", (W) => {
      if (W.touches.length !== 1)
        return;
      const [L, J] = v(W);
      k(L, J), !c.value && y.value && (c.value = !0), c.value && (a == null || a(W));
    }, C),
    ke(t, ["touchend", "touchcancel"], _, C)
  ];
  return {
    isPassiveEventSupported: w,
    isSwiping: c,
    direction: g,
    coordsStart: i,
    coordsEnd: u,
    lengthX: d,
    lengthY: p,
    stop: () => F.forEach((W) => W())
  };
}
function fr(t) {
  if (!t)
    return !1;
  let e = !1;
  const l = {
    get passive() {
      return e = !0, !1;
    }
  };
  return t.addEventListener("x", We, l), t.removeEventListener("x", We), e;
}
function vr(t, e, l, a = {}) {
  var o, r, n;
  const {
    clone: s = !1,
    passive: i = !1,
    eventName: u,
    deep: d = !1,
    defaultValue: p,
    shouldEmit: f
  } = a, m = gt(), y = l || (m == null ? void 0 : m.emit) || ((o = m == null ? void 0 : m.$emit) == null ? void 0 : o.bind(m)) || ((n = (r = m == null ? void 0 : m.proxy) == null ? void 0 : r.$emit) == null ? void 0 : n.bind(m == null ? void 0 : m.proxy));
  let c = u;
  e || (e = "modelValue"), c = c || `update:${e.toString()}`;
  const g = (k) => s ? typeof s == "function" ? s(k) : Js(k) : k, v = () => Ls(t[e]) ? g(t[e]) : p, h = (k) => {
    f ? f(k) && y(c, k) : y(c, k);
  };
  if (i) {
    const k = v(), C = x(k);
    let w = !1;
    return ue(
      () => t[e],
      (_) => {
        w || (w = !0, C.value = g(_), _e(() => w = !1));
      }
    ), ue(
      C,
      (_) => {
        !w && (_ !== t[e] || d) && h(_);
      },
      { deep: d }
    ), C;
  } else
    return B({
      get() {
        return v();
      },
      set(k) {
        h(k);
      }
    });
}
const pr = ["id"], mr = ["id"], br = ["innerHTML"], yr = ["innerHTML"], Xa = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BPopover",
  props: /* @__PURE__ */ pe({
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    click: { type: Boolean, default: !1 },
    content: { default: void 0 },
    customClass: { default: "" },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    floatingMiddleware: { default: void 0 },
    hide: { type: Boolean, default: void 0 },
    html: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    manual: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noHide: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    noninteractive: { type: Boolean, default: !1 },
    offset: { default: null },
    placement: { default: "top" },
    persistent: { type: Boolean, default: !1 },
    realtime: { type: Boolean, default: !1 },
    reference: { default: null },
    strategy: { default: "absolute" },
    target: { default: null },
    title: { default: void 0 },
    tooltip: { type: Boolean, default: !1 },
    variant: { default: null },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "modelValue"), n = x(r.value), s = x(r.value);
    Rt(() => {
      r.value = n.value;
    }), ue(r, (q) => {
      q !== n.value && (q ? A() : K(new Event("update:modelValue")));
    });
    const i = Be(() => a.id, "popover"), u = x(!1), d = x(null), p = x(null), f = x(null), m = x(null), y = x(null), c = B(
      () => a.title ? Tt(a.title, $t) : ""
    ), g = B(
      () => a.content ? Tt(a.content, $t) : ""
    ), v = $(() => a.placement.startsWith("auto")), h = be(() => a.offset ?? NaN), k = B(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), C = B(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), w = x({}), _ = B(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const q = a.offset !== null ? h.value : a.tooltip ? 6 : 8, ne = [Kl(q)];
      return a.noFlip === !1 && !v.value && ne.push(
        so({
          boundary: k.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), v.value && ne.push(
        Cs({
          alignment: a.placement.split("-")[1] || void 0,
          boundary: k.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === !1 && ne.push(
        no({
          boundary: k.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), a.noHide === !1 && ne.push(
        ks({
          boundary: k.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), a.inline === !0 && ne.push(Ts()), ne.push(_s({ element: f, padding: 10 })), a.noSize === !1 && ne.push(
        ro({
          boundary: k.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: ge, availableHeight: te }) {
            w.value = {
              maxHeight: te ? `${te}px` : void 0,
              maxWidth: ge ? `${ge}px` : void 0
            };
          }
        })
      ), ne;
    }), F = $(
      () => v.value ? void 0 : a.placement
    ), { floatingStyles: Q, middlewareData: W, placement: L, update: J } = uo(p, d, {
      placement: F,
      middleware: _,
      strategy: $(() => a.strategy),
      whileElementsMounted: (...q) => oo(...q, { animationFrame: a.realtime })
    }), R = x({ position: "absolute" });
    ue(W, () => {
      var q;
      if (a.noHide === !1 && ((q = W.value.hide) != null && q.referenceHidden ? u.value = !0 : u.value = !1), W.value.arrow) {
        const { x: ne, y: ge } = W.value.arrow;
        R.value = {
          position: "absolute",
          top: ge ? `${ge}px` : "",
          left: ne ? `${ne}px` : ""
        };
      }
    });
    const le = B(() => {
      const q = a.tooltip ? "tooltip" : "popover";
      return [
        q,
        `b-${q}`,
        {
          [`b-${q}-${a.variant}`]: a.variant !== null,
          show: n.value && !u.value,
          "pe-none": !n.value,
          fade: !a.noFade,
          "d-none": !n.value && a.noFade,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${q}-${hr(L.value)}`]: L.value !== void 0
        }
      ];
    }), { isOutside: N } = gl(d), { isOutside: S } = gl(m), E = (q) => {
      const ne = q ?? new Event("click");
      n.value ? K(ne) : A();
    }, M = (q, ne = {}) => new Bt(q, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...ne,
      componentId: i.value
    });
    let j;
    const A = () => {
      const q = M("show", { cancelable: !0 });
      if (o("show", q), q.defaultPrevented) {
        o("show-prevented");
        return;
      }
      s.value = !0, _e(() => {
        var ne;
        J(), j = setTimeout(
          () => {
            J(), n.value = !0, _e(() => {
              o("shown", M("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((ne = a.delay) == null ? void 0 : ne.show) || 0
        );
      });
    }, K = (q) => {
      var te;
      const ne = M("hide", { cancelable: !0 });
      if (o("hide", ne), ne.defaultPrevented) {
        o("hide-prevented");
        return;
      }
      j && (clearTimeout(j), j = void 0);
      const ge = typeof a.delay == "number" ? a.delay : ((te = a.delay) == null ? void 0 : te.hide) || 0;
      setTimeout(() => {
        var ye, ee;
        (q == null ? void 0 : q.type) === "click" || (q == null ? void 0 : q.type) === "forceHide" || (q == null ? void 0 : q.type) === "update:modelValue" && a.manual || !a.noninteractive && N.value && S.value && !((ye = d.value) != null && ye.contains(document == null ? void 0 : document.activeElement)) && !((ee = m.value) != null && ee.contains(document == null ? void 0 : document.activeElement)) || a.noninteractive && S.value ? (n.value = !1, _e(() => {
          setTimeout(
            () => {
              s.value = !1;
            },
            d.value ? wa(d.value) : 150
          ), o("hidden", M("hidden"));
        })) : setTimeout(
          () => {
            K(q);
          },
          ge < 50 ? 50 : ge
        );
      }, ge);
    };
    e({
      hide: K,
      show: A,
      toggle: E
    });
    const G = () => {
      var q;
      if (a.target) {
        const ne = mt(a.target);
        ne ? m.value = ne : console.warn("Target element not found", a.target);
      } else
        m.value = (q = y.value) == null ? void 0 : q.nextElementSibling;
      if (a.reference) {
        const ne = mt(a.reference);
        ne ? p.value = ne : console.warn("Reference element not found", a.reference);
      } else
        p.value = m.value;
      if (!(!m.value || a.manual) && za) {
        if (m.value.addEventListener("forceHide", K), a.click) {
          m.value.addEventListener("click", E);
          return;
        }
        m.value.addEventListener("pointerenter", A), m.value.addEventListener("pointerleave", K), m.value.addEventListener("focus", A), m.value.addEventListener("blur", K);
      }
    }, ie = () => {
      m.value && (m.value.removeEventListener("forceHide", K), m.value.removeEventListener("click", E), m.value.removeEventListener("pointerenter", A), m.value.removeEventListener("pointerleave", K), m.value.removeEventListener("focus", A), m.value.removeEventListener("blur", K));
    };
    return yo(
      d,
      () => {
        n.value && a.click && !a.noAutoClose && !a.manual && K(new Event("clickOutside"));
      },
      { ignore: [m] }
    ), ue([() => a.click, () => a.target, () => a.reference], () => {
      ie(), G();
    }), Xe(G), La(ie), (q, ne) => (b(), V(de, null, [
      Z("span", {
        id: O(i) + "_placeholder",
        ref_key: "placeholder",
        ref: y
      }, null, 8, pr),
      T(q.$slots, "target", {
        show: A,
        hide: K,
        toggle: E,
        showState: n.value
      }),
      (b(), I(ht, {
        to: q.teleportTo,
        disabled: !q.teleportTo || q.teleportDisabled
      }, [
        s.value || a.persistent ? (b(), V("div", X({
          key: 0,
          id: O(i)
        }, q.$attrs, {
          ref_key: "element",
          ref: d,
          class: le.value,
          role: "tooltip",
          tabindex: "-1",
          style: O(Q)
        }), [
          Z("div", {
            ref_key: "arrow",
            ref: f,
            class: D(`${a.tooltip ? "tooltip" : "popover"}-arrow`),
            style: Ee(R.value),
            "data-popper-arrow": ""
          }, null, 6),
          Z("div", {
            class: "overflow-auto",
            style: Ee(w.value)
          }, [
            q.title || q.$slots.title ? (b(), V(de, { key: 0 }, [
              a.html ? (b(), V("div", {
                key: 1,
                class: D(["position-sticky top-0", a.tooltip ? "tooltip-inner" : "popover-header"]),
                innerHTML: c.value
              }, null, 10, br)) : (b(), V("div", {
                key: 0,
                class: D(["position-sticky top-0", a.tooltip ? "tooltip-inner" : "popover-header"])
              }, [
                T(q.$slots, "title", {}, () => [
                  se(Y(q.title), 1)
                ])
              ], 2))
            ], 64)) : ae("", !0),
            a.tooltip && !q.$slots.title && !q.title || !a.tooltip ? (b(), V(de, { key: 1 }, [
              a.html ? (b(), V("div", {
                key: 1,
                class: D(a.tooltip ? "tooltip-inner" : "popover-body"),
                innerHTML: g.value
              }, null, 10, yr)) : (b(), V("div", {
                key: 0,
                class: D(a.tooltip ? "tooltip-inner" : "popover-body")
              }, [
                T(q.$slots, "default", {}, () => [
                  se(Y(q.content), 1)
                ])
              ], 2))
            ], 64)) : ae("", !0)
          ], 4)
        ], 16, mr)) : ae("", !0)
      ], 8, ["to", "disabled"]))
    ], 64));
  }
}), gr = ({
  top: t,
  end: e,
  start: l,
  alignCenter: a,
  alignEnd: o
}) => {
  const r = t ? "top" : l ? "left" : e ? "right" : "bottom", n = o ? "end" : a ? null : "start";
  return `${r}${n ? `-${n}` : ""}`;
}, hr = (t) => {
  const [e] = t.split("-");
  switch (e) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return e;
  }
}, Ht = (t) => typeof t != "object" || t.active !== !1, oa = (t, e) => {
  if (!Ht(t))
    return {};
  const a = typeof t > "u" || typeof t == "object" && !t.title && !t.content, o = e.getAttribute("title") || e.getAttribute("data-original-title");
  return a ? o ? (e.removeAttribute("title"), e.setAttribute("data-original-title", o), {
    content: Tt(o, $t)
  }) : {} : typeof t == "string" ? {
    content: Tt(t, $t)
  } : {
    title: t != null && t.title ? Tt(t == null ? void 0 : t.title, $t) : void 0,
    content: t != null && t.content ? Tt(t == null ? void 0 : t.content, $t) : void 0
  };
}, na = (t, e) => ({
  target: e,
  modelValue: t.modifiers.show,
  inline: t.modifiers.inline,
  click: t.modifiers.click,
  realtime: t.modifiers.realtime,
  persistent: t.modifiers.persistent,
  placement: t.modifiers.left ? "left" : t.modifiers.right ? "right" : t.modifiers.bottom ? "bottom" : t.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof t.value == "object" ? t.value : {},
  ...t.modifiers.interactive ? { noninteractive: !1 } : {},
  title: null,
  content: null
}), sa = (t, e, l) => {
  var o;
  const a = document.createElement("span");
  e.modifiers.body ? document.body.appendChild(a) : e.modifiers.child ? t.appendChild(a) : (o = t.parentNode) == null || o.insertBefore(a, t.nextSibling), Dl(Ne(Xa, l), a), t.$__element = a;
}, ra = (t) => {
  const e = t.$__element;
  e && Dl(null, e), setTimeout(() => {
    e == null || e.remove();
  }, 0), delete t.$__element;
}, ho = (t, e, l) => {
  const a = Je(t, e);
  return l && typeof l == "function" ? l(a, e, t) : a;
}, fa = (t, e, l) => e.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((a, o) => (a[t ? `${t}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), {}), Bo = (t, e, l, a = l) => Object.keys(e).reduce((o, r) => (t[r] && o.push(
  [a, r.replace(l, ""), t[r]].filter((n) => n && typeof n != "boolean").join("-").toLowerCase()
), o), []), mt = (t) => {
  if (t)
    return typeof t == "string" ? typeof document > "u" ? void 0 : document.getElementById(t) ?? document.querySelector(t) ?? void 0 : t.$el ?? t;
}, Br = (t, e) => ((t == null ? void 0 : t()) ?? []).reduce((l, a) => (typeof a.type == "symbol" ? l = l.concat(a.children) : l.push(a), l), []).filter((l) => {
  var a;
  return ((a = l.type) == null ? void 0 : a.__name) === e;
}), wo = /_/g, Co = /([a-z])([A-Z])/g, wr = /^[0-9]*\.?[0-9]+$/, Cr = /(\s|^)(\w)/g, kr = /(\s|^)(\w)/, Jt = /\s+/, $r = /^#/, Tr = /^#[A-Za-z]+[\w\-:.]*$/, Sr = /[-/\\^$*+?.()|[\]{}]/g, Vr = /[\s\uFEFF\xA0]+/g, ya = (t) => t.replace(wo, " ").replace(Co, (e, l, a) => `${l} ${a}`).replace(kr, (e, l, a) => l + a.toUpperCase()), hl = (t) => t.replace(wo, " ").replace(Co, (e, l, a) => `${l} ${a}`).replace(Cr, (e, l, a) => l + a.toUpperCase()), _r = (t) => {
  const e = t.trim();
  return e.charAt(0).toUpperCase() + e.slice(1);
}, Ar = (t) => t.replace(Sr, "\\$&"), Or = (t) => Ar(t).replace(Vr, "\\s"), Zt = (t) => typeof t == "string" ? hl(t) : t.label !== void 0 ? t.label : typeof t.key == "string" ? hl(t.key) : t.key, Nr = (t) => !!(t.href || t.to), ko = Symbol("carousel"), $o = Symbol("tabs"), To = Symbol("progress"), So = Symbol("listGroup"), Vo = Symbol("avatarGroup"), _o = Symbol("accordion"), Ao = Symbol("checkboxGroup"), Oo = Symbol("radioGroup"), Ka = Symbol("collapse"), No = Symbol("collapse"), Ya = Symbol("navbar"), Io = Symbol("toastPlugin"), Po = Symbol("rtlPlugin"), Eo = Symbol("breadcrumbPlugin"), Lo = Symbol("modalControllerPlugin"), Fo = Symbol("modalManagerPlugin"), zo = Symbol("idPluginKey"), Et = (t, e = {}, l = {}) => {
  const a = [t];
  let o;
  for (let r = 0; r < a.length && !o; r++) {
    const n = a[r];
    o = l[n];
  }
  return o && typeof o == "function" ? o(e) : o;
}, va = (t, e) => Object.keys(t).filter((l) => !e.map((a) => a.toString()).includes(l)).reduce((l, a) => ({ ...l, [a]: t[a] }), {}), Ja = (t, e) => [...e].reduce(
  (l, a) => (l[a] = t[a], l),
  {}
), Je = (t, e, l) => {
  const a = e.split(/[.[\]]/g);
  let o = t;
  for (const r of a) {
    if (o === null || o === void 0)
      return l;
    r.trim() !== "" && (o = o[r]);
  }
  return o === void 0 ? l : o;
}, Ir = (t, e, l) => {
  const a = (i) => {
    if (((p) => p == null || typeof p != "object" && typeof p != "function")(i))
      return i;
    if (typeof i == "function")
      return i.bind({});
    const d = new i.constructor();
    return Object.getOwnPropertyNames(i).forEach((p) => {
      d[p] = i[p];
    }), d;
  }, o = (i, u) => {
    const d = u === void 0 ? 0 : u;
    if (i == null)
      return d;
    const p = Number.parseInt(i);
    return Number.isNaN(p) ? d : p;
  };
  if (!t)
    return {};
  if (!e || l === void 0)
    return t;
  const r = e.split(/[.[\]]/g).filter((i) => !!i.trim()), n = (i) => {
    if (r.length > 1) {
      const u = r.shift(), d = o(r[0], null) !== null;
      i[u] = i[u] === void 0 ? d ? [] : {} : i[u], n(i[u]);
    } else
      i[r[0]] = l;
  }, s = a(t);
  return n(s), s;
}, Bl = (t, e) => {
  const { all: l, ...a } = t, o = {};
  l && e.forEach((n) => {
    o[n] = l;
  });
  const r = { ...o, ...a };
  return Object.entries(r).filter(([n, s]) => !!s && e.includes(n)).map(([n]) => n);
}, wl = (t, e) => e + (t ? _r(t) : ""), wt = (t, e) => {
  const l = $(e), a = $(t), o = $(() => Nr(a.value)), r = B(
    () => o.value ? Ja(
      a.value,
      l.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: o, computedLinkProps: r };
}, Ho = () => ({ ...Ve(Eo) }), Pr = (t = {}) => {
  const e = t.persist ?? !1, l = "data-bs-theme", a = "body";
  return or({
    attribute: l,
    selector: a,
    storageKey: e === !0 ? `bv-color-${t.attribute ?? l}-${t.selector ?? a}` : null,
    ...t
  });
}, Qe = (t) => B(() => {
  let e = Se(t);
  return e = {
    ...e,
    variant: e.variant ?? null,
    bgVariant: e.bgVariant ?? null,
    textVariant: e.textVariant ?? null
  }, {
    [`text-bg-${e.variant}`]: e.variant !== null,
    [`text-${e.textVariant}`]: e.textVariant !== null && e.variant === null,
    [`bg-${e.bgVariant}`]: e.bgVariant !== null && e.variant === null
  };
}), Er = (t) => B(() => {
  const e = Se(t);
  return {
    container: e === !0,
    [`container-${e}`]: typeof e == "string"
  };
}), Ro = (t, e = x(1e3), l = {}) => {
  const a = qe($(t)), o = qe($(e)), r = x(!1), n = x(0), s = $(() => Math.ceil(a.value / o.value)), i = $(
    () => p.value || r.value ? Math.round(a.value - n.value * o.value) : 0
  ), { pause: u, resume: d, isActive: p } = bo(
    () => {
      n.value = n.value + 1;
    },
    e,
    l
  ), f = () => {
    r.value = !1, n.value = 0, d();
  }, m = () => {
    r.value = !1, n.value = s.value;
  };
  Rt(() => {
    n.value > s.value && (n.value = s.value), n.value === s.value && u();
  }), ue([o, a], () => {
    m(), f();
  });
  const y = () => {
    p.value !== !1 && (r.value = !0, u());
  }, c = () => {
    n.value !== s.value && (r.value = !1, d());
  };
  return {
    isActive: qe(p),
    isPaused: qe(r),
    restart: f,
    stop: m,
    pause: y,
    resume: c,
    value: i
  };
}, Ct = (t) => B(() => {
  const e = Se(t);
  return e === !0 ? "is-valid" : e === !1 ? "is-invalid" : null;
}), Mo = (t) => B(() => {
  const e = Se(t);
  return {
    "form-check": e.plain === !1 && e.button === !1 && e.hasDefaultSlot,
    "form-check-reverse": e.reverse === !0,
    "form-check-inline": e.inline === !0,
    "form-switch": e.switch === !0,
    [`form-control-${e.size}`]: e.size !== void 0 && e.size !== "md" && e.button === !1
  };
}), xo = (t) => {
  const e = $(t), l = Ct(() => e.value.state ?? null);
  return B(() => [
    l.value,
    {
      "form-check-input": e.value.plain === !1 && e.value.button === !1,
      "btn-check": e.value.button === !0
    }
  ]);
}, Do = (t) => B(() => {
  const e = Se(t);
  return {
    "form-check-label": e.plain === !1 && e.button === !1,
    btn: e.button === !0,
    [`btn-${e.buttonVariant}`]: e.button === !0 && e.buttonVariant !== void 0 && e.buttonVariant !== null,
    [`btn-${e.size}`]: e.button && e.size && e.size !== "md"
  };
}), jo = (t) => {
  const e = $(t), l = ua(
    () => e.value.ariaInvalid,
    () => e.value.state
  );
  return B(() => ({
    "aria-invalid": l.value,
    "aria-required": e.value.required === !0 ? !0 : void 0
  }));
}, qo = (t) => B(() => {
  const e = Se(t);
  return {
    "was-validated": e.validated === !0,
    "btn-group": e.buttons === !0 && e.stacked === !1,
    "btn-group-vertical": e.stacked === !0 && e.buttons === !0,
    [`btn-group-${e.size}`]: e.size !== void 0
  };
}), Be = (t, e) => B(() => Se(t) || Lr(e)), Lr = (t = "") => `__BVID__${Ve(zo, () => Math.random().toString().slice(2, 8))()}___BV_${t}__`, Wo = (t, e) => {
  const l = x(null), a = vr(t, "modelValue", e, { passive: !0 }), o = Be(() => t.id, "input"), r = be(() => t.debounce ?? 0), n = be(() => t.debounceMaxWait ?? NaN), s = Ws(
    (h) => {
      a.value = h;
    },
    () => t.lazy === !0 ? 0 : r.value,
    { maxWait: () => t.lazy === !0 ? NaN : n.value }
  ), i = (h, k = !1) => {
    t.lazy === !0 && k === !1 || s(h);
  }, { focused: u } = Pe(l, {
    initialValue: t.autofocus
  }), d = (h, k, C = !1) => t.formatter !== void 0 && (!t.lazyFormatter || C) ? t.formatter(h, k) : h, p = (h) => t.trim ? h.trim() : t.number ? Number.parseFloat(h) : h;
  Xe(() => {
    var h;
    l.value && (l.value.value = ((h = a.value) == null ? void 0 : h.toString()) ?? "");
  }), An(() => {
    _e(() => {
      t.autofocus && (u.value = !0);
    });
  });
  const f = ua(
    () => t.ariaInvalid,
    () => t.state
  );
  return {
    input: l,
    computedId: o,
    computedAriaInvalid: f,
    onInput: (h) => {
      const { value: k } = h.target, C = d(k, h);
      if (h.defaultPrevented) {
        h.preventDefault();
        return;
      }
      const w = p(C);
      i(w);
    },
    onChange: (h) => {
      const { value: k } = h.target, C = d(k, h);
      if (h.defaultPrevented) {
        h.preventDefault();
        return;
      }
      const w = p(C);
      a.value !== w && i(C, !0);
    },
    onBlur: (h) => {
      if (!t.lazy && !t.lazyFormatter)
        return;
      const { value: k } = h.target, C = d(k, h, !0), w = p(C);
      a.value !== w && i(C, !0);
    },
    focus: () => {
      t.disabled || (u.value = !0);
    },
    blur: () => {
      t.disabled || (u.value = !1);
    }
  };
}, Go = (t, e) => {
  const l = (n) => typeof n == "object" && n !== null && "label" in n, a = (n) => {
    if (typeof n == "string")
      return { value: n, text: n };
    if (typeof n == "number")
      return { value: n, text: `${n}` };
    if (n instanceof Date)
      return { value: n, text: n.toLocaleString() };
    const s = Je(n, e.valueField), i = Je(n, e.textField), u = Je(n, e.htmlField), d = Je(n, e.disabledField), p = e.optionsField ? Je(n, e.optionsField) : void 0;
    return p !== void 0 ? {
      label: Je(n, e.labelField) || i,
      options: p
    } : {
      value: s,
      text: i,
      html: u,
      disabled: d
    };
  }, o = (n) => n.map((s) => a(s));
  return { normalizedOptions: B(() => o(Se(t))), isComplex: l };
}, ga = "modal-open", Za = () => {
  const t = Ve(Fo), e = (a) => {
    t == null || t.removeStack(a), t == null || t.removeRegistry(a);
  }, l = Ga("updateHTMLAttrs", (a, o, r) => {
    const n = typeof a == "string" ? window == null ? void 0 : window.document.querySelector(a) : Me(a);
    n && (o === "class" ? n.classList.toggle(ga, r === ga) : n.setAttribute(o, r));
  });
  return it(() => {
    l("body", "class", "");
  }), ue(
    () => t == null ? void 0 : t.countStack.value,
    (a) => {
      a !== void 0 && l("body", "class", a > 0 ? ga : "");
    }
  ), {
    ...t,
    dispose: e
  };
}, Fr = (t) => {
  const { pushRegistry: e, pushStack: l, removeStack: a, stack: o, dispose: r, countStack: n } = Za(), s = gt();
  if (!s || s.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  return e == null || e(s), it(() => {
    r(s);
  }), ue(
    t,
    (i, u) => {
      i ? l == null || l(s) : u && !i && (a == null || a(s));
    },
    { immediate: !0 }
  ), {
    activePosition: B(
      () => o == null ? void 0 : o.value.findIndex((i) => {
        var u, d;
        return ((u = i.exposed) == null ? void 0 : u.id) === ((d = s.exposed) == null ? void 0 : d.id);
      })
    ),
    activeModalCount: n
  };
}, zr = (t = void 0) => {
  const { registry: e } = Za(), l = gt(), a = (n) => n.parent ? n.parent.type.__name === "BModal" ? n.parent : a(n.parent) : null, o = B(() => {
    const n = Se(t);
    return n ? (e == null ? void 0 : e.value.find((s) => {
      var i;
      return ((i = s.exposed) == null ? void 0 : i.id.value) === n;
    })) || null : l ? a(l) : null;
  }), r = $(() => {
    var n;
    return (n = o.value) == null ? void 0 : n.proxy;
  });
  return {
    show() {
      var n, s;
      (s = (n = o.value) == null ? void 0 : n.exposed) == null || s.show();
    },
    hide(n = "") {
      var s, i;
      (i = (s = o.value) == null ? void 0 : s.exposed) == null || i.hide(n);
    },
    modal: r
  };
}, Uo = () => {
  const { lastStack: t, stack: e } = Za();
  return {
    ...Ve(Lo),
    hide: (r = "") => {
      var n;
      t != null && t.value && ((n = t == null ? void 0 : t.value.exposed) == null || n.hide(r));
    },
    hideAll: (r = "") => {
      e == null || e.value.forEach((n) => {
        var s;
        (s = n.exposed) == null || s.hide(r);
      });
    }
    // Todo: Supports listening events globally in the future
  };
}, ia = (t, e = "px") => B(() => {
  const l = Se(t), a = Se(e);
  return wr.test(String(l)) ? `${Number(l)}${a}` : l;
}), Qa = (t) => {
  const e = (l, a) => {
    const o = a === null ? "" : `${a}-`;
    return l === "circle" ? `${o}rounded-circle` : l === "pill" ? `${o}rounded-pill` : typeof l == "number" || l === "0" || l === "1" || l === "2" || l === "3" || l === "4" || l === "5" ? `${o}rounded-${l}` : l === "none" ? `${o}rounded-0` : l === "sm" ? `${o}rounded-1` : l === "lg" ? `${o}rounded-5` : `${o}rounded`;
  };
  return B(() => {
    const l = Se(t);
    return {
      [`${e(l.rounded, null)}`]: !!l.rounded,
      [`${e(l.roundedTop, "top")}`]: !!l.roundedTop,
      [`${e(l.roundedBottom, "bottom")}`]: !!l.roundedBottom,
      [`${e(l.roundedStart, "start")}`]: !!l.roundedStart,
      [`${e(l.roundedEnd, "end")}`]: !!l.roundedEnd
    };
  });
}, Hr = () => {
  const t = Ve(Po);
  return Xe(() => {
    ue(
      [() => t == null ? void 0 : t.isRtl.value, () => t == null ? void 0 : t.locale.value],
      ([e, l]) => {
        const a = document.documentElement;
        a.setAttribute("dir", e ?? !1 ? "rtl" : "ltr"), a.setAttribute("lang", l ?? "");
      },
      { immediate: !0 }
    );
  }), { ...t };
}, Xo = (t, e) => {
  const l = qe($(t)), a = qe($(e)), o = $(() => !a.value);
  Xe(() => {
    const r = dr(
      document.body,
      l.value && o.value
    );
    ue([l, o], ([n, s]) => {
      r.value = n && s;
    });
  });
}, Ko = (t, e, l = {}) => {
  const a = $(t), o = $(e), r = x(mt(a.value)), n = x(mt(o.value));
  ue([a, o], () => {
    h();
  });
  const {
    contentQuery: s = ":scope > [id]",
    targetQuery: i = "[href]",
    manual: u = !1,
    root: d,
    rootMargin: p = "0px 0px -25%",
    threshold: f = [0.1, 0.5, 1],
    watchChanges: m = !0
  } = l, y = x(null), c = x([]), g = x([]);
  gt() ? Xe(() => {
    Sa(a, r, {
      transform: {
        ltr: (L) => mt(L)
      },
      direction: "ltr",
      immediate: !0
    }), Sa(o, n, {
      transform: {
        ltr: (L) => mt(L)
      },
      direction: "ltr",
      immediate: !0
    }), h();
  }) : _e(() => {
    h();
  });
  const h = () => {
    g.value = r.value ? Array.from(r.value.querySelectorAll(s)) : [], c.value = g.value.map((L) => ({
      id: L.id,
      el: L,
      visible: !1,
      text: L.textContent
    }));
  };
  let k = !0, C = 0;
  const w = B(
    () => r.value && getComputedStyle(r.value).overflowY === "visible" ? null : r.value
  ), _ = sr(
    g,
    (L) => {
      var le, N, S, E;
      const J = (le = w.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : le.scrollTop;
      k = J > C, C = J, L.forEach((M) => {
        if (M.isIntersecting) {
          c.value.forEach((j) => {
            j.el === M.target && (j.visible = !0);
          });
          return;
        }
        c.value.forEach((j) => {
          j.el === M.target && (j.visible = !1);
        });
      });
      let R = null;
      k ? R = ((N = [...c.value].reverse().find((M) => M.visible)) == null ? void 0 : N.id) || null : R = ((S = c.value.find((M) => M.visible)) == null ? void 0 : S.id) || null, R !== null && (y.value = R), y.value || (y.value = ((E = c.value[0]) == null ? void 0 : E.id) || null);
    },
    {
      root: d ? mt(d) : w,
      rootMargin: p,
      threshold: f
    }
  );
  ue(y, (L) => {
    var N;
    if (u)
      return;
    const J = (N = n.value) == null ? void 0 : N.querySelectorAll(i);
    if (J === void 0)
      return;
    let R = !1, le = null;
    J.forEach((S) => {
      var M, j, A, K, G, ie, q, ne, ge, te, ye;
      const E = S.closest(".dropdown");
      if ((M = S.getAttribute("href")) != null && M.includes(`#${L}`)) {
        le = S, S.classList.add("active"), E && ((j = E == null ? void 0 : E.querySelector(".dropdown-toggle")) == null || j.classList.add("active"), R = !0);
        let ee = (A = S.closest(".nav")) == null ? void 0 : A.previousSibling;
        for (; (K = ee == null ? void 0 : ee.classList) != null && K.contains("nav-item"); )
          R = !0, (G = ee.querySelector(".nav-link")) == null || G.classList.add("active"), ee = (ie = ee.closest(".nav")) == null ? void 0 : ie.previousSibling;
      } else if (S.classList.remove("active"), E && !R && ((q = E == null ? void 0 : E.querySelector(".dropdown-toggle")) == null || q.classList.remove("active")), !R) {
        let ee = (ne = S.closest(".nav")) == null ? void 0 : ne.previousSibling;
        for (; (ge = ee == null ? void 0 : ee.classList) != null && ge.contains("nav-item"); )
          R = !0, ee.querySelector(".nav-link") !== le && ((te = ee.querySelector(".nav-link")) == null || te.classList.remove("active")), ee = (ye = ee.closest(".nav")) == null ? void 0 : ye.previousSibling;
      }
    });
  });
  const F = m ? nr(
    r,
    () => {
      h();
    },
    {
      childList: !0
    }
  ) : { stop: () => {
  } }, Q = (L, J = !1) => {
    var N, S;
    L.preventDefault();
    const R = (S = (N = L.target) == null ? void 0 : N.getAttribute) == null ? void 0 : S.call(N, "href"), le = R ? document == null ? void 0 : document.querySelector(R) : null;
    le && r.value && (r.value.scrollTo ? r.value.scrollTo({ top: le.offsetTop, behavior: J ? "smooth" : "auto" }) : r.value.scrollTop = le.offsetTop);
  }, W = () => {
    _.stop(), F.stop();
  };
  return {
    current: qe(y),
    list: c,
    content: r,
    target: n,
    scrollIntoView: Q,
    updateList: h,
    cleanup: W
  };
}, Yo = () => ({ ...Ve(Io) }), It = /* @__PURE__ */ H({
  __name: "BTransition",
  props: {
    appear: { type: Boolean, default: !1 },
    mode: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    transProps: { default: void 0 }
  },
  emits: ["after-appear", "after-enter", "after-leave", "appear", "before-appear", "before-enter", "before-leave", "enter", "appear-cancelled", "enter-cancelled", "leave", "leave-cancelled"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = B(() => {
      const n = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, s = {
        ...n,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.noFade ? n : s;
    }), r = B(() => ({ mode: l.mode, css: !0, ...o.value }));
    return (n, s) => (b(), I(On, X({ ...r.value, ...n.transProps }, {
      appear: l.appear,
      onAfterAppear: s[0] || (s[0] = (i) => a("after-appear", i)),
      onAfterEnter: s[1] || (s[1] = (i) => a("after-enter", i)),
      onAfterLeave: s[2] || (s[2] = (i) => a("after-leave", i)),
      onAppear: s[3] || (s[3] = (i) => a("appear", i)),
      onBeforeAppear: s[4] || (s[4] = (i) => a("before-appear", i)),
      onBeforeEnter: s[5] || (s[5] = (i) => a("before-enter", i)),
      onBeforeLeave: s[6] || (s[6] = (i) => a("before-leave", i)),
      onEnter: s[7] || (s[7] = (i) => a("enter", i)),
      onAppearCancelled: s[8] || (s[8] = (i) => a("appear-cancelled", i)),
      onEnterCancelled: s[9] || (s[9] = (i) => a("enter-cancelled", i)),
      onLeave: s[10] || (s[10] = (i) => a("leave", i)),
      onLeaveCancelled: s[11] || (s[11] = (i) => a("leave-cancelled", i))
    }), {
      default: P(() => [
        T(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["appear"]));
  }
}), Rr = ["type", "disabled", "aria-label"], Pt = /* @__PURE__ */ H({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: Boolean, default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e;
    return (o, r) => (b(), V("button", {
      type: o.type,
      class: "btn-close",
      disabled: l.disabled,
      "aria-label": o.ariaLabel,
      onClick: r[0] || (r[0] = (n) => a("click", n))
    }, null, 8, Rr));
  }
}), Cl = "active", lt = /* @__PURE__ */ H({
  __name: "BLink",
  props: {
    active: { type: Boolean, default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    exactActiveClass: { default: "router-link-exact-active" },
    href: { default: void 0 },
    icon: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: null },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = Mt(), r = Ve(Ka, null), n = Ve(Ya, null), s = gt(), i = B(() => {
      const y = l.routerComponentName.split("-").map((g) => g.charAt(0).toUpperCase() + g.slice(1)).join("");
      return !((s == null ? void 0 : s.appContext.app.component(y)) !== void 0) || l.disabled || !l.to ? "a" : l.routerComponentName;
    }), u = B(() => {
      const y = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || y;
      const { to: c } = l;
      if (c !== void 0 && "path" in c) {
        const g = c.path || "", v = c.query ? `?${Object.keys(c.query).map((k) => {
          var C;
          return `${k}=${(C = c.query) == null ? void 0 : C[k]}`;
        }).join("=")}` : "", h = !c.hash || c.hash.charAt(0) === "#" ? c.hash || "" : `#${c.hash}`;
        return `${g}${v}${h}` || y;
      }
      return y;
    }), d = B(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": l.icon === !0
    })), p = B(() => ({
      class: d.value,
      to: l.to,
      href: u.value,
      target: l.target,
      rel: l.target === "_blank" ? l.rel ?? "noopener" : void 0,
      tabindex: l.disabled ? "-1" : typeof o.tabindex > "u" ? null : o.tabindex,
      "aria-disabled": l.disabled ? !0 : null
    })), f = B(() => ({
      [Cl]: l.active,
      disabled: l.disabled
    })), m = (y) => {
      var c, g, v;
      if (l.disabled) {
        y.preventDefault(), y.stopImmediatePropagation();
        return;
      }
      (((c = r == null ? void 0 : r.isNav) == null ? void 0 : c.value) === !0 && n === null || n !== null && ((g = n.autoClose) == null ? void 0 : g.value) === !0) && ((v = r == null ? void 0 : r.hide) == null || v.call(r)), a("click", y);
    };
    return (y, c) => i.value === "router-link" ? (b(), I(re(i.value), X({ key: 0 }, p.value, { custom: "" }), {
      default: P(({ href: g, navigate: v, isActive: h, isExactActive: k }) => [
        (b(), I(re(y.routerTag), X({
          href: g,
          class: {
            [Cl]: l.active,
            [y.activeClass]: h,
            [y.exactActiveClass]: k
          }
        }, y.$attrs, {
          onClick: (C) => {
            v(C), m(C);
          }
        }), {
          default: P(() => [
            T(y.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (b(), I(re(i.value), X({
      key: 1,
      class: f.value
    }, p.value, { onClick: m }), {
      default: P(() => [
        T(y.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Mr = ["aria-valuenow", "aria-valuemax"], Jo = /* @__PURE__ */ H({
  __name: "BProgressBar",
  props: {
    animated: { type: Boolean, default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: Boolean, default: !1 },
    showValue: { type: Boolean, default: !1 },
    striped: { type: Boolean, default: !1 },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Ve(To, null), a = Qe(e), o = B(() => [
      a.value,
      {
        "progress-bar-animated": e.animated || (l == null ? void 0 : l.animated.value),
        "progress-bar-striped": e.striped || (l == null ? void 0 : l.striped.value) || e.animated || (l == null ? void 0 : l.animated.value)
      }
    ]), r = be(() => e.precision), n = be(() => e.value), s = be(() => e.max ?? NaN), i = be(() => (l == null ? void 0 : l.max.value) ?? NaN), u = B(
      () => e.labelHtml !== void 0 ? e.labelHtml : e.showValue || l != null && l.showValue.value ? n.value.toFixed(r.value) : e.showProgress || l != null && l.showProgress.value ? (n.value * 100 / (s.value || 100)).toFixed(r.value) : e.label !== void 0 ? e.label : ""
    ), d = B(
      () => i.value ? `${n.value * 100 / i.value}%` : s.value ? `${n.value * 100 / s.value}%` : typeof e.value == "string" ? e.value : `${e.value}%`
    );
    return (p, f) => (b(), V("div", {
      class: D(["progress-bar", o.value]),
      role: "progressbar",
      "aria-valuenow": p.value,
      "aria-valuemin": "0",
      "aria-valuemax": p.max,
      style: Ee({ width: d.value })
    }, [
      T(p.$slots, "default", {}, () => [
        se(Y(u.value), 1)
      ])
    ], 14, Mr));
  }
}), Zo = /* @__PURE__ */ H({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: Boolean, default: void 0 },
    max: { default: 100 },
    precision: { default: void 0 },
    showProgress: { type: Boolean, default: void 0 },
    showValue: { type: Boolean, default: void 0 },
    striped: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return tt(To, {
      animated: $(() => e.animated),
      max: $(() => e.max),
      showProgress: $(() => e.showProgress),
      showValue: $(() => e.showValue),
      striped: $(() => e.striped)
    }), (l, a) => (b(), V("div", {
      class: "progress",
      style: Ee({ height: l.height })
    }, [
      T(l.$slots, "default", {}, () => [
        ve(Jo, {
          animated: l.animated,
          max: l.max,
          precision: l.precision,
          "show-progress": l.showProgress,
          "show-value": l.showValue,
          striped: l.striped,
          value: l.value,
          variant: l.variant,
          "text-variant": l.textVariant,
          "bg-variant": l.bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
}), xr = ["id", "role", "aria-live", "aria-atomic"], Dr = { class: "me-auto" }, Qo = /* @__PURE__ */ H({
  __name: "BToast",
  props: /* @__PURE__ */ pe({
    body: { default: void 0 },
    bodyClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    id: { default: void 0 },
    interval: { default: 1e3 },
    isStatus: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, Number] },
    noCloseButton: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noHoverPause: { type: Boolean, default: !1 },
    progressProps: { default: void 0 },
    showOnPause: { type: Boolean, default: !0 },
    solid: { type: Boolean, default: !1 },
    title: { default: void 0 },
    toastClass: { default: void 0 },
    transProps: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["close", "close-countdown", "hide", "hidden", "show", "shown", "show-prevented", "hide-prevented"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = x(null), n = Ua(r), s = he(t, "modelValue"), { computedLink: i, computedLinkProps: u } = wt(a), d = be(() => a.interval), p = Qe(a), f = $(() => typeof s.value == "boolean" ? 0 : s.value), {
      isActive: m,
      pause: y,
      restart: c,
      resume: g,
      stop: v,
      isPaused: h,
      value: k
    } = Ro(f, d, {
      immediate: typeof s.value == "number"
    });
    Rt(() => {
      o("close-countdown", k.value);
    });
    const C = $(() => i.value ? lt : "div"), w = $(
      () => typeof s.value == "boolean" ? s.value : m.value || a.showOnPause && h.value
    ), _ = B(() => [
      p.value,
      {
        show: w.value
      }
    ]), F = () => {
      a.noHoverPause || y();
    };
    ue(n, (N) => {
      if (N) {
        F();
        return;
      }
      g();
    });
    const Q = (N, S = {}) => new Bt(N, {
      cancelable: !1,
      target: r.value || null,
      relatedTarget: null,
      trigger: null,
      ...S,
      componentId: a.id
    }), W = () => {
      const N = Q("show", { cancelable: !0 });
      if (o("show", N), N.defaultPrevented) {
        s.value && (s.value = !1), o("show-prevented");
        return;
      }
      s.value || (s.value = !0);
    }, L = (N = "") => {
      const S = Q("hide", { cancelable: N !== "", trigger: N });
      if (o("hide", S), N === "close" && o("close", S), S.defaultPrevented) {
        o("hide-prevented"), s.value || (s.value = !0);
        return;
      }
      typeof s.value == "boolean" ? s.value = !1 : (s.value = 0, v());
    }, J = () => {
      W();
    }, R = () => {
      o("shown", Q("shown"));
    }, le = () => {
      o("hidden", Q("hidden"));
    };
    return ue(m, (N) => {
      N === !1 && h.value === !1 && s.value && L();
    }), La(v), e({
      pause: y,
      restart: c,
      resume: g,
      stop: v
    }), (N, S) => (b(), I(It, X({
      "no-fade": a.noFade
    }, N.transProps, {
      onBeforeEnter: J,
      onAfterEnter: R,
      onAfterLeave: le
    }), {
      default: P(() => [
        w.value ? (b(), V("div", {
          key: 0,
          id: N.id,
          ref_key: "element",
          ref: r,
          class: D(["toast", [N.toastClass, _.value]]),
          tabindex: "0",
          role: w.value ? a.isStatus ? "status" : "alert" : void 0,
          "aria-live": w.value ? a.isStatus ? "polite" : "assertive" : void 0,
          "aria-atomic": w.value ? !0 : void 0
        }, [
          N.$slots.title || N.title ? (b(), I(re(N.headerTag), {
            key: 0,
            class: "toast-header"
          }, {
            default: P(() => [
              T(N.$slots, "title", { hide: L }, () => [
                Z("strong", Dr, Y(N.title), 1)
              ]),
              a.noCloseButton ? ae("", !0) : (b(), I(Pt, {
                key: 0,
                onClick: S[0] || (S[0] = (E) => L("close"))
              }))
            ]),
            _: 3
          })) : ae("", !0),
          N.$slots.default || N.body ? (b(), I(re(C.value), X({
            key: 1,
            class: ["toast-body", N.bodyClass],
            style: { display: "block" }
          }, O(u), {
            onClick: S[1] || (S[1] = (E) => O(i) ? L() : () => {
            })
          }), {
            default: P(() => [
              T(N.$slots, "default", { hide: L }, () => [
                se(Y(N.body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : ae("", !0),
          typeof s.value == "number" && N.progressProps !== void 0 ? (b(), I(Zo, {
            key: 2,
            animated: N.progressProps.animated,
            precision: N.progressProps.precision,
            "show-progress": N.progressProps.showProgress,
            "show-value": N.progressProps.showValue,
            striped: N.progressProps.striped,
            variant: N.progressProps.variant,
            max: s.value,
            value: O(k),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : ae("", !0)
        ], 10, xr)) : ae("", !0)
      ]),
      _: 3
    }, 16, ["no-fade"]));
  }
}), jr = "top-right", qr = {
  install(t) {
    const e = bt([]), l = x(!1), a = (n) => {
      l.value = n;
    }, o = (n) => {
      const s = Symbol(), i = B(() => {
        const u = Se(n.props);
        return {
          component: Se(n.component) ?? Qo,
          props: {
            ...u,
            pos: (u == null ? void 0 : u.pos) || jr,
            _modelValue: (u == null ? void 0 : u.value) || 5e3,
            _self: s
          }
        };
      });
      return (i.value.props.appendToast !== void 0 ? i.value.props.appendToast : l.value) ? e.value = [...e.value, i] : e.value = [i, ...e.value], s;
    }, r = (n) => {
      e.value = e.value.filter((s) => s.value.props._self !== n);
    };
    t.provide(Io, {
      _setIsAppend: a,
      toasts: e,
      show: o,
      remove: r
    });
  }
}, Wr = {
  install(t) {
    const e = x([]), l = () => {
      e.value.splice(0, e.value.length);
    };
    t.provide(Eo, { items: e, reset: l });
  }
}, Gr = {
  install(t, e) {
    (e == null ? void 0 : e.id) instanceof Object && typeof e.id.getId == "function" && t.provide(zo, e.id.getId);
  }
}, Ur = {
  key: 0,
  class: "visually-hidden"
}, pa = /* @__PURE__ */ H({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: Boolean, default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = Fe(), a = B(() => [
      `spinner-${e.type}`,
      {
        [`spinner-${e.type}-sm`]: e.small,
        [`text-${e.variant}`]: e.variant !== null
      }
    ]), o = $(() => !Ae(l.label));
    return (r, n) => (b(), I(re(r.tag), {
      class: D(a.value),
      role: r.label || o.value ? r.role : null,
      "aria-hidden": r.label || o.value ? null : !0
    }, {
      default: P(() => [
        r.label || o.value ? (b(), V("span", Ur, [
          T(r.$slots, "label", {}, () => [
            se(Y(r.label), 1)
          ])
        ])) : ae("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), vt = /* @__PURE__ */ H({
  __name: "BButton",
  props: /* @__PURE__ */ pe({
    loading: { type: Boolean, default: !1 },
    loadingFill: { type: Boolean, default: !1 },
    loadingText: { default: "Loading..." },
    pill: { type: Boolean, default: !1 },
    pressed: { type: Boolean },
    size: { default: "md" },
    squared: { type: Boolean, default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    routerTag: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  }, {
    pressed: { type: Boolean, default: void 0 },
    pressedModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["click"], ["update:pressed"]),
  setup(t, { emit: e }) {
    const l = t, a = e, o = he(t, "pressed"), { computedLink: r, computedLinkProps: n } = wt(l, [
      "active-class",
      "exact-active-class",
      "replace",
      "routerComponentName",
      "routerTag"
    ]), s = $(() => typeof l.pressed == "boolean"), i = $(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), u = $(() => l.to !== void 0), d = $(() => l.href !== void 0 ? !1 : !i.value), p = B(() => u.value ? n.value : []), f = B(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        active: l.active || l.pressed,
        "rounded-pill": l.pill,
        "rounded-0": l.squared,
        disabled: l.disabled
      }
    ]), m = $(() => u.value ? lt : l.href ? "a" : l.tag), y = (c) => {
      if (l.disabled) {
        c.preventDefault(), c.stopPropagation();
        return;
      }
      a("click", c), s.value && (o.value = !l.pressed);
    };
    return (c, g) => (b(), I(re(m.value), X({ class: "btn" }, p.value, {
      class: f.value,
      "aria-disabled": d.value ? l.disabled : null,
      "aria-pressed": s.value ? l.pressed : null,
      autocomplete: s.value ? "off" : null,
      disabled: i.value ? l.disabled : null,
      href: c.href,
      rel: O(r) ? c.rel : null,
      role: d.value || O(r) ? "button" : null,
      target: O(r) ? c.target : null,
      type: i.value ? c.type : null,
      to: i.value ? null : c.to,
      append: O(r) ? c.append : null,
      onClick: y
    }), {
      default: P(() => [
        l.loading ? T(c.$slots, "loading", { key: 0 }, () => [
          l.loadingFill ? ae("", !0) : (b(), V(de, { key: 0 }, [
            se(Y(c.loadingText), 1)
          ], 64)),
          T(c.$slots, "loading-spinner", {}, () => [
            ve(pa, {
              small: c.size !== "lg",
              label: l.loadingFill ? c.loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : T(c.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to", "append"]));
  }
}), ma = /* @__PURE__ */ H({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: Boolean, default: !1 },
    noCenter: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noSpinner: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    show: { type: Boolean, default: !1 },
    spinnerSmall: { type: Boolean, default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "hidden", "shown"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = { top: 0, left: 0, bottom: 0, right: 0 }, r = Qa(() => ({
      rounded: l.rounded,
      roundedTop: l.roundedTop,
      roundedBottom: l.roundedBottom,
      roundedStart: l.roundedStart,
      roundedEnd: l.roundedEnd
    })), n = $(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), s = $(() => l.show ? !0 : null), i = B(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: l.spinnerSmall
    })), u = B(() => ({
      ...o,
      zIndex: l.zIndex || 10
    })), d = B(() => ({
      "position-absolute": !l.noWrap || !l.fixed,
      "position-fixed": l.noWrap && l.fixed
    })), p = B(() => [n.value, r.value]), f = B(() => ({
      ...o,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), m = B(
      () => l.noCenter ? o : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (y, c) => (b(), I(re(y.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": s.value
    }, {
      default: P(() => [
        T(y.$slots, "default"),
        ve(It, {
          "no-fade": y.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onAfterEnter: c[1] || (c[1] = (g) => a("shown")),
          onAfterLeave: c[2] || (c[2] = (g) => a("hidden"))
        }, {
          default: P(() => [
            l.show ? (b(), I(re(y.overlayTag), {
              key: 0,
              class: D(["b-overlay", d.value]),
              style: Ee(u.value),
              onClick: c[0] || (c[0] = (g) => a("click", g))
            }, {
              default: P(() => [
                Z("div", {
                  class: D(["position-absolute", p.value]),
                  style: Ee(f.value)
                }, null, 6),
                Z("div", {
                  class: "position-absolute",
                  style: Ee(m.value)
                }, [
                  T(y.$slots, "overlay", me(we(i.value)), () => [
                    l.noSpinner ? ae("", !0) : (b(), I(pa, me(X({ key: 0 }, i.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : ae("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), Xr = ["id", "aria-labelledby", "aria-describedby"], Kr = ["id"], kl = 1056, Yr = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BModal",
  props: /* @__PURE__ */ pe({
    autoFocus: { type: Boolean, default: !0 },
    autoFocusButton: { default: void 0 },
    body: { default: void 0 },
    backdropVariant: { default: void 0 },
    bodyAttrs: { default: void 0 },
    bodyBgVariant: { default: null },
    bodyClass: { default: null },
    bodyScrolling: { type: Boolean, default: !1 },
    bodyTextVariant: { default: null },
    bodyVariant: { default: null },
    busy: { type: Boolean, default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: Boolean, default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    footerVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerTextVariant: { default: null },
    headerVariant: { default: null },
    hideBackdrop: { type: Boolean, default: !1 },
    hideFooter: { type: Boolean, default: !1 },
    hideHeader: { type: Boolean, default: !1 },
    hideHeaderClose: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modalClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    okDisabled: { type: Boolean, default: !1 },
    okOnly: { type: Boolean, default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: Boolean, default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: Boolean, default: !1 },
    titleTag: { default: "h5" },
    transProps: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["cancel", "close", "hidden", "hide", "hide-prevented", "ok", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Fe(), n = Be(() => a.id, "modal"), s = he(t, "modelValue"), i = x(null), u = x(null), d = x(null), p = x(null), f = x(s.value), m = x(!1);
    Re(
      "Escape",
      () => {
        j("esc");
      },
      { target: i }
    ), Xo(s, () => a.bodyScrolling);
    const { focused: y } = Pe(i, {
      initialValue: s.value && a.autoFocusButton === void 0
    }), { focused: c } = Pe(u, {
      initialValue: s.value && a.autoFocusButton === "ok"
    }), { focused: g } = Pe(d, {
      initialValue: s.value && a.autoFocusButton === "cancel"
    }), { focused: v } = Pe(p, {
      initialValue: s.value && a.autoFocusButton === "close"
    }), h = B(() => [
      a.modalClass,
      {
        fade: !a.noFade,
        show: f.value
      }
    ]), k = $(
      () => a.lazy === !1 || a.lazy === !0 && m.value === !0 || a.lazy === !0 && s.value === !0
    ), C = $(
      () => a.backdropVariant !== void 0 ? a.backdropVariant : a.hideBackdrop ? "transparent" : "dark"
    ), w = $(() => !Ae(r["header-close"])), _ = B(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": a.centered,
        "modal-dialog-scrollable": a.scrollable
      }
    ]), F = Qe(() => ({
      bgVariant: a.bodyBgVariant,
      textVariant: a.bodyTextVariant,
      variant: a.bodyVariant
    })), Q = B(() => [a.bodyClass, F.value]), W = Qe(() => ({
      bgVariant: a.headerBgVariant,
      textVariant: a.headerTextVariant,
      variant: a.headerVariant
    })), L = B(() => [
      a.headerClass,
      W.value,
      {
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null
      }
    ]), J = B(() => ({
      variant: w.value ? a.headerCloseVariant : void 0,
      class: a.headerCloseClass
    })), R = Qe(() => ({
      bgVariant: a.footerBgVariant,
      textVariant: a.footerTextVariant,
      variant: a.footerVariant
    })), le = B(() => [
      a.footerClass,
      R.value,
      {
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null
      }
    ]), N = B(() => [
      a.titleClass,
      {
        "visually-hidden": a.titleSrOnly
      }
    ]), S = $(() => a.cancelDisabled || a.busy), E = $(() => a.okDisabled || a.busy), M = (U, z = {}) => new Bt(U, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ...z,
      componentId: n.value
    });
    ue(s, (U, z) => {
      U !== z && (U === !0 ? A() : j());
    });
    const j = (U = "") => {
      if (U === "backdrop" && a.noCloseOnBackdrop || U === "esc" && a.noCloseOnEsc) {
        o("hide-prevented");
        return;
      }
      const z = M("hide", { cancelable: U !== "", trigger: U });
      if (U === "ok" && o(U, z), U === "cancel" && o(U, z), U === "close" && o(U, z), o("hide", z), z.defaultPrevented) {
        o("hide-prevented"), s.value || (s.value = !0);
        return;
      }
      s.value && (s.value = !1);
    }, A = () => {
      if (f.value)
        return;
      const U = M("show", { cancelable: !0 });
      if (o("show", U), U.defaultPrevented) {
        s.value && (s.value = !1), o("show-prevented");
        return;
      }
      s.value || (s.value = !0);
    }, K = () => {
      a.autoFocus !== !1 && (a.autoFocusButton === "ok" ? c.value = !0 : a.autoFocusButton === "close" ? v.value = !0 : a.autoFocusButton === "cancel" ? g.value = !0 : y.value = !0);
    }, G = () => {
      A();
    }, ie = () => {
      f.value = !0, K(), o("shown", M("shown")), a.lazy === !0 && (m.value = !0);
    }, q = () => {
      f.value = !1;
    }, ne = () => {
      o("hidden", M("hidden")), a.lazy === !0 && (m.value = !1);
    }, { activePosition: ge, activeModalCount: te } = Fr(f), ye = B(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": f.value ? kl - (((te == null ? void 0 : te.value) ?? 0) - ((ge == null ? void 0 : ge.value) ?? 0)) : kl
    }));
    ke(i, "bv-toggle", () => {
      s.value ? j() : A();
    });
    const ee = B(() => ({
      cancel: () => {
        j("cancel");
      },
      close: () => {
        j("close");
      },
      hide: j,
      ok: () => {
        j("ok");
      },
      visible: s.value
    }));
    return e({
      hide: j,
      id: n,
      show: A
    }), (U, z) => {
      var oe;
      return b(), I(ht, {
        to: U.teleportTo,
        disabled: a.teleportDisabled
      }, [
        ve(It, X({ "no-fade": !0 }, U.transProps, {
          "trans-props": { enterToClass: "show", ...(oe = U.transProps) == null ? void 0 : oe.transProps },
          onBeforeEnter: G,
          onAfterEnter: ie,
          onLeave: q,
          onAfterLeave: ne
        }), {
          default: P(() => [
            ut(Z("div", X({
              id: O(n),
              ref_key: "element",
              ref: i,
              class: ["modal", h.value],
              role: "dialog",
              "aria-labelledby": a.hideHeader ? void 0 : `${O(n)}-label`,
              "aria-describedby": `${O(n)}-body`,
              tabindex: "-1"
            }, U.$attrs, { style: ye.value }), [
              Z("div", {
                class: D(["modal-dialog", _.value])
              }, [
                k.value ? (b(), V("div", {
                  key: 0,
                  class: D(["modal-content", U.contentClass])
                }, [
                  a.hideHeader ? ae("", !0) : (b(), V("div", {
                    key: 0,
                    class: D(["modal-header", L.value])
                  }, [
                    T(U.$slots, "header", me(we(ee.value)), () => [
                      (b(), I(re(U.titleTag), {
                        id: `${O(n)}-label`,
                        class: D(["modal-title", N.value])
                      }, {
                        default: P(() => [
                          T(U.$slots, "title", me(we(ee.value)), () => [
                            se(Y(U.title), 1)
                          ], !0)
                        ]),
                        _: 3
                      }, 8, ["id", "class"])),
                      a.hideHeaderClose ? ae("", !0) : (b(), V(de, { key: 0 }, [
                        w.value ? (b(), I(vt, X({ key: 0 }, J.value, {
                          onClick: z[0] || (z[0] = (fe) => j("close"))
                        }), {
                          default: P(() => [
                            T(U.$slots, "header-close", {}, void 0, !0)
                          ]),
                          _: 3
                        }, 16)) : (b(), I(Pt, X({
                          key: 1,
                          "aria-label": U.headerCloseLabel
                        }, J.value, {
                          onClick: z[1] || (z[1] = (fe) => j("close"))
                        }), null, 16, ["aria-label"]))
                      ], 64))
                    ], !0)
                  ], 2)),
                  Z("div", X({
                    id: `${O(n)}-body`,
                    class: ["modal-body", Q.value]
                  }, U.bodyAttrs), [
                    T(U.$slots, "default", me(we(ee.value)), () => [
                      se(Y(U.body), 1)
                    ], !0)
                  ], 16, Kr),
                  a.hideFooter ? ae("", !0) : (b(), V("div", {
                    key: 1,
                    class: D(["modal-footer", le.value])
                  }, [
                    T(U.$slots, "footer", me(we(ee.value)), () => [
                      T(U.$slots, "cancel", me(we(ee.value)), () => [
                        a.okOnly ? ae("", !0) : (b(), I(vt, {
                          key: 0,
                          ref_key: "cancelButton",
                          ref: d,
                          disabled: S.value,
                          size: U.buttonSize,
                          variant: U.cancelVariant,
                          onClick: z[2] || (z[2] = (fe) => j("cancel"))
                        }, {
                          default: P(() => [
                            se(Y(U.cancelTitle), 1)
                          ]),
                          _: 1
                        }, 8, ["disabled", "size", "variant"]))
                      ], !0),
                      T(U.$slots, "ok", me(we(ee.value)), () => [
                        ve(vt, {
                          ref_key: "okButton",
                          ref: u,
                          disabled: E.value,
                          size: U.buttonSize,
                          variant: U.okVariant,
                          onClick: z[3] || (z[3] = (fe) => j("ok"))
                        }, {
                          default: P(() => [
                            se(Y(U.okTitle), 1)
                          ]),
                          _: 1
                        }, 8, ["disabled", "size", "variant"])
                      ], !0)
                    ], !0)
                  ], 2))
                ], 2)) : ae("", !0)
              ], 2),
              T(U.$slots, "backdrop", {}, () => [
                ve(ma, {
                  variant: C.value,
                  show: s.value,
                  "no-spinner": "",
                  fixed: "",
                  "no-wrap": "",
                  blur: null,
                  onClick: z[4] || (z[4] = (fe) => j("backdrop"))
                }, null, 8, ["variant", "show"])
              ], !0)
            ], 16, Xr), [
              [xt, s.value]
            ])
          ]),
          _: 3
        }, 16, ["trans-props"])
      ], 8, ["to", "disabled"]);
    };
  }
}), qt = (t, e) => {
  const l = t.__vccOpts || t;
  for (const [a, o] of e)
    l[a] = o;
  return l;
}, Va = /* @__PURE__ */ qt(Yr, [["__scopeId", "data-v-8a2b2b28"]]), Jr = {
  install(t) {
    const e = bt([]), l = () => {
      let n = () => {
      };
      return {
        value: new Promise((i) => {
          n = i;
        }),
        resolve: n
      };
    }, a = (n) => {
      const s = l(), i = Symbol();
      return e.value = [
        ...e.value,
        B(() => ({
          component: Se(n.component) ?? Va,
          props: { ...Se(n.props), _isConfirm: !1, _promise: s, _self: i, _modelValue: !0 }
        }))
      ], s.value;
    }, o = (n) => {
      const s = l(), i = Symbol();
      return e.value = [
        ...e.value,
        B(() => ({
          component: Se(n.component) ?? Va,
          props: { ...Se(n.props), _isConfirm: !0, _promise: s, _self: i, _modelValue: !0 }
        }))
      ], s.value;
    }, r = (n) => {
      e.value = e.value.filter((s) => s.value.props._self !== n);
    };
    t.provide(Lo, {
      modals: e,
      remove: r,
      show: a,
      confirm: o
    });
  }
}, Zr = {
  install(t) {
    const e = bt([]), l = $(() => e.value.length), a = $(() => e.value[e.value.length - 1]), o = (u) => {
      e.value = [...e.value, u];
    }, r = (u) => {
      e.value = e.value.filter((d) => d.uid !== u.uid);
    }, n = bt([]), s = (u) => {
      n.value = [...n.value, u];
    }, i = (u) => {
      n.value = n.value.filter((d) => d.uid !== u.uid);
    };
    t.provide(Fo, {
      stack: e,
      countStack: l,
      lastStack: a,
      registry: n,
      pushStack: o,
      removeStack: r,
      pushRegistry: s,
      removeRegistry: i
    });
  }
}, Qr = {
  install(t, e) {
    var i, u;
    const o = typeof (e == null ? void 0 : e.rtl) == "boolean" ? !1 : ((i = e == null ? void 0 : e.rtl) == null ? void 0 : i.rtlInitial) ?? !1, r = typeof (e == null ? void 0 : e.rtl) == "boolean" ? void 0 : ((u = e == null ? void 0 : e.rtl) == null ? void 0 : u.localeInitial) ?? void 0, n = x(o), s = x(r);
    t.provide(Po, { isRtl: n, locale: s });
  }
}, ei = ["id"], ti = /* @__PURE__ */ H({
  __name: "BAccordion",
  props: /* @__PURE__ */ pe({
    flush: { type: Boolean, default: !1 },
    free: { type: Boolean, default: !1 },
    id: { default: void 0 },
    modelValue: {}
  }, {
    modelValue: {
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t) {
    const e = t, l = he(t, "modelValue"), a = Be(() => e.id, "accordion"), o = B(() => ({
      "accordion-flush": e.flush
    }));
    return tt(_o, {
      openItem: qe(l),
      free: $(() => e.free),
      setOpenItem: (r) => {
        l.value = r;
      }
    }), (r, n) => (b(), V("div", {
      id: O(a),
      class: D(["accordion", o.value])
    }, [
      T(r.$slots, "default")
    ], 10, ei));
  }
}), en = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: /* @__PURE__ */ pe({
    horizontal: { type: Boolean, default: !1 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    skipAnimation: { type: Boolean, default: !1 },
    tag: { default: "div" },
    toggle: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !1 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = (w, _ = {}) => new Bt(w, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ..._,
      componentId: s.value
    }), n = he(t, "modelValue"), s = Be(() => a.id, "collapse"), i = x(null), u = x(!1), d = x(n.value), p = B(() => ({
      show: d.value,
      "navbar-collapse": a.isNav,
      collapsing: u.value,
      closing: d.value && !n.value,
      "collapse-horizontal": a.horizontal
    })), f = () => {
      n.value = !1;
    }, m = () => {
      n.value = !0;
    }, y = () => {
      n.value = !n.value;
    }, c = B(() => ({
      toggle: y,
      show: m,
      hide: f,
      id: s.value,
      visible: n.value
    }));
    let g, v, h = a.skipAnimation;
    const k = () => {
      const w = r("show", { cancelable: !0 });
      if (o("show", w), w.defaultPrevented) {
        o("show-prevented");
        return;
      }
      clearTimeout(v), clearTimeout(g), d.value = !0, !h && (u.value = !0, _e(() => {
        i.value !== null && (a.horizontal ? i.value.style.width = `${i.value.scrollWidth}px` : i.value.style.height = `${i.value.scrollHeight}px`, g = setTimeout(() => {
          u.value = !1, o("shown"), i.value !== null && (i.value.style.height = "", i.value.style.width = "");
        }, wa(i.value)));
      }));
    }, C = () => {
      const w = r("hide", { cancelable: !0 });
      if (o("hide", w), w.defaultPrevented) {
        o("hide-prevented");
        return;
      }
      if (clearTimeout(g), clearTimeout(v), i.value !== null) {
        if (h) {
          d.value = !1;
          return;
        }
        u.value ? (i.value.style.height = "", i.value.style.width = "") : a.horizontal ? i.value.style.width = `${i.value.scrollWidth}px` : i.value.style.height = `${i.value.scrollHeight}px`, i.value.offsetHeight, u.value = !0, _e(() => {
          i.value !== null && (i.value.style.height = "", i.value.style.width = "", v = setTimeout(() => {
            d.value = !1, u.value = !1, o("hidden");
          }, wa(i.value)));
        });
      }
    };
    return ue(n, () => {
      n.value ? k() : C();
    }), Xe(() => {
      i.value !== null && !n.value && a.toggle && _e(() => {
        n.value = !0;
      });
    }), ue(
      () => a.skipAnimation,
      (w) => {
        h = w;
      }
    ), a.visible && (h = !0, n.value = !0, _e(() => {
      h = a.skipAnimation;
    })), ue(
      () => a.visible,
      (w) => {
        h = !0, w ? m() : f(), _e(() => {
          h = a.skipAnimation;
        });
      }
    ), ke(i, "bv-toggle", () => {
      n.value = !n.value;
    }), e({
      hide: f,
      isNav: a.isNav,
      show: m,
      toggle: y,
      visible: qe(d)
    }), tt(Ka, {
      id: s,
      hide: f,
      show: m,
      toggle: y,
      visible: qe(d),
      isNav: $(() => a.isNav)
    }), (w, _) => (b(), V(de, null, [
      T(w.$slots, "header", me(we(c.value))),
      (b(), I(re(w.tag), X({
        id: O(s),
        ref_key: "element",
        ref: i,
        class: ["collapse", p.value],
        "is-nav": a.isNav
      }, w.$attrs), {
        default: P(() => [
          T(w.$slots, "default", me(we(c.value)))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      T(w.$slots, "footer", me(we(c.value)))
    ], 64));
  }
}), ai = ["aria-expanded", "aria-controls", "onClick"], li = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: /* @__PURE__ */ pe({
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    buttonAttrs: { default: void 0 },
    buttonClass: { default: void 0 },
    collapseClass: { default: void 0 },
    headerAttrs: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "h2" },
    horizontal: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    tag: { default: void 0 },
    title: { default: void 0 },
    toggle: { type: Boolean, default: void 0 },
    visible: { type: Boolean, default: !1 },
    wrapperAttrs: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { emit: e }) {
    const { class: l, ...a } = Mt(), o = t, r = e, n = he(t, "modelValue"), s = Ve(_o, null), i = Be(() => o.id, "accordion_item");
    return Xe(() => {
      n.value && !(s != null && s.free.value) && (s == null || s.setOpenItem(i.value)), !n.value && (s == null ? void 0 : s.openItem.value) === i.value && (n.value = !0);
    }), ue(
      () => s == null ? void 0 : s.openItem.value,
      () => n.value = (s == null ? void 0 : s.openItem.value) === i.value && !(s != null && s.free.value)
    ), ue(n, () => {
      n.value && !(s != null && s.free.value) && (s == null || s.setOpenItem(i.value));
    }), (u, d) => (b(), V("div", X({ class: "accordion-item" }, u.wrapperAttrs, { class: O(l) }), [
      ve(en, X({
        id: O(i),
        modelValue: n.value,
        "onUpdate:modelValue": d[0] || (d[0] = (p) => n.value = p),
        class: ["accordion-collapse", u.collapseClass],
        "aria-labelledby": `${O(i)}-heading`
      }, a, {
        tag: u.tag,
        toggle: u.toggle,
        horizontal: u.horizontal,
        visible: u.visible,
        "is-nav": u.isNav,
        onShow: d[1] || (d[1] = (p) => r("show", p)),
        onShown: d[2] || (d[2] = (p) => r("shown")),
        onHide: d[3] || (d[3] = (p) => r("hide", p)),
        onHidden: d[4] || (d[4] = (p) => r("hidden")),
        onHidePrevented: d[5] || (d[5] = (p) => r("hide-prevented")),
        onShowPrevented: d[6] || (d[6] = (p) => r("show-prevented"))
      }), {
        header: P(({ visible: p, toggle: f }) => [
          (b(), I(re(u.headerTag), X({
            id: `${O(i)}-heading`,
            class: ["accordion-header", u.headerClass]
          }, u.headerAttrs), {
            default: P(() => [
              Z("button", X({ class: "accordion-button" }, u.buttonAttrs, {
                class: [{ collapsed: !p }, u.buttonClass],
                type: "button",
                "aria-expanded": p ? "true" : "false",
                "aria-controls": O(i),
                onClick: f
              }), [
                T(u.$slots, "title", {}, () => [
                  se(Y(u.title), 1)
                ])
              ], 16, ai)
            ]),
            _: 2
          }, 1040, ["id", "class"]))
        ]),
        default: P(() => [
          Z("div", X({ class: "accordion-body" }, u.bodyAttrs, { class: u.bodyClass }), [
            T(u.$slots, "default")
          ], 16)
        ]),
        _: 3
      }, 16, ["id", "modelValue", "class", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ], 16));
  }
}), oi = /* @__PURE__ */ H({
  __name: "BAlert",
  props: /* @__PURE__ */ pe({
    closeClass: { default: void 0 },
    closeContent: { default: void 0 },
    closeLabel: { default: "Close" },
    closeVariant: { default: "secondary" },
    dismissible: { type: Boolean, default: !1 },
    fade: { type: Boolean, default: !1 },
    immediate: { type: Boolean, default: !0 },
    interval: { default: 1e3 },
    modelValue: { type: [Boolean, Number] },
    noHoverPause: { type: Boolean, default: !1 },
    showOnPause: { type: Boolean, default: !0 },
    variant: { default: "info" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["close", "close-countdown", "closed"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Fe(), n = x(null), s = he(t, "modelValue"), i = Ua(n), u = be(() => a.interval), d = $(() => !Ae(r.close)), p = $(() => typeof s.value == "boolean" ? 0 : s.value), f = B(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": a.dismissible
    })), m = B(() => [a.closeClass, { "btn-close-custom": d.value }]), {
      isActive: y,
      pause: c,
      restart: g,
      resume: v,
      stop: h,
      isPaused: k,
      value: C
    } = Ro(p, u, {
      immediate: typeof s.value == "number" && a.immediate
    }), w = $(
      () => typeof s.value == "boolean" ? s.value : y.value || a.showOnPause && k.value
    ), _ = B(() => ({
      variant: d.value ? a.closeVariant : void 0,
      class: m.value
    }));
    Rt(() => {
      o("close-countdown", C.value);
    });
    const F = () => {
      o("close"), typeof s.value == "boolean" ? s.value = !1 : (s.value = 0, h()), o("closed");
    }, Q = () => {
      a.noHoverPause || c();
    };
    return ue(i, (W) => {
      if (W) {
        Q();
        return;
      }
      v();
    }), La(h), e({
      pause: c,
      restart: g,
      resume: v,
      stop: h
    }), (W, L) => (b(), I(It, {
      "no-fade": !a.fade,
      "trans-props": { enterToClass: "show" }
    }, {
      default: P(() => [
        w.value ? (b(), V("div", {
          key: 0,
          ref_key: "element",
          ref: n,
          class: D(["alert", f.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          T(W.$slots, "default", {}, void 0, !0),
          a.dismissible ? (b(), V(de, { key: 0 }, [
            d.value || W.closeContent ? (b(), I(vt, X({ key: 0 }, _.value, { onClick: F }), {
              default: P(() => [
                T(W.$slots, "close", {}, () => [
                  se(Y(W.closeContent), 1)
                ], !0)
              ]),
              _: 3
            }, 16)) : (b(), I(Pt, X({
              key: 1,
              "aria-label": W.closeLabel
            }, _.value, { onClick: F }), null, 16, ["aria-label"]))
          ], 64)) : ae("", !0)
        ], 2)) : ae("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), ni = /* @__PURE__ */ qt(oi, [["__scopeId", "data-v-30d91aa1"]]), si = {
  key: 0,
  class: "b-avatar-custom"
}, ri = {
  key: 1,
  class: "b-avatar-img"
}, ii = ["src", "alt"], $l = 0.4, ui = /* @__PURE__ */ H({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: !1 },
    badgeBgVariant: { default: null },
    badgeOffset: { default: void 0 },
    badgeStart: { type: Boolean, default: !1 },
    badgeTextVariant: { default: null },
    badgeTop: { type: Boolean, default: !1 },
    badgeVariant: { default: "primary" },
    button: { type: Boolean, default: !1 },
    buttonType: { default: "button" },
    icon: { default: void 0 },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = Fe(), { computedLink: r, computedLinkProps: n } = wt(l), s = Ve(Vo, null), i = ["sm", null, "lg"], u = $l * 0.7, d = $(() => !Ae(o.default)), p = $(() => !Ae(o.badge)), f = $(() => !!l.badge || l.badge === "" || p.value), m = $(() => (s == null ? void 0 : s.size.value) ?? l.square), y = ia(() => l.size), c = ia(() => s == null ? void 0 : s.size.value), g = B(() => c.value ?? y.value), v = $(() => (s == null ? void 0 : s.variant.value) ?? l.variant), h = $(() => (s == null ? void 0 : s.rounded.value) ?? l.rounded), k = $(() => (s == null ? void 0 : s.roundedTop.value) ?? l.roundedTop), C = $(() => (s == null ? void 0 : s.roundedBottom.value) ?? l.roundedBottom), w = $(() => (s == null ? void 0 : s.roundedStart.value) ?? l.roundedStart), _ = $(() => (s == null ? void 0 : s.roundedEnd.value) ?? l.roundedEnd), F = Qa(() => ({
      rounded: h.value,
      roundedTop: k.value,
      roundedBottom: C.value,
      roundedStart: w.value,
      roundedEnd: _.value
    })), Q = Qe(() => ({
      variant: l.badgeVariant,
      bgVariant: l.badgeBgVariant,
      textVariant: l.badgeTextVariant
    })), W = $(() => l.badge === !0 ? "" : l.badge), L = $(() => (s == null ? void 0 : s.textVariant.value) ?? l.textVariant), J = $(() => (s == null ? void 0 : s.bgVariant.value) ?? l.bgVariant), R = Qe(() => ({
      bgVariant: J.value,
      textVariant: L.value,
      variant: v.value
    })), le = B(() => [
      R.value,
      // Square overwrites all else
      m.value === !0 ? void 0 : F.value,
      {
        [`b-avatar-${l.size}`]: !!l.size && i.indexOf(y.value) !== -1,
        [`btn-${v.value}`]: l.button ? v.value !== null : !1,
        badge: !l.button && v.value !== null && d.value,
        btn: l.button,
        // Square is the same as rounded-0 class
        "rounded-0": m.value === !0
      }
    ]), N = B(() => {
      const G = l.badgeOffset || "0px";
      return {
        fontSize: (i.indexOf(g.value || null) === -1 ? `calc(${g.value} * ${u})` : "") || "",
        top: l.badgeTop ? G : "",
        bottom: l.badgeTop ? "" : G,
        left: l.badgeStart ? G : "",
        right: l.badgeStart ? "" : G
      };
    }), S = B(() => {
      const G = i.indexOf(g.value || null) === -1 ? `calc(${g.value} * ${$l})` : null;
      return G ? { fontSize: G } : {};
    }), E = B(() => {
      var q;
      const G = ((q = s == null ? void 0 : s.overlapScale) == null ? void 0 : q.value) || 0, ie = g.value && G ? `calc(${g.value} * -${G})` : null;
      return ie ? { marginLeft: ie, marginRight: ie } : {};
    }), M = $(() => r.value ? lt : l.button ? "button" : "span"), j = B(() => ({
      ...E.value,
      width: g.value ?? void 0,
      height: g.value ?? void 0
    })), A = (G) => {
      !l.disabled && (r.value || l.button) && a("click", G);
    }, K = (G) => {
      a("img-error", G);
    };
    return (G, ie) => (b(), I(re(M.value), X({
      class: ["b-avatar", le.value],
      style: j.value
    }, O(n), {
      type: l.button && !O(r) ? l.buttonType : void 0,
      disabled: l.disabled || null,
      onClick: A
    }), {
      default: P(() => [
        d.value ? (b(), V("span", si, [
          T(G.$slots, "default")
        ])) : G.src ? (b(), V("span", ri, [
          Z("img", {
            src: G.src,
            alt: G.alt,
            onError: K
          }, null, 40, ii)
        ])) : G.text ? (b(), V("span", {
          key: 2,
          class: "b-avatar-text",
          style: Ee(S.value)
        }, Y(G.text), 5)) : ae("", !0),
        f.value ? (b(), V("span", {
          key: 3,
          class: D(["b-avatar-badge", O(Q)]),
          style: Ee(N.value)
        }, [
          T(G.$slots, "badge", {}, () => [
            se(Y(W.value), 1)
          ])
        ], 6)) : ae("", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
}), di = /* @__PURE__ */ H({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = t, l = be(() => e.overlap), a = ia(() => e.size), o = $(() => Math.min(Math.max(l.value, 0), 1) / 2), r = B(() => {
      const n = a.value ? `calc(${a.value} * ${o.value})` : null;
      return n ? { paddingLeft: n, paddingRight: n } : {};
    });
    return tt(Vo, {
      overlapScale: o,
      size: $(() => e.size),
      square: $(() => e.square),
      rounded: $(() => e.rounded),
      roundedTop: $(() => e.roundedTop),
      roundedBottom: $(() => e.roundedBottom),
      roundedStart: $(() => e.roundedStart),
      roundedEnd: $(() => e.roundedEnd),
      variant: $(() => e.variant),
      bgVariant: $(() => e.bgVariant),
      textVariant: $(() => e.textVariant)
    }), (n, s) => (b(), I(re(n.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: P(() => [
        Z("div", {
          class: "b-avatar-group-inner",
          style: Ee(r.value)
        }, [
          T(n.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), ci = /* @__PURE__ */ H({
  __name: "BBadge",
  props: {
    dotIndicator: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    tag: { default: "span" },
    textIndicator: { type: Boolean, default: !1 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Qe(e), { computedLink: a, computedLinkProps: o } = wt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), r = $(() => a.value ? lt : e.tag), n = B(() => [
      l.value,
      {
        active: e.active,
        disabled: e.disabled,
        "rounded-pill": e.pill,
        "position-absolute top-0 start-100 translate-middle": e.textIndicator || e.dotIndicator,
        "p-2 border border-light rounded-circle": e.dotIndicator,
        "text-decoration-none": a.value
      }
    ]);
    return (s, i) => (b(), I(re(r.value), X({
      class: ["badge", n.value]
    }, O(o)), {
      default: P(() => [
        T(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), tn = /* @__PURE__ */ H({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = B(() => ({
      active: l.active
    })), r = $(() => l.active ? "span" : lt), n = $(() => l.active ? l.ariaCurrent : void 0), s = B(
      () => r.value !== "span" ? Ja(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), i = (u) => {
      if (l.disabled || l.active) {
        u.preventDefault(), u.stopImmediatePropagation();
        return;
      }
      l.disabled || a("click", u);
    };
    return (u, d) => (b(), V("li", {
      class: D(["breadcrumb-item", o.value])
    }, [
      (b(), I(re(r.value), X({ "aria-current": n.value }, s.value, { onClick: i }), {
        default: P(() => [
          T(u.$slots, "default", {}, () => [
            se(Y(u.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), fi = { "aria-label": "breadcrumb" }, vi = { class: "breadcrumb" }, pi = /* @__PURE__ */ H({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(t) {
    const e = t, l = Ho(), a = B(() => {
      var s;
      const o = e.items || ((s = l.items) == null ? void 0 : s.value) || [];
      let r = !1;
      return o.map((i, u) => (typeof i == "string" && (i = { text: i }, u < o.length - 1 && (i.href = "#")), i.active && (r = !0), !i.active && !r && (i.active = u + 1 === o.length), i));
    });
    return (o, r) => (b(), V("nav", fi, [
      Z("ol", vi, [
        T(o.$slots, "prepend"),
        (b(!0), V(de, null, Ce(a.value, (n, s) => (b(), I(tn, X({ key: s }, n), {
          default: P(() => [
            se(Y(n.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        T(o.$slots, "default"),
        T(o.$slots, "append")
      ])
    ]));
  }
}), mi = /* @__PURE__ */ H({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = B(() => ({
      "btn-group": !e.vertical,
      [`btn-group-${e.size}`]: e.size !== "md",
      "btn-group-vertical": e.vertical
    }));
    return (a, o) => (b(), I(re(a.tag), {
      class: D(l.value),
      role: "group",
      "aria-label": a.ariaLabel
    }, {
      default: P(() => [
        T(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), bi = ["role", "aria-label"], yi = /* @__PURE__ */ H({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: Boolean, default: !1 },
    role: { default: "toolbar" }
  },
  setup(t) {
    const e = t, l = B(() => ({
      "justify-content-between": e.justify
    }));
    return (a, o) => (b(), V("div", {
      class: D([l.value, "btn-toolbar"]),
      role: a.role,
      "aria-label": a.ariaLabel
    }, [
      T(a.$slots, "default")
    ], 10, bi));
  }
}), gi = ["src", "width", "height", "srcset", "sizes", "loading"], el = /* @__PURE__ */ H({
  __name: "BImg",
  props: {
    blank: { type: Boolean, default: !1 },
    blankColor: { default: "transparent" },
    block: { type: Boolean, default: !1 },
    center: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    fluid: { type: Boolean, default: !1 },
    fluidGrow: { type: Boolean, default: !1 },
    height: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    start: { type: Boolean, default: !1 },
    thumbnail: { type: Boolean, default: !1 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = t, l = be(() => e.height ?? NaN), a = be(() => e.width ?? NaN), o = Qa(() => ({
      rounded: e.rounded,
      roundedTop: e.roundedTop,
      roundedBottom: e.roundedBottom,
      roundedStart: e.roundedStart,
      roundedEnd: e.roundedEnd
    })), r = B(
      () => typeof e.srcset == "string" ? e.srcset.split(",").filter((f) => f).join(",") : Array.isArray(e.srcset) ? e.srcset.filter((f) => f).join(",") : void 0
    ), n = B(
      () => typeof e.sizes == "string" ? e.sizes.split(",").filter((f) => f).join(",") : Array.isArray(e.sizes) ? e.sizes.filter((f) => f).join(",") : void 0
    ), s = B(() => {
      const f = Number.isNaN(a.value) ? void 0 : a.value, m = Number.isNaN(l.value) ? void 0 : l.value;
      return e.blank ? f !== void 0 && m === void 0 ? { height: f, width: f } : f === void 0 && m !== void 0 ? { height: m, width: m } : { height: 1, width: 1 } : {
        width: f,
        height: m
      };
    }), i = $(
      () => p(s.value.width, s.value.height, e.blankColor)
    ), u = $(
      () => e.start ? "float-start" : e.end ? "float-end" : e.center ? "mx-auto" : void 0
    ), d = B(() => [
      o.value,
      {
        "img-thumbnail": e.thumbnail,
        "img-fluid": e.fluid || e.fluidGrow,
        "w-100": e.fluidGrow,
        [`${u.value}`]: u.value !== void 0,
        "d-block": e.block || e.center
      }
    ]), p = (f, m, y) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width="${f}" height="${m}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${f} ${m}" preserveAspectRatio="none">
    <rect width="100%" height="100%" style="fill:${y};"></rect>
    </svg>`)}`;
    return (f, m) => (b(), V("img", {
      class: D(d.value),
      src: e.blank ? i.value : f.src,
      width: s.value.width || void 0,
      height: s.value.height || void 0,
      srcset: e.blank ? void 0 : r.value,
      sizes: e.blank ? void 0 : n.value,
      loading: e.lazy ? "lazy" : "eager"
    }, null, 10, gi));
  }
}), tl = /* @__PURE__ */ H({
  __name: "BCardImg",
  props: {
    bottom: { type: Boolean, default: !1 },
    top: { type: Boolean, default: !1 },
    blank: { type: Boolean, default: void 0 },
    blankColor: { default: void 0 },
    block: { type: Boolean, default: void 0 },
    center: { type: Boolean, default: void 0 },
    end: { type: Boolean, default: void 0 },
    fluid: { type: Boolean, default: void 0 },
    fluidGrow: { type: Boolean, default: void 0 },
    height: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    start: { type: Boolean, default: void 0 },
    thumbnail: { type: Boolean, default: void 0 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: void 0 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = t, l = $(
      () => e.top ? "card-img-top" : e.end ? "card-img-right" : e.bottom ? "card-img-bottom" : e.start ? "card-img-left" : "card-img"
    ), a = B(() => va(e, ["bottom", "top", "end", "start"]));
    return (o, r) => (b(), I(el, X(a.value, { class: l.value }), null, 16, ["class"]));
  }
}), hi = ["innerHTML"], an = /* @__PURE__ */ H({
  __name: "BCardHeadFoot",
  props: {
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Qe(e), a = B(() => [
      l.value,
      {
        [`border-${e.borderVariant}`]: e.borderVariant !== null
      }
    ]);
    return (o, r) => (b(), I(re(o.tag), {
      class: D(a.value)
    }, {
      default: P(() => [
        o.html ? (b(), V("div", {
          key: 0,
          innerHTML: o.html
        }, null, 8, hi)) : T(o.$slots, "default", { key: 1 }, () => [
          se(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ln = /* @__PURE__ */ H({
  __name: "BCardHeader",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return (l, a) => (b(), I(an, X({ class: "card-header" }, e), {
      default: P(() => [
        T(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), on = /* @__PURE__ */ H({
  __name: "BCardTitle",
  props: {
    tag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "card-title" }, {
      default: P(() => [
        T(e.$slots, "default", {}, () => [
          se(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), nn = /* @__PURE__ */ H({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null
    }));
    return (a, o) => (b(), I(re(a.tag), {
      class: D(["card-subtitle mb-2", l.value])
    }, {
      default: P(() => [
        T(a.$slots, "default", {}, () => [
          se(Y(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), sn = /* @__PURE__ */ H({
  __name: "BCardBody",
  props: {
    overlay: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Fe(), a = Qe(e), o = $(() => !Ae(l.title)), r = $(() => !Ae(l.subtitle)), n = B(() => [
      a.value,
      {
        "card-img-overlay": e.overlay
      }
    ]);
    return (s, i) => (b(), I(re(s.tag), {
      class: D(["card-body", n.value])
    }, {
      default: P(() => [
        s.title || o.value ? (b(), I(on, {
          key: 0,
          tag: s.titleTag
        }, {
          default: P(() => [
            T(s.$slots, "title", {}, () => [
              se(Y(s.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : ae("", !0),
        s.subtitle || r.value ? (b(), I(nn, {
          key: 1,
          tag: s.subtitleTag,
          "text-variant": s.subtitleTextVariant
        }, {
          default: P(() => [
            T(s.$slots, "subtitle", {}, () => [
              se(Y(s.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : ae("", !0),
        T(s.$slots, "default", {}, () => [
          se(Y(s.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), rn = /* @__PURE__ */ H({
  __name: "BCardFooter",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return (l, a) => (b(), I(an, X({ class: "card-footer" }, e), {
      default: P(() => [
        T(l.$slots, "default", {}, () => [
          se(Y(l.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), un = /* @__PURE__ */ H({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyText: { default: "" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    footerVariant: { default: null },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    headerVariant: { default: null },
    imgAlt: { default: void 0 },
    imgBottom: { type: Boolean, default: !1 },
    imgEnd: { type: Boolean, default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: Boolean, default: !1 },
    imgTop: { type: Boolean, default: !1 },
    imgWidth: { default: void 0 },
    noBody: { type: Boolean, default: !1 },
    overlay: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Fe(), a = $(() => !Ae(l.header)), o = $(() => !Ae(l.footer)), r = Qe(e), n = B(() => [
      r.value,
      {
        [`text-${e.align}`]: e.align !== void 0,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "flex-row": e.imgStart,
        "flex-row-reverse": e.imgEnd
      }
    ]), s = B(() => ({
      src: e.imgSrc,
      alt: e.imgAlt,
      height: e.imgHeight,
      width: e.imgWidth,
      bottom: e.imgBottom,
      end: e.imgEnd,
      start: e.imgStart,
      top: e.imgTop
    })), i = zt();
    return (u, d) => (b(), I(re(u.tag), {
      class: D(["card", n.value])
    }, {
      default: P(() => [
        ve(O(i).define, null, {
          default: P(() => [
            T(u.$slots, "img", {}, () => [
              u.imgSrc ? (b(), I(tl, me(X({ key: 0 }, s.value)), null, 16)) : ae("", !0)
            ])
          ]),
          _: 3
        }),
        e.imgBottom ? ae("", !0) : (b(), I(O(i).reuse, { key: 0 })),
        u.header || a.value || u.headerHtml ? (b(), I(ln, {
          key: 1,
          "bg-variant": u.headerBgVariant,
          variant: u.headerVariant,
          "border-variant": u.headerBorderVariant,
          html: u.headerHtml,
          tag: u.headerTag,
          "text-variant": u.headerTextVariant,
          class: D(u.headerClass)
        }, {
          default: P(() => [
            T(u.$slots, "header", {}, () => [
              se(Y(u.header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : ae("", !0),
        e.noBody ? T(u.$slots, "default", { key: 3 }, () => [
          se(Y(u.bodyText), 1)
        ]) : (b(), I(sn, {
          key: 2,
          overlay: u.overlay,
          "bg-variant": u.bodyBgVariant,
          tag: u.bodyTag,
          "text-variant": u.bodyTextVariant,
          subtitle: u.subtitle,
          "subtitle-tag": u.subtitleTag,
          "subtitle-text-variant": u.subtitleTextVariant,
          title: u.title,
          "title-tag": u.titleTag,
          class: D(u.bodyClass)
        }, {
          default: P(() => [
            T(u.$slots, "default", {}, () => [
              se(Y(u.bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        u.footer || o.value || u.footerHtml ? (b(), I(rn, {
          key: 4,
          "bg-variant": u.footerBgVariant,
          "border-variant": u.footerBorderVariant,
          variant: u.footerVariant,
          html: u.footerHtml,
          tag: u.footerTag,
          "text-variant": u.footerTextVariant,
          class: D(u.footerClass)
        }, {
          default: P(() => [
            T(u.$slots, "footer", {}, () => [
              se(Y(u.footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : ae("", !0),
        e.imgBottom ? (b(), I(O(i).reuse, { key: 5 })) : ae("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Bi = /* @__PURE__ */ H({
  __name: "BCardGroup",
  props: {
    columns: { type: Boolean, default: !1 },
    deck: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = $(
      () => e.deck ? "card-deck" : e.columns ? "card-columns" : "card-group"
    );
    return (a, o) => (b(), I(re(a.tag), {
      class: D(l.value)
    }, {
      default: P(() => [
        T(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), wi = /* @__PURE__ */ H({
  __name: "BCardText",
  props: {
    tag: { default: "p" },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "card-text" }, {
      default: P(() => [
        T(e.$slots, "default", {}, () => [
          se(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Ci = ["id"], ki = {
  key: 0,
  class: "carousel-indicators"
}, $i = ["aria-current", "aria-label", "onClick"], Ti = /* @__PURE__ */ Z("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Si = { class: "visually-hidden" }, Vi = /* @__PURE__ */ Z("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), _i = { class: "visually-hidden" }, Ai = /* @__PURE__ */ H({
  __name: "BCarousel",
  props: /* @__PURE__ */ pe({
    background: { default: void 0 },
    controls: { type: Boolean, default: !1 },
    controlsNextText: { default: "Next" },
    controlsPrevText: { default: "Previous" },
    fade: { type: Boolean, default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    indicators: { type: Boolean, default: !1 },
    indicatorsButtonLabel: { default: "Slide" },
    interval: { default: 5e3 },
    keyboard: { type: Boolean, default: !0 },
    modelValue: {},
    noHoverPause: { type: Boolean, default: !1 },
    noTouch: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    ride: { type: [Boolean, String], default: !1 },
    rideReverse: { type: Boolean, default: !1 },
    touchThreshold: { default: 50 }
  }, {
    modelValue: { default: 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["slide", "slid"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Fe(), n = Be(() => a.id, "carousel"), s = he(t, "modelValue"), i = be(() => a.touchThreshold), u = be(() => a.interval), d = x(!1), p = x(!1), f = x(!0), m = x(null), y = x(null), c = x(s.value), g = Ua(y), v = $(
      () => `carousel-item carousel-item-${f.value ? "prev" : "next"} carousel-item-${f.value ? "end" : "start"}`
    ), h = $(
      () => `carousel-item active carousel-item-${f.value ? "start" : "end"}`
    ), { pause: k, resume: C } = bo(
      () => {
        a.rideReverse ? L() : J();
      },
      u,
      { immediate: a.ride === "carousel" }
    ), w = $(
      () => a.ride === !0 && p.value === !0 || a.ride === "carousel"
    ), _ = B(() => Br(r.default, "BCarouselSlide")), F = B(() => ({ "carousel-fade": a.fade })), Q = (A) => {
      var K;
      return new ql(A, {
        componentId: n.value,
        cancelable: !1,
        target: y.value,
        direction: f.value ? "right" : "left",
        from: c.value,
        to: s.value,
        relatedTarget: ((K = m.value) == null ? void 0 : K.children[s.value]) ?? null
      });
    }, W = (A) => {
      if (d.value !== !0) {
        if (a.ride === !0 && (p.value = !0), w.value === !0 && C(), f.value = !(A < s.value), A >= _.value.length) {
          if (a.noWrap)
            return;
          s.value = 0;
          return;
        }
        if (A < 0) {
          if (a.noWrap)
            return;
          s.value = _.value.length - 1;
          return;
        }
        c.value = s.value, s.value = A;
      }
    }, L = () => {
      W(s.value - 1);
    }, J = () => {
      W(s.value + 1);
    }, R = (A) => {
      a.keyboard !== !1 && A();
    }, le = () => {
      a.noHoverPause || k();
    }, N = () => {
      w.value && C();
    }, { lengthX: S } = cr(y, {
      passive: !0,
      onSwipeStart() {
        a.noTouch !== !0 && k();
      },
      onSwipeEnd() {
        if (a.noTouch === !0)
          return;
        const A = () => {
          w.value !== !1 && C();
        };
        if (S.value >= i.value) {
          J(), A();
          return;
        }
        S.value <= -i.value && (L(), A());
      }
    }), E = () => {
      o("slide", Q("slide")), d.value = !0;
    }, M = () => {
      o("slid", Q("slid")), d.value = !1;
    }, j = (A) => {
      s.value !== 0 && A.classList.add("carousel-item");
    };
    return Re(
      "ArrowLeft",
      () => {
        R(L);
      },
      { target: y }
    ), Re(
      "ArrowRight",
      () => {
        R(J);
      },
      { target: y }
    ), ue(
      () => a.ride,
      () => {
        p.value = !1;
      }
    ), ue(g, (A) => {
      if (A) {
        le();
        return;
      }
      N();
    }), e({
      next: J,
      pause: k,
      prev: L,
      resume: C
    }), tt(ko, {
      background: $(() => a.background),
      width: $(() => a.imgWidth),
      height: $(() => a.imgHeight)
    }), (A, K) => (b(), V("div", {
      id: O(n),
      ref_key: "element",
      ref: y,
      class: D(["carousel slide pointer-event", F.value])
    }, [
      a.indicators ? (b(), V("div", ki, [
        (b(!0), V(de, null, Ce(_.value.length, (G, ie) => (b(), V("button", {
          key: ie,
          type: "button",
          "data-bs-target": "",
          class: D(ie === s.value ? "active" : ""),
          "aria-current": ie === s.value ? !0 : void 0,
          "aria-label": `${A.indicatorsButtonLabel} ${ie}`,
          onClick: (q) => W(ie)
        }, null, 10, $i))), 128))
      ])) : ae("", !0),
      Z("div", {
        ref_key: "relatedTarget",
        ref: m,
        class: "carousel-inner"
      }, [
        ve(jl, {
          "enter-from-class": v.value,
          "enter-active-class": v.value,
          "enter-to-class": v.value,
          "leave-from-class": h.value,
          "leave-active-class": h.value,
          "leave-to-class": h.value,
          onBeforeLeave: E,
          onAfterLeave: M,
          onAfterEnter: j
        }, {
          default: P(() => [
            (b(!0), V(de, null, Ce(_.value, (G, ie) => ut((b(), I(re(G), {
              key: ie,
              class: D({ active: ie === s.value && d.value === !1 })
            }, null, 8, ["class"])), [
              [xt, ie === s.value]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      a.controls ? (b(), V(de, { key: 1 }, [
        Z("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: L
        }, [
          Ti,
          Z("span", Si, Y(A.controlsPrevText), 1)
        ]),
        Z("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: J
        }, [
          Vi,
          Z("span", _i, Y(A.controlsNextText), 1)
        ])
      ], 64)) : ae("", !0)
    ], 10, Ci));
  }
}), Oi = ["innerHTML"], Ni = { key: 1 }, Ii = ["innerHTML"], Pi = { key: 1 }, Ei = /* @__PURE__ */ H({
  __name: "BCarouselSlide",
  props: {
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: Boolean, default: !1 },
    imgBlankColor: { default: "transparent" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(t) {
    const e = t, l = Fe(), a = Ve(ko, null), o = $(() => e.text || e.textHtml || !Ae(l.text)), r = $(() => e.caption || e.captionHtml || !Ae(l.caption)), n = $(() => o.value || r.value || !Ae(l.default)), s = B(() => ({
      background: `${e.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), i = B(() => ({
      "d-none": e.contentVisibleUp !== void 0,
      [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0
    }));
    return (u, d) => (b(), V("div", {
      class: "carousel-item",
      style: Ee(s.value)
    }, [
      T(u.$slots, "img", {}, () => {
        var p, f;
        return [
          ve(el, {
            class: "d-block w-100",
            alt: u.imgAlt,
            srcset: u.imgSrcset,
            src: u.imgSrc,
            width: u.imgWidth || ((p = O(a)) == null ? void 0 : p.width.value),
            height: u.imgHeight || ((f = O(a)) == null ? void 0 : f.height.value),
            blank: u.imgBlank,
            "blank-color": u.imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      n.value ? (b(), I(re(u.contentTag), {
        key: 0,
        class: D(["carousel-caption", i.value])
      }, {
        default: P(() => [
          r.value ? (b(), I(re(u.captionTag), { key: 0 }, {
            default: P(() => [
              T(u.$slots, "caption", {}, () => [
                u.captionHtml ? (b(), V("span", {
                  key: 0,
                  innerHTML: u.captionHtml
                }, null, 8, Oi)) : (b(), V("span", Ni, Y(u.caption), 1))
              ])
            ]),
            _: 3
          })) : ae("", !0),
          o.value ? (b(), I(re(u.textTag), { key: 1 }, {
            default: P(() => [
              T(u.$slots, "text", {}, () => [
                u.textHtml ? (b(), V("span", {
                  key: 0,
                  innerHTML: u.textHtml
                }, null, 8, Ii)) : (b(), V("span", Pi, Y(u.text), 1))
              ])
            ]),
            _: 3
          })) : ae("", !0),
          T(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : ae("", !0)
    ], 4));
  }
}), Tl = fa("", [], { type: [Boolean, String, Number], default: !1 }), Sl = fa("offset", [""], { type: [String, Number], default: null }), Vl = fa("order", [""], { type: [String, Number], default: null }), Li = H({
  name: "BCol",
  slots: Object,
  props: {
    col: { type: Boolean, default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Tl,
    offset: { type: [String, Number], default: null },
    ...Sl,
    order: { type: [String, Number], default: null },
    ...Vl,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(t) {
    const e = [
      { content: Tl, propPrefix: "cols", classPrefix: "col" },
      { content: Sl, propPrefix: "offset" },
      { content: Vl, propPrefix: "order" }
    ], l = B(
      () => e.flatMap((o) => Bo(t, o.content, o.propPrefix, o.classPrefix))
    );
    return {
      computedClasses: B(() => [
        l.value,
        {
          col: t.col || !l.value.some((o) => /^col-/.test(o)) && !t.cols,
          [`col-${t.cols}`]: !!t.cols,
          [`offset-${t.offset}`]: !!t.offset,
          [`order-${t.order}`]: !!t.order,
          [`align-self-${t.alignSelf}`]: !!t.alignSelf
        }
      ])
    };
  }
});
function Fi(t, e, l, a, o, r) {
  return b(), I(re(t.tag), {
    class: D(t.computedClasses)
  }, {
    default: P(() => [
      T(t.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Lt = /* @__PURE__ */ qt(Li, [["render", Fi]]), zi = /* @__PURE__ */ H({
  __name: "BContainer",
  props: {
    fluid: { type: [Boolean, String], default: !1 },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = be(() => e.gutterX ?? NaN, { method: "parseInt" }), a = be(() => e.gutterY ?? NaN, { method: "parseInt" }), o = B(() => ({
      container: e.fluid === !1,
      "container-fluid": e.fluid === !0,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${l.value}`]: !Number.isNaN(l.value),
      [`gy-${a.value}`]: !Number.isNaN(a.value)
    }));
    return (r, n) => (b(), I(re(r.tag), {
      class: D(o.value)
    }, {
      default: P(() => [
        T(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Hi = { class: "visually-hidden" }, Ri = ["aria-labelledby", "role"], dn = /* @__PURE__ */ H({
  __name: "BDropdown",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Be(() => a.id, "dropdown"), n = he(t, "modelValue"), s = $(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), i = be(s), u = x(null), d = x(null), p = x(null), f = x(null), m = B(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), y = B(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), c = $(() => a.split ? d.value : p.value);
    Re(
      "Escape",
      () => {
        n.value = !n.value;
      },
      { target: c }
    ), Re(
      "Escape",
      () => {
        n.value = !n.value;
      },
      { target: u }
    );
    const g = (N, S) => {
      var M, j, A, K, G, ie, q;
      if ((j = u.value) != null && j.contains((M = N.target) == null ? void 0 : M.closest("form")) || /input|select|option|textarea|form/i.test((A = N.target) == null ? void 0 : A.tagName))
        return;
      if (N.preventDefault(), !n.value) {
        open(), _e(() => g(N, S));
        return;
      }
      const E = (K = u.value) == null ? void 0 : K.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (E)
        if ((G = u.value) != null && G.contains(document.activeElement)) {
          const ne = u.value.querySelector(".dropdown-item:focus"), ge = Array.prototype.indexOf.call(E, ne) + S;
          ge >= 0 && ge < (E == null ? void 0 : E.length) && ((ie = E[ge]) == null || ie.focus());
        } else
          (q = E[S === -1 ? E.length - 1 : 0]) == null || q.focus();
    };
    Re("ArrowUp", (N) => g(N, -1), { target: c }), Re("ArrowDown", (N) => g(N, 1), { target: c }), Re("ArrowUp", (N) => g(N, -1), { target: u }), Re("ArrowDown", (N) => g(N, 1), { target: u });
    const v = B(
      () => gr({
        top: a.dropup,
        start: a.dropstart,
        end: a.dropend,
        alignCenter: a.center,
        alignEnd: a.end
      })
    ), h = x({}), k = B(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const N = typeof a.offset == "string" || typeof a.offset == "number" ? i.value : a.offset, S = [Kl(N)];
      return a.noFlip === !1 && S.push(
        so({
          boundary: m.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === !1 && S.push(
        no({
          boundary: m.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.noSize === !1 && S.push(
        ro({
          boundary: m.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: E, availableHeight: M }) {
            h.value = {
              maxHeight: M && n.value ? `${M}px` : void 0,
              maxWidth: E && n.value ? `${E}px` : void 0
            };
          }
        })
      ), S;
    }), { update: C, floatingStyles: w } = uo(c, u, {
      placement: v,
      middleware: k,
      strategy: $(() => a.strategy),
      whileElementsMounted: oo
    }), _ = B(() => ({
      dropup: a.dropup,
      dropend: a.dropend,
      dropstart: a.dropstart,
      "position-static": a.boundary !== "clippingAncestors" && !a.isNav
    })), F = B(() => [
      a.split ? a.splitClass : a.toggleClass,
      {
        "nav-link": a.isNav,
        "dropdown-toggle": !a.split,
        "dropdown-toggle-no-caret": a.noCaret && !a.split,
        show: a.split ? void 0 : n.value
      }
    ]), Q = () => {
      le();
    }, W = (N) => {
      a.split ? o("click", N) : Q();
    };
    yo(
      u,
      () => {
        n.value && (a.autoClose === !0 || a.autoClose === "outside") && le();
      },
      { ignore: [d, p] }
    );
    const L = () => {
      n.value && (a.autoClose === !0 || a.autoClose === "inside") && le();
    }, J = () => {
      n.value && le();
    }, R = () => {
      n.value || le();
    }, le = () => {
      var E;
      o("toggle");
      const N = n.value, S = new Bt(N ? "hide" : "show");
      if (o(N ? "hide" : "show", S), S.defaultPrevented) {
        o(N ? "hide-prevented" : "show-prevented");
        return;
      }
      n.value = !N, o(N ? "hidden" : "shown"), (E = f.value) == null || E.dispatchEvent(new Event("forceHide"));
    };
    return ue(n, () => {
      C();
    }), e({
      hide: J,
      show: R,
      toggle: le
    }), tt(No, {
      id: r,
      show: R,
      hide: J,
      toggle: le,
      visible: $(() => n.value),
      isNav: $(() => a.isNav)
    }), (N, S) => (b(), V("div", {
      ref_key: "wrapper",
      ref: f,
      class: D([_.value, "btn-group"])
    }, [
      ve(vt, {
        id: O(r),
        ref_key: "splitButton",
        ref: p,
        variant: N.splitVariant || N.variant,
        size: N.size,
        class: D(F.value),
        disabled: a.splitDisabled || N.disabled,
        type: N.splitButtonType,
        "aria-label": N.ariaLabel,
        "aria-expanded": a.split ? void 0 : n.value,
        "aria-haspopup": a.split ? void 0 : "menu",
        href: a.split ? N.splitHref : void 0,
        to: a.split && N.splitTo ? N.splitTo : void 0,
        onClick: W
      }, {
        default: P(() => [
          T(N.$slots, "button-content", {}, () => [
            se(Y(N.text), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
      a.split ? (b(), I(vt, {
        key: 0,
        ref_key: "button",
        ref: d,
        variant: N.variant,
        size: N.size,
        disabled: N.disabled,
        class: D([[N.toggleClass, { show: n.value }], "dropdown-toggle-split dropdown-toggle"]),
        "aria-expanded": n.value,
        "aria-haspopup": "menu",
        onClick: Q
      }, {
        default: P(() => [
          Z("span", Hi, [
            T(N.$slots, "toggle-text", {}, () => [
              se(Y(N.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : ae("", !0),
      (b(), I(ht, {
        to: N.teleportTo,
        disabled: !N.teleportTo || N.teleportDisabled
      }, [
        !a.lazy || n.value ? ut((b(), V("ul", {
          key: 0,
          ref_key: "floating",
          ref: u,
          style: Ee([O(w), h.value]),
          class: D(["dropdown-menu overflow-auto", [N.menuClass, { show: n.value }]]),
          "aria-labelledby": O(r),
          role: N.role,
          onClick: L
        }, [
          T(N.$slots, "default", {
            hide: J,
            show: R
          })
        ], 14, Ri)), [
          [xt, a.lazy || n.value]
        ]) : ae("", !0)
      ], 8, ["to", "disabled"]))
    ], 2));
  }
}), Mi = { role: "presentation" }, xi = /* @__PURE__ */ H({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(t) {
    return (e, l) => (b(), V("li", Mi, [
      (b(), I(re(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), Di = { role: "presentation" }, ji = /* @__PURE__ */ H({
  __name: "BDropdownForm",
  setup(t) {
    return (e, l) => (b(), V("li", Di, [
      Z("form", X({ class: "dropdown-item-text" }, e.$attrs), [
        T(e.$slots, "default")
      ], 16)
    ]));
  }
}), qi = { role: "presentation" }, Wi = ["id", "aria-describedby"], Gi = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null },
    id: { default: void 0 }
  },
  setup(t) {
    const e = t, l = $(() => e.id ? `${e.id}_group_dd_header` : void 0), a = $(() => e.headerTag === "header" ? void 0 : "heading"), o = B(() => [
      e.headerClass,
      {
        [`text-${e.headerVariant}`]: e.headerVariant !== null
      }
    ]);
    return (r, n) => (b(), V("li", qi, [
      (b(), I(re(r.headerTag), {
        id: l.value,
        class: D(["dropdown-header", o.value]),
        role: a.value
      }, {
        default: P(() => [
          T(r.$slots, "header", {}, () => [
            se(Y(r.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      Z("ul", X({
        id: r.id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": r.ariaDescribedby || l.value
      }), [
        T(r.$slots, "default")
      ], 16, Wi)
    ]));
  }
}), Ui = { class: "dropdown-header" }, Xi = /* @__PURE__ */ H({
  __name: "BDropdownHeader",
  setup(t) {
    return (e, l) => (b(), V("li", null, [
      Z("h6", Ui, [
        T(e.$slots, "default")
      ])
    ]));
  }
}), Ki = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    wrapperAttrs: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, { class: o, ...r } = Mt(), { computedLink: n, computedLinkProps: s } = wt(l), i = B(() => [
      l.linkClass,
      {
        active: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), u = $(() => n.value ? lt : l.href ? "a" : "button"), d = Ve(Ka, null), p = Ve(No, null), f = Ve(Ya, null), m = (y) => {
      var c, g, v;
      a("click", y), f !== null && ((c = f == null ? void 0 : f.autoClose) == null ? void 0 : c.value) === !0 && ((g = d == null ? void 0 : d.hide) == null || g.call(d)), (v = p == null ? void 0 : p.hide) == null || v.call(p);
    };
    return (y, c) => (b(), V("li", X({
      role: "presentation",
      class: O(o)
    }, y.wrapperAttrs), [
      (b(), I(re(u.value), X({
        class: ["dropdown-item", i.value],
        disabled: l.disabled,
        "aria-disabled": l.disabled ? !0 : null,
        "aria-current": l.active ? !0 : null,
        href: u.value === "a" ? y.href : null,
        rel: y.rel,
        role: "menuitem",
        type: u.value === "button" ? "button" : null,
        target: y.target
      }, { ...O(s), ...r }, { onClick: m }), {
        default: P(() => [
          T(y.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ], 16));
  }
}), Yi = { role: "presentation" }, Ji = ["disabled"], Zi = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    active: { type: Boolean, default: !1 },
    activeClass: { default: "active" },
    buttonClass: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = B(() => [
      l.buttonClass,
      {
        [l.activeClass]: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), r = (n) => {
      a("click", n);
    };
    return (n, s) => (b(), V("li", Yi, [
      Z("button", {
        role: "menu",
        type: "button",
        class: D(["dropdown-item", o.value]),
        disabled: l.disabled,
        onClick: r
      }, [
        T(n.$slots, "default")
      ], 10, Ji)
    ]));
  }
}), Qi = { role: "presentation" }, eu = /* @__PURE__ */ H({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(t) {
    return (e, l) => (b(), V("li", Qi, [
      Z("span", X({ class: "dropdown-item-text" }, e.$attrs), [
        T(e.$slots, "default", {}, () => [
          se(Y(e.text), 1)
        ])
      ], 16)
    ]));
  }
}), tu = ["id", "novalidate"], cn = /* @__PURE__ */ H({
  __name: "BForm",
  props: {
    floating: { type: Boolean, default: !1 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: !1 },
    validated: { type: Boolean, default: !1 }
  },
  emits: ["submit"],
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = x(null), n = B(() => ({
      "form-floating": a.floating,
      "was-validated": a.validated
    })), s = (i) => {
      o("submit", i);
    };
    return e({
      element: r
    }), (i, u) => (b(), V("form", {
      id: i.id,
      ref_key: "element",
      ref: r,
      novalidate: a.novalidate,
      class: D(n.value),
      onSubmit: ft(s, ["prevent"])
    }, [
      T(i.$slots, "default")
    ], 42, tu));
  }
}), au = { class: "form-floating" }, lu = ["for"], ou = /* @__PURE__ */ H({
  __name: "BFormFloatingLabel",
  props: {
    label: { default: void 0 },
    labelFor: { default: void 0 },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), V("div", au, [
      T(e.$slots, "default", {}, () => [
        se(Y(e.text), 1)
      ]),
      Z("label", { for: e.labelFor }, [
        T(e.$slots, "label", {}, () => [
          se(Y(e.label), 1)
        ])
      ], 8, lu)
    ]));
  }
}), _a = /* @__PURE__ */ H({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = $(() => e.forceShow === !0 || e.state === !1), a = B(() => ({
      "d-block": l.value,
      "invalid-feedback": !e.tooltip,
      "invalid-tooltip": e.tooltip
    }));
    return (o, r) => (b(), I(re(o.tag), {
      id: o.id,
      role: o.role,
      "aria-live": o.ariaLive,
      "aria-atomic": o.ariaLive ? !0 : void 0,
      class: D(a.value)
    }, {
      default: P(() => [
        T(o.$slots, "default", {}, () => [
          se(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Qt = /* @__PURE__ */ H({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "row d-flex flex-wrap" }, {
      default: P(() => [
        T(e.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Aa = /* @__PURE__ */ H({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null,
      "form-text": !e.inline
    }));
    return (a, o) => (b(), I(re(a.tag), {
      id: a.id,
      class: D(l.value)
    }, {
      default: P(() => [
        T(a.$slots, "default", {}, () => [
          se(Y(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Oa = /* @__PURE__ */ H({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = $(() => e.forceShow === !0 || e.state === !0), a = B(() => ({
      "d-block": l.value,
      "valid-feedback": !e.tooltip,
      "valid-tooltip": e.tooltip
    }));
    return (o, r) => (b(), I(re(o.tag), {
      id: o.id,
      role: o.role,
      "aria-live": o.ariaLive,
      "aria-atomic": o.ariaLive ? !0 : void 0,
      class: D(a.value)
    }, {
      default: P(() => [
        T(o.$slots, "default", {}, () => [
          se(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), fn = H({
  name: "ComponentOrEmpty",
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(t, { slots: e, attrs: l }) {
    return () => {
      var a, o, r;
      return t.skip ? (a = e.default) == null ? void 0 : a.call(e) : t.tag === "Teleport" ? Ne(ht, { to: t.to }, [(o = e.default) == null ? void 0 : o.call(e)]) : Ne(t.tag, { ...l }, [(r = e.default) == null ? void 0 : r.call(e)]);
    };
  }
}), nu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "true-value", "false-value", "indeterminate"], su = ["for"], vn = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    indeterminate: { type: Boolean },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [String, Boolean, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: void 0 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    switch: { type: Boolean, default: !1 },
    uncheckedValue: { type: [String, Boolean, Object, Number, null], default: !1 },
    value: { type: [String, Boolean, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [String, Boolean], default: void 0 },
    modelModifiers: {},
    indeterminate: { type: Boolean, default: !1 },
    indeterminateModifiers: {}
  }),
  emits: ["update:modelValue", "update:indeterminate"],
  setup(t, { expose: e }) {
    const l = t, a = Fe(), o = he(t, "modelValue"), r = he(t, "indeterminate"), n = Be(() => l.id, "form-check"), s = Ve(Ao, null), i = x(null), { focused: u } = Pe(i, {
      initialValue: l.autofocus
    }), d = $(() => !Ae(a.default)), p = B({
      get: () => (s == null ? void 0 : s.modelValue.value) ?? o.value,
      set: (h) => {
        if (h !== void 0) {
          if (r.value = !1, s !== null && Array.isArray(h)) {
            s.modelValue.value = h;
            return;
          }
          o.value = h;
        }
      }
    }), f = $(
      () => !!(l.name ?? (s == null ? void 0 : s.name.value)) && (l.required || (s == null ? void 0 : s.required.value))
    ), m = $(() => l.buttonGroup || ((s == null ? void 0 : s.buttons.value) ?? !1)), y = B(() => ({
      plain: l.plain || ((s == null ? void 0 : s.plain.value) ?? !1),
      button: l.button || ((s == null ? void 0 : s.buttons.value) ?? !1),
      inline: l.inline || ((s == null ? void 0 : s.inline.value) ?? !1),
      reverse: l.reverse || ((s == null ? void 0 : s.reverse.value) ?? !1),
      switch: l.switch || ((s == null ? void 0 : s.switch.value) ?? !1),
      state: l.state || (s == null ? void 0 : s.state.value),
      size: l.size ?? (s == null ? void 0 : s.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (s == null ? void 0 : s.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: d.value
    })), c = Mo(y), g = xo(y), v = Do(y);
    return e({
      blur: () => {
        u.value = !1;
      },
      element: i,
      focus: () => {
        u.value = !0;
      }
    }), (h, k) => (b(), I(fn, {
      skip: m.value,
      class: D(O(c))
    }, {
      default: P(() => {
        var C, w, _;
        return [
          ut(Z("input", X({ id: O(n) }, h.$attrs, {
            ref_key: "input",
            ref: i,
            "onUpdate:modelValue": k[0] || (k[0] = (F) => p.value = F),
            class: O(g),
            type: "checkbox",
            disabled: l.disabled || ((C = O(s)) == null ? void 0 : C.disabled.value),
            required: f.value || void 0,
            name: h.name || ((w = O(s)) == null ? void 0 : w.name.value),
            form: h.form || ((_ = O(s)) == null ? void 0 : _.form.value),
            "aria-label": h.ariaLabel,
            "aria-labelledby": h.ariaLabelledby,
            "aria-required": f.value || void 0,
            value: h.value,
            "true-value": h.value,
            "false-value": h.uncheckedValue,
            indeterminate: l.indeterminate
          }), null, 16, nu), [
            [Nn, p.value]
          ]),
          d.value || l.plain === !1 ? (b(), V("label", {
            key: 0,
            for: O(n),
            class: D(O(v))
          }, [
            T(h.$slots, "default")
          ], 10, su)) : ae("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), ru = ["id"], iu = ["innerHTML"], uu = /* @__PURE__ */ H({
  __name: "BFormCheckboxGroup",
  props: /* @__PURE__ */ pe({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: {},
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    switches: { type: Boolean, default: !1 },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = he(t, "modelValue"), o = Be(() => l.id, "checkbox"), r = Be(() => l.name, "checkbox"), n = x(null), { focused: s } = Pe(n, {
      initialValue: l.autofocus
    });
    tt(Ao, {
      modelValue: a,
      switch: $(() => l.switches),
      buttonVariant: $(() => l.buttonVariant),
      form: $(() => l.form),
      name: r,
      state: $(() => l.state),
      plain: $(() => l.plain),
      size: $(() => l.size),
      inline: $(() => !l.stacked),
      reverse: $(() => l.reverse),
      required: $(() => l.required),
      buttons: $(() => l.buttons),
      disabled: $(() => l.disabled)
    });
    const i = B(
      () => l.options.map(
        (f, m) => typeof f == "string" || typeof f == "number" ? {
          props: {
            value: f,
            disabled: l.disabled
          },
          text: f.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${m}`)
        } : {
          props: {
            value: f[l.valueField],
            disabled: f[l.disabledField],
            ...f.props ? f.props : {}
          },
          text: f[l.textField],
          html: f[l.htmlField],
          self: Symbol(`checkboxGroupOptionItem${m}`)
        }
      )
    ), u = B(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), d = jo(u), p = qo(u);
    return e({
      blur: () => {
        s.value = !1;
      },
      focus: () => {
        s.value = !0;
      }
    }), (f, m) => (b(), V("div", X(O(d), {
      id: O(o),
      ref_key: "element",
      ref: n,
      role: "group",
      class: [O(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      T(f.$slots, "first"),
      (b(!0), V(de, null, Ce(i.value, (y) => (b(), I(vn, X({
        key: y.self
      }, y.props), {
        default: P(() => [
          y.html ? (b(), V("span", {
            key: 0,
            innerHTML: y.html
          }, null, 8, iu)) : (b(), V(de, { key: 1 }, [
            se(Y(y.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040))), 128)),
      T(f.$slots, "default")
    ], 16, ru));
  }
}), du = ["for"], cu = ["for"], fu = { class: "input-group form-input-file" }, vu = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-label", "aria-labelledby", "aria-required", "directory", "webkitdirectory"], pu = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    accept: { default: "" },
    autofocus: { type: Boolean, default: !1 },
    browserText: { default: "Choose" },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    label: { default: "" },
    labelClass: { default: void 0 },
    modelValue: {},
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    noDrop: { type: Boolean, default: !1 },
    noTraverse: { type: Boolean, default: !1 },
    placement: { default: "start" },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = Fe(), a = t, o = he(t, "modelValue"), r = Be(() => a.id), n = Ct(() => a.state), s = x(null), { focused: i } = Pe(s, { initialValue: a.autofocus }), u = $(() => !Ae(l.label)), d = $(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), p = B(() => [
      n.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0
      }
    ]), f = () => {
      var h, k;
      const v = ((h = s.value) == null ? void 0 : h.files) === null || ((k = s.value) == null ? void 0 : k.files) === void 0 ? null : [...s.value.files];
      o.value = v === null ? null : a.multiple === !0 ? v : v[0];
    }, m = (v) => {
      a.noDrop === !0 && v.preventDefault();
    }, y = () => {
      o.value = null;
    };
    ue(o, (v) => {
      v === null && s.value !== null && (s.value.value = "");
    }), e({
      blur: () => {
        i.value = !1;
      },
      element: s,
      focus: () => {
        i.value = !0;
      },
      reset: y
    });
    const [c, g] = zt();
    return (v, h) => (b(), V(de, null, [
      ve(O(c), null, {
        default: P(() => [
          Z("label", {
            class: "input-group-text",
            for: O(r)
          }, Y(v.browserText), 9, du)
        ]),
        _: 1
      }),
      u.value || v.label ? (b(), V("label", {
        key: 0,
        class: D(["form-label", v.labelClass]),
        for: O(r)
      }, [
        T(v.$slots, "label", {}, () => [
          se(Y(v.label), 1)
        ], !0)
      ], 10, cu)) : ae("", !0),
      Z("div", fu, [
        v.placement === "start" ? (b(), I(O(g), { key: 0 })) : ae("", !0),
        Z("input", X({ id: O(r) }, v.$attrs, {
          ref_key: "input",
          ref: s,
          type: "file",
          class: ["form-control", p.value],
          form: v.form,
          name: v.name,
          multiple: a.multiple,
          disabled: a.disabled,
          capture: a.capture,
          accept: d.value || void 0,
          required: a.required || void 0,
          "aria-label": v.ariaLabel,
          "aria-labelledby": v.ariaLabelledby,
          "aria-required": a.required || void 0,
          directory: a.directory,
          webkitdirectory: a.directory,
          onChange: f,
          onDrop: m
        }), null, 16, vu),
        v.placement === "end" ? (b(), I(O(g), { key: 1 })) : ae("", !0)
      ])
    ], 64));
  }
}), mu = /* @__PURE__ */ qt(pu, [["__scopeId", "data-v-1eb930f5"]]), pn = ["input", "select", "textarea"], bu = pn.map((t) => `${t}:not([disabled])`).join(), yu = [...pn, "a", "button", "label"], gu = "label", hu = "invalid-feedback", Bu = "valid-feedback", wu = "description", Cu = "default", ku = H({
  components: { BCol: Lt, BFormInvalidFeedback: _a, BFormRow: Qt, BFormText: Aa, BFormValidFeedback: Oa },
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: Boolean, default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: Boolean, default: !1 },
    state: { type: Boolean, default: null },
    tooltip: { type: Boolean, default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: Boolean, default: !1 },
    floating: { type: Boolean, default: !1 }
  },
  setup(t) {
    const l = ["xs", "sm", "md", "lg", "xl"], a = (y, c) => l.reduce((g, v) => {
      const h = wl(v === "xs" ? "" : v, `${c}Align`), k = y[h] || null;
      return k && (v === "xs" ? g.push(`text-${k}`) : g.push(`text-${v}-${k}`)), g;
    }, []), o = (y, c) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      l.reduce((g, v) => {
        const h = wl(v === "xs" ? "" : v, `${c}Cols`);
        let k = y[h];
        if (k = k === "" ? !0 : k || !1, typeof k != "boolean" && k !== "auto") {
          const C = Number.parseInt(k);
          k = Number.isNaN(C) ? 0 : C, k = k > 0 ? k : !1;
        }
        return k && (v === "xs" ? g[typeof k == "boolean" ? "col" : "cols"] = k : g[v || (typeof k == "boolean" ? "col" : "cols")] = k), g;
      }, {})
    ), r = x(null), n = (y, c = null) => {
      if (za && t.labelFor && r.value !== null) {
        const g = r.value.querySelector(`#${CSS.escape(t.labelFor)}`);
        if (g) {
          const v = "aria-describedby", h = (y || "").split(Jt), k = (c || "").split(Jt), C = (g.getAttribute(v) || "").split(Jt).filter((w) => !k.includes(w)).concat(h).filter((w, _, F) => F.indexOf(w) === _).filter((w) => w).join(" ").trim();
          C ? g.setAttribute(v, C) : g.removeAttribute(v);
        }
      }
    }, s = B(() => o(t, "content")), i = B(() => a(t, "label")), u = B(() => o(t, "label")), d = B(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(s.value).length > 0 || Object.keys(u.value).length > 0
      )
    ), p = Ct(() => t.state), f = ua(
      () => t.ariaInvalid,
      () => t.state
    );
    return ue(
      () => null,
      (y, c) => {
        y !== c && n(y, c);
      }
    ), Xe(() => {
      _e(() => {
        n(null);
      });
    }), {
      ariaDescribedby: null,
      computedAriaInvalid: f,
      contentColProps: s,
      isHorizontal: d,
      labelAlignClasses: i,
      labelColProps: u,
      onLegendClick: (y) => {
        if (t.labelFor || r.value === null)
          return;
        const { target: c } = y, g = c ? c.tagName : "";
        if (yu.indexOf(g) !== -1)
          return;
        const v = [...r.value.querySelectorAll(bu)].filter(Fn), [h] = v;
        v.length === 1 && h instanceof HTMLElement && Ln(h);
      },
      stateClass: p
    };
  },
  render() {
    const t = this.$props, e = this.$slots, l = Be(), a = !t.labelFor;
    let o = null;
    const r = Et(gu, {}, e) || t.label, n = r ? Be(void 0, "_BV_label_").value : null;
    if (r || this.isHorizontal) {
      const C = a ? "legend" : "label";
      if (t.labelSrOnly)
        r && (o = Ne(
          C,
          {
            class: "visually-hidden",
            id: n,
            for: t.labelFor || null
          },
          r
        )), this.isHorizontal ? o = Ne(Lt, this.labelColProps, { default: () => o }) : o = Ne("div", {}, [o]);
      else {
        const w = {
          onClick: a ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? C : null,
          id: n,
          for: t.labelFor || null,
          tabIndex: a ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": a,
              "col-form-label": this.isHorizontal || a,
              "pt-0": !this.isHorizontal && a,
              "d-block": !this.isHorizontal && !a,
              [`col-form-label-${t.labelSize}`]: !!t.labelSize
            },
            this.labelAlignClasses,
            t.labelClass
          ]
        };
        this.isHorizontal ? o = Ne(Lt, w, { default: () => r }) : o = Ne(C, w, r);
      }
    }
    let s = null;
    const i = Et(hu, {}, e) || this.invalidFeedback, u = i ? Be(void 0, "_BV_feedback_invalid_").value : void 0;
    i && (s = Ne(
      _a,
      {
        ariaLive: t.feedbackAriaLive,
        id: u,
        state: t.state,
        tooltip: t.tooltip
      },
      { default: () => i }
    ));
    let d = null;
    const p = Et(Bu, {}, e) || this.validFeedback, f = p ? Be(void 0, "_BV_feedback_valid_").value : void 0;
    p && (d = Ne(
      Oa,
      {
        ariaLive: t.feedbackAriaLive,
        id: f,
        state: t.state,
        tooltip: t.tooltip
      },
      { default: () => p }
      // validFeedbackContent
    ));
    let m = null;
    const y = Et(wu, {}, e) || this.description, c = y ? Be(void 0, "_BV_description_").value : void 0;
    y && (m = Ne(
      Aa,
      {
        id: c
      },
      { default: () => y }
    ));
    const g = this.ariaDescribedby = [
      c,
      t.state === !1 ? u : null,
      t.state === !0 ? f : null
    ].filter((C) => C).join(" ") || null, v = [
      Et(Cu, { ariaDescribedby: g, descriptionId: c, id: l, labelId: n }, e) || "",
      s,
      d,
      m
    ];
    !this.isHorizontal && t.floating && v.push(o);
    let h = Ne(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && t.floating
          }
        ]
      },
      v
    );
    this.isHorizontal && (h = Ne(Lt, { ref: "content", ...this.contentColProps }, { default: () => v }));
    const k = {
      class: [
        this.stateClass,
        {
          "was-validated": t.validated
        }
      ],
      id: Be(() => t.id).value,
      disabled: a ? t.disabled : null,
      role: a ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": a && this.isHorizontal ? n : null
    };
    return this.isHorizontal && !a ? Ne(Qt, k, { default: () => [o, h] }) : Ne(
      a ? "fieldset" : "div",
      k,
      this.isHorizontal && a ? [Ne(Qt, null, { default: () => [o, h] })] : this.isHorizontal || !t.floating ? [o, h] : [h]
    );
  }
}), $u = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Tu = /* @__PURE__ */ H({
  __name: "BFormInput",
  props: {
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    trim: { type: Boolean, default: !1 },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  },
  emits: ["update:modelValue"],
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, { input: r, computedId: n, computedAriaInvalid: s, onInput: i, onChange: u, onBlur: d, focus: p, blur: f } = Wo(a, o), m = Ct(() => a.state), y = x(!1), c = B(() => {
      const g = a.type === "range", v = a.type === "color";
      return [
        m.value,
        {
          "form-control-highlighted": y.value,
          "form-range": g,
          "form-control": v || !a.plaintext && !g,
          "form-control-color": v,
          "form-control-plaintext": a.plaintext && !g && !v,
          [`form-control-${a.size}`]: !!a.size
        }
      ];
    });
    return e({
      blur: f,
      element: r,
      focus: p
    }), (g, v) => (b(), V("input", {
      id: O(n),
      ref_key: "input",
      ref: r,
      value: g.modelValue,
      class: D(c.value),
      name: g.name || void 0,
      form: g.form || void 0,
      type: g.type,
      disabled: a.disabled,
      placeholder: g.placeholder,
      required: a.required || void 0,
      autocomplete: g.autocomplete || void 0,
      readonly: a.readonly || a.plaintext,
      min: g.min,
      max: g.max,
      step: g.step,
      list: g.type !== "password" ? g.list : void 0,
      "aria-required": a.required || void 0,
      "aria-invalid": O(s),
      onInput: v[0] || (v[0] = (h) => O(i)(h)),
      onChange: v[1] || (v[1] = (h) => O(u)(h)),
      onBlur: v[2] || (v[2] = (h) => O(d)(h))
    }, null, 42, $u));
  }
}), Su = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], Vu = ["for"], mn = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, String, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    value: { type: [Boolean, String, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Boolean, String], default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = Fe(), o = he(t, "modelValue"), r = Be(() => l.id, "form-check"), n = Ve(Oo, null), s = x(null), { focused: i } = Pe(s, {
      initialValue: l.autofocus
    }), u = $(() => !Ae(a.default)), d = B({
      get: () => (n == null ? void 0 : n.modelValue.value) ?? o.value,
      set: (v) => {
        if (v !== void 0) {
          if (n !== null) {
            n.modelValue.value = v;
            return;
          }
          o.value = v;
        }
      }
    }), p = $(
      () => !!(l.name ?? (n == null ? void 0 : n.name.value)) && (l.required || (n == null ? void 0 : n.required.value))
    ), f = $(() => l.buttonGroup || ((n == null ? void 0 : n.buttons.value) ?? !1)), m = B(() => ({
      plain: l.plain || ((n == null ? void 0 : n.plain.value) ?? !1),
      button: l.button || ((n == null ? void 0 : n.buttons.value) ?? !1),
      inline: l.inline || ((n == null ? void 0 : n.inline.value) ?? !1),
      state: l.state || (n == null ? void 0 : n.state.value),
      reverse: l.reverse || ((n == null ? void 0 : n.reverse.value) ?? !1),
      size: l.size ?? (n == null ? void 0 : n.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (n == null ? void 0 : n.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: u.value
    })), y = Mo(m), c = xo(m), g = Do(m);
    return e({
      blur: () => {
        i.value = !1;
      },
      element: s,
      focus: () => {
        i.value = !0;
      }
    }), (v, h) => (b(), I(fn, {
      skip: f.value,
      class: D(O(y))
    }, {
      default: P(() => {
        var k, C, w;
        return [
          ut(Z("input", X({ id: O(r) }, v.$attrs, {
            ref_key: "input",
            ref: s,
            "onUpdate:modelValue": h[0] || (h[0] = (_) => d.value = _),
            class: O(c),
            type: "radio",
            disabled: l.disabled || ((k = O(n)) == null ? void 0 : k.disabled.value),
            required: p.value || void 0,
            name: v.name || ((C = O(n)) == null ? void 0 : C.name.value),
            form: v.form || ((w = O(n)) == null ? void 0 : w.form.value),
            "aria-label": v.ariaLabel,
            "aria-labelledby": v.ariaLabelledby,
            value: v.value,
            "aria-required": p.value || void 0
          }), null, 16, Su), [
            [In, d.value]
          ]),
          u.value || l.plain === !1 ? (b(), V("label", {
            key: 0,
            for: O(r),
            class: D(O(g))
          }, [
            T(v.$slots, "default")
          ], 10, Vu)) : ae("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), _u = ["id"], Au = ["innerHTML"], Ou = /* @__PURE__ */ H({
  __name: "BFormRadioGroup",
  props: /* @__PURE__ */ pe({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { type: [Boolean, String, Object, Number, null] },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: { type: [Boolean, String], default: null },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = he(t, "modelValue"), o = Be(() => l.id, "radio"), r = Be(() => l.name, "checkbox"), n = x(null), { focused: s } = Pe(n, {
      initialValue: l.autofocus
    });
    tt(Oo, {
      modelValue: a,
      buttonVariant: $(() => l.buttonVariant),
      form: $(() => l.form),
      name: r,
      buttons: $(() => l.buttons),
      state: $(() => l.state),
      plain: $(() => l.plain),
      size: $(() => l.size),
      inline: $(() => !l.stacked),
      reverse: $(() => l.reverse),
      required: $(() => l.required),
      disabled: $(() => l.disabled)
    });
    const i = B(
      () => l.options.map(
        (f, m) => typeof f == "string" || typeof f == "number" ? {
          value: f,
          disabled: l.disabled,
          text: f.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${m}`)
        } : {
          value: f[l.valueField],
          disabled: f[l.disabledField],
          ...f.props ? f.props : {},
          text: f[l.textField],
          html: f[l.htmlField],
          self: Symbol(`radioGroupOptionItem${m}`)
        }
      )
    ), u = B(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), d = jo(u), p = qo(u);
    return e({
      blur: () => {
        s.value = !1;
      },
      focus: () => {
        s.value = !0;
      }
    }), (f, m) => (b(), V("div", X(O(d), {
      id: O(o),
      ref_key: "element",
      ref: n,
      role: "radiogroup",
      class: [O(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      T(f.$slots, "first"),
      (b(!0), V(de, null, Ce(i.value, (y) => (b(), I(mn, {
        key: y.self,
        disabled: y.disabled,
        value: y.value
      }, {
        default: P(() => [
          y.html ? (b(), V("span", {
            key: 0,
            innerHTML: y.html
          }, null, 8, Au)) : (b(), V(de, { key: 1 }, [
            se(Y(y.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["disabled", "value"]))), 128)),
      T(f.$slots, "default")
    ], 16, _u));
  }
}), Nu = ["value", "disabled"], al = /* @__PURE__ */ H({
  __name: "BFormSelectOption",
  props: {
    disabled: { type: Boolean, default: !1 },
    value: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return (l, a) => (b(), V("option", {
      value: l.value,
      disabled: e.disabled
    }, [
      T(l.$slots, "default")
    ], 8, Nu));
  }
}), Iu = ["label"], Pu = ["innerHTML"], bn = /* @__PURE__ */ H({
  __name: "BFormSelectOptionGroup",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    label: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(t) {
    const e = t, { normalizedOptions: l } = Go(() => e.options, e), a = B(() => l.value);
    return (o, r) => (b(), V("optgroup", { label: o.label }, [
      T(o.$slots, "first"),
      (b(!0), V(de, null, Ce(a.value, (n, s) => (b(), I(al, X({
        key: s,
        disabled: n.disabled,
        value: n.value
      }, o.$attrs), {
        default: P(() => [
          n.html ? (b(), V("span", {
            key: 0,
            innerHTML: n.html
          }, null, 8, Pu)) : (b(), V(de, { key: 1 }, [
            se(Y(n.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040, ["disabled", "value"]))), 128)),
      T(o.$slots, "default")
    ], 8, Iu));
  }
}), Eu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Lu = ["innerHTML"], Fu = /* @__PURE__ */ H({
  __name: "BFormSelect",
  props: /* @__PURE__ */ pe({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    modelValue: { type: [Boolean, String, Object, Number, null] },
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" }
  }, {
    modelValue: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = he(t, "modelValue"), o = Be(() => l.id, "input"), r = be(() => l.selectSize), n = Ct(() => l.state), s = x(null), { focused: i } = Pe(s, {
      initialValue: l.autofocus
    }), u = B(() => [
      n.value,
      {
        "form-control": l.plain,
        [`form-control-${l.size}`]: l.size !== "md" && l.plain,
        "form-select": !l.plain,
        [`form-select-${l.size}`]: l.size !== "md" && !l.plain
      }
    ]), d = $(
      () => r.value || l.plain ? r.value : void 0
    ), p = ua(
      () => l.ariaInvalid,
      () => l.state
    ), { normalizedOptions: f, isComplex: m } = Go(() => l.options, l), y = B(
      () => f.value
    ), c = B({
      get: () => a.value,
      set: (g) => {
        a.value = g;
      }
    });
    return e({
      blur: () => {
        i.value = !1;
      },
      element: s,
      focus: () => {
        i.value = !0;
      }
    }), (g, v) => ut((b(), V("select", {
      id: O(o),
      ref_key: "input",
      ref: s,
      "onUpdate:modelValue": v[0] || (v[0] = (h) => c.value = h),
      class: D(u.value),
      name: g.name,
      form: g.form || void 0,
      multiple: l.multiple || void 0,
      size: d.value,
      disabled: l.disabled,
      required: l.required || void 0,
      "aria-required": l.required || void 0,
      "aria-invalid": O(p)
    }, [
      T(g.$slots, "first"),
      (b(!0), V(de, null, Ce(y.value, (h, k) => (b(), V(de, { key: k }, [
        O(m)(h) ? (b(), I(bn, {
          key: 0,
          label: h.label,
          options: h.options,
          "value-field": g.valueField,
          "text-field": g.textField,
          "html-field": g.htmlField,
          "disabled-field": g.disabledField
        }, null, 8, ["label", "options", "value-field", "text-field", "html-field", "disabled-field"])) : (b(), I(al, {
          key: 1,
          value: h.value,
          disabled: h.disabled
        }, {
          default: P(() => [
            h.html ? (b(), V("span", {
              key: 0,
              innerHTML: h.html
            }, null, 8, Lu)) : (b(), V(de, { key: 1 }, [
              se(Y(h.text), 1)
            ], 64))
          ]),
          _: 2
        }, 1032, ["value", "disabled"]))
      ], 64))), 128)),
      T(g.$slots, "default")
    ], 10, Eu)), [
      [Pn, c.value]
    ]);
  }
}), ha = "ArrowDown", _l = "End", Al = "Home", Ol = "PageDown", Nl = "PageUp", Ba = "ArrowUp", zu = ["lang", "tabindex", "title"], Hu = ["name", "form", "value"], Ru = ["id", "dir", "tabindex", "aria-label", "aria-invalid", "aria-required", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext"], He = {
  min: 1,
  max: 100,
  step: 1,
  repeatDelay: 500,
  repeatInterval: 100,
  repeatThreshold: 10,
  repeatMultiplier: 4
}, Mu = /* @__PURE__ */ H({
  __name: "BFormSpinbutton",
  props: /* @__PURE__ */ pe({
    ariaControls: { default: void 0 },
    ariaLabel: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatterFn: { type: Function, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    labelDecrement: { default: "Decrement" },
    labelIncrement: { default: "Increment" },
    locale: { default: void 0 },
    max: { default: He.max },
    min: { default: He.min },
    modelValue: {},
    name: { default: void 0 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: !1 },
    repeatDelay: { default: He.repeatDelay },
    repeatInterval: { default: He.repeatInterval },
    repeatStepMultiplier: { default: He.repeatMultiplier },
    repeatThreshold: { default: He.repeatThreshold },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    step: { default: He.step },
    vertical: { type: Boolean, default: !1 },
    wrap: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["change"], ["update:modelValue"]),
  setup(t, { emit: e }) {
    const l = [Ba, ha, Al, _l, Nl, Ol], a = t, o = e, r = he(t, "modelValue"), n = x(null), { focused: s } = Pe(n), i = Be(() => a.id, "spinbutton"), u = B(() => ({
      disabled: a.disabled,
      readonly: a.readonly,
      focus: s.value,
      "d-inline-flex": a.inline || a.vertical,
      "d-flex": !a.inline && !a.vertical,
      "align-items-stretch": !a.vertical,
      "flex-column": a.vertical,
      [`form-control-${a.size}`]: a.size !== void 0
    })), d = B(() => ({
      "d-flex": a.vertical,
      "align-self-center": !a.vertical,
      "align-items-center": a.vertical,
      "border-top": a.vertical,
      "border-bottom": a.vertical,
      "border-start": !a.vertical,
      "border-end": !a.vertical
    }));
    let p, f, m = !1;
    const y = be(() => a.step), c = $(
      () => Number.isNaN(y.value) ? He.step : y.value
    ), g = be(() => a.min), v = $(
      () => Number.isNaN(g.value) ? He.min : g.value
    ), h = be(() => a.max), k = $(() => {
      const z = c.value, oe = v.value;
      return Math.floor((h.value - oe) / z) * z + oe;
    }), C = be(() => a.repeatDelay, {
      nanToZero: !0,
      method: "parseInt"
    }), w = $(
      () => C.value > 0 ? C.value : He.repeatDelay
    ), _ = be(() => a.repeatInterval, {
      nanToZero: !0,
      method: "parseInt"
    }), F = $(
      () => _.value > 0 ? _.value : He.repeatInterval
    ), Q = be(() => a.repeatThreshold, {
      nanToZero: !0,
      method: "parseInt"
    }), W = $(
      () => Math.max(
        Number.isNaN(Q.value) ? He.repeatThreshold : Q.value,
        1
      )
    ), L = be(() => a.repeatStepMultiplier, {
      nanToZero: !0,
      method: "parseInt"
    }), J = $(
      () => Math.max(
        Number.isNaN(L.value) ? He.repeatMultiplier : L.value,
        1
      )
    ), R = $(() => {
      const z = c.value;
      return Math.floor(z) === z ? 0 : (z.toString().split(".")[1] || "").length;
    }), le = $(() => Math.pow(10, R.value || 0)), N = $(
      () => r.value === null ? "" : r.value.toFixed(R.value)
    ), { isRtl: S, locale: E } = Hr(), M = B(() => {
      const oe = [(a.locale ?? (E == null ? void 0 : E.value)) || "locale"];
      return new Intl.NumberFormat(oe).resolvedOptions().locale;
    }), j = () => new Intl.NumberFormat(M.value, {
      style: "decimal",
      useGrouping: !1,
      minimumIntegerDigits: 1,
      minimumFractionDigits: R.value,
      maximumFractionDigits: R.value,
      notation: "standard"
    }).format, A = $(() => a.formatterFn ?? j()), K = (z) => {
      let { value: oe } = r;
      if (!a.disabled && oe !== null) {
        const fe = c.value * z, ce = v.value, Oe = k.value, $e = le.value, { wrap: Te } = a;
        oe = Math.round((oe - ce) / fe) * fe + ce + fe, oe = Math.round(oe * $e) / $e, r.value = oe > Oe ? Te ? ce : Oe : oe < ce ? Te ? Oe : ce : oe;
      }
    }, G = (z = 1) => {
      if (r.value === null) {
        r.value = v.value;
        return;
      }
      K(1 * z);
    }, ie = (z = 1) => {
      if (r.value === null) {
        r.value = a.wrap ? k.value : v.value;
        return;
      }
      K(-1 * z);
    }, q = (z) => {
      z.preventDefault(), z.stopImmediatePropagation();
    };
    Re(
      l,
      (z) => {
        const { code: oe, altKey: fe, ctrlKey: ce, metaKey: Oe } = z;
        if (!(a.disabled || a.readonly || fe || ce || Oe) && (q(z), !m)) {
          if (ee(), [Ba, ha].includes(oe)) {
            if (m = !0, oe === Ba) {
              ne(z, G);
              return;
            }
            oe === ha && ne(z, ie);
            return;
          }
          if (oe === Nl) {
            G(J.value);
            return;
          }
          if (oe === Ol) {
            ie(J.value);
            return;
          }
          if (oe === Al) {
            r.value = v.value;
            return;
          }
          oe === _l && (r.value = k.value);
        }
      },
      { target: n, eventName: "keydown" }
    ), Re(
      l,
      (z) => {
        const { altKey: oe, ctrlKey: fe, metaKey: ce } = z;
        a.disabled || a.readonly || oe || fe || ce || (q(z), ee(), m = !1, o("change", r.value));
      },
      { target: n, eventName: "keyup" }
    );
    const ne = (z, oe) => {
      const { type: fe } = z || {};
      if (!a.disabled && !a.readonly) {
        if (ge(z) && fe === "mousedown" && z.button)
          return;
        ee(), oe(1);
        const ce = W.value, Oe = J.value, $e = w.value, Te = F.value;
        p = setTimeout(() => {
          let Ke = 0;
          f = setInterval(() => {
            oe(Ke < ce ? 1 : Oe), Ke++;
          }, Te);
        }, $e);
      }
    }, ge = (z) => z.type === "mouseup" || z.type === "mousedown", te = (z) => {
      ge(z) && z.type === "mouseup" && z.button || (q(z), ee(), ye(!1), o("change", r.value));
    }, ye = (z) => {
      try {
        sl(z, [document.body, "mouseup", te, !1]), sl(z, [document.body, "touchend", te, !1]);
      } catch {
      }
    }, ee = () => {
      clearTimeout(p), clearInterval(f), p = void 0, f = void 0;
    }, U = B(() => {
      const z = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-plus",
          viewBox: "0 0 16 16"
        },
        path: {
          d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
        }
      }, oe = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-dash",
          viewBox: "0 0 16 16"
        },
        path: { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" }
      }, fe = {
        class: [{ "py-0": !a.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
        tabindex: "-1",
        type: "button",
        disabled: a.disabled || a.readonly,
        "aria-disabled": a.disabled || a.readonly ? !0 : void 0,
        "aria-controls": i.value
      }, ce = {
        "aria-hidden": !0,
        scale: s.value ? 1.5 : 1.25
      }, Oe = (Ke, $n) => {
        !a.disabled && !a.readonly && (q(Ke), ye(!0), s.value = !0, ne(Ke, $n));
      }, $e = {
        button: {
          ...fe,
          "aria-label": a.labelIncrement || void 0,
          "aria-keyshortcuts": "ArrowUp"
        },
        svg: {
          ...ce,
          ...z.svg
        },
        path: {
          ...z.path
        },
        slot: {
          name: "increment"
        },
        handler: (Ke) => Oe(Ke, G)
      }, Te = {
        button: {
          ...fe,
          "aria-label": a.labelDecrement || void 0,
          "aria-keyshortcuts": "ArrowDown"
        },
        svg: {
          ...ce,
          ...oe.svg
        },
        path: {
          ...oe.path
        },
        slot: {
          name: "decrement"
        },
        handler: (Ke) => Oe(Ke, ie)
      };
      return {
        top: {
          ...a.vertical ? $e : Te
        },
        bottom: {
          ...a.vertical ? Te : $e
        }
      };
    });
    return (z, oe) => (b(), V("div", {
      ref_key: "element",
      ref: n,
      class: D(["b-form-spinbutton form-control", u.value]),
      role: "group",
      lang: M.value,
      tabindex: a.disabled ? void 0 : "-1",
      title: z.ariaLabel,
      onClick: oe[4] || (oe[4] = (fe) => s.value = !0)
    }, [
      T(z.$slots, U.value.top.slot.name, { hasFocus: O(s) }, () => [
        Z("button", X(U.value.top.button, {
          onMousedown: oe[0] || (oe[0] = //@ts-ignore
          (...fe) => U.value.top.handler && U.value.top.handler(...fe)),
          onTouchstart: oe[1] || (oe[1] = //@ts-ignore
          (...fe) => U.value.top.handler && U.value.top.handler(...fe))
        }), [
          (b(), V("svg", me(we(U.value.top.svg)), [
            Z("path", me(we(U.value.top.path)), null, 16)
          ], 16))
        ], 16)
      ]),
      z.name && !a.disabled ? (b(), V("input", {
        key: "hidden",
        type: "hidden",
        name: z.name,
        form: z.form,
        value: N.value
      }, null, 8, Hu)) : ae("", !0),
      Z("output", {
        id: O(i),
        key: "output",
        class: D(["flex-grow-1", d.value]),
        dir: O(S) ?? !1 ? "rtl" : "ltr",
        tabindex: a.disabled ? void 0 : "0",
        role: "spinbutton",
        "aria-live": "off",
        "aria-label": z.ariaLabel || void 0,
        "aria-invalid": a.state === !1 || !r.value !== null && a.required ? !0 : void 0,
        "aria-required": a.required ? !0 : void 0,
        "aria-valuemin": v.value,
        "aria-valuemax": k.value,
        "aria-valuenow": r.value !== null ? r.value : void 0,
        "aria-valuetext": r.value !== null ? A.value(r.value) : void 0
      }, [
        Z("bdi", null, Y((r.value !== null ? A.value(r.value) : z.placeholder) || ""), 1)
      ], 10, Ru),
      T(z.$slots, U.value.bottom.slot.name, { hasFocus: O(s) }, () => [
        Z("button", X(U.value.bottom.button, {
          onMousedown: oe[2] || (oe[2] = //@ts-ignore
          (...fe) => U.value.bottom.handler && U.value.bottom.handler(...fe)),
          onTouchstart: oe[3] || (oe[3] = //@ts-ignore
          (...fe) => U.value.bottom.handler && U.value.bottom.handler(...fe))
        }), [
          (b(), V("svg", me(we(U.value.bottom.svg)), [
            Z("path", me(we(U.value.bottom.path)), null, 16)
          ], 16))
        ], 16)
      ])
    ], 10, zu));
  }
}), xu = ["id"], yn = /* @__PURE__ */ H({
  __name: "BFormTag",
  props: {
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noRemove: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    title: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = Fe(), r = Be(() => l.id), n = B(
      () => {
        var u;
        return ((((u = o.default) == null ? void 0 : u.call(o, {})[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), s = $(() => `${r.value}taglabel__`), i = B(() => ({
      [`text-bg-${l.variant}`]: l.variant !== null,
      "rounded-pill": l.pill,
      disabled: l.disabled
    }));
    return (u, d) => (b(), I(re(u.tag), {
      id: O(r),
      title: n.value,
      class: D(["badge b-form-tag d-inline-flex align-items-center mw-100", i.value]),
      "aria-labelledby": s.value
    }, {
      default: P(() => [
        Z("span", {
          id: s.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          T(u.$slots, "default", {}, () => [
            se(Y(n.value), 1)
          ])
        ], 8, xu),
        !l.disabled && !l.noRemove ? (b(), I(Pt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": u.removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": s.value,
          "aria-controls": u.id,
          onClick: d[0] || (d[0] = (p) => a("remove", n.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : ae("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Du = ["id"], ju = ["id", "for", "aria-live"], qu = ["id", "aria-live"], Wu = ["id"], Gu = ["aria-controls"], Uu = {
  role: "group",
  class: "d-flex"
}, Xu = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], Ku = ["disabled"], Yu = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, Ju = {
  key: 0,
  class: "d-block invalid-feedback"
}, Zu = {
  key: 1,
  class: "form-text text-body-secondary"
}, Qu = {
  key: 2,
  class: "form-text text-body-secondary"
}, ed = ["name", "value"], td = /* @__PURE__ */ H({
  __name: "BFormTags",
  props: /* @__PURE__ */ pe({
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: Boolean, default: !1 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    form: { default: void 0 },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: {},
    name: { default: void 0 },
    noAddOnEnter: { type: Boolean, default: !1 },
    noOuterFocus: { type: Boolean, default: !1 },
    noTagRemove: { type: Boolean, default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    separator: { default: void 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    tagClass: { default: void 0 },
    tagPills: { type: Boolean, default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["blur", "focus", "focusin", "focusout", "tag-state"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "modelValue"), n = Be(), s = be(() => a.limit ?? NaN), i = Ct(() => a.state), u = x(null), { focused: d } = Pe(u, {
      initialValue: a.autofocus
    }), p = $(() => a.inputId || `${n.value}input__`), f = x([...r.value]), m = x(""), y = x(r.value.length > 0), c = x(""), g = x([]), v = x([]), h = x([]);
    Sa(r, f, {
      direction: "ltr",
      transform: {
        ltr: (A) => [...A]
      }
    });
    const k = B(() => [
      i.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: a.disabled,
        focus: d.value
      }
    ]), C = B(() => f.value.includes(m.value)), w = B(
      () => m.value === "" ? !1 : !a.tagValidator(m.value)
    ), _ = $(() => f.value.length === s.value), F = $(() => !w.value && !C.value), Q = B(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: M,
      disableAddButton: F.value,
      disabled: a.disabled,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: h.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: a.disabled,
        form: a.form,
        id: p,
        value: m
      },
      inputHandlers: {
        input: R,
        keydown: N,
        change: le
      },
      inputId: p,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: v.value,
      isDuplicate: C.value,
      isInvalid: w.value,
      isLimitReached: _.value,
      limitTagsText: a.limitTagsText,
      limit: s.value,
      noTagRemove: a.noTagRemove,
      placeholder: a.placeholder,
      removeTag: j,
      required: a.required,
      separator: a.separator,
      size: a.size,
      state: a.state,
      tagClass: a.tagClass,
      tagPills: a.tagPills,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: f.value
    })), W = (A) => {
      if (a.disabled) {
        A.target.blur();
        return;
      }
      o("focusin", A);
    }, L = (A) => {
      a.disabled || a.noOuterFocus || (d.value = !0, o("focus", A));
    }, J = (A) => {
      d.value = !1, o("blur", A);
    }, R = (A) => {
      var G, ie;
      const K = typeof A == "string" ? A : A.target.value;
      if (y.value = !1, (G = a.separator) != null && G.includes(K.charAt(0)) && K.length > 0) {
        u.value && (u.value.value = "");
        return;
      }
      if (m.value = K, (ie = a.separator) != null && ie.includes(K.charAt(K.length - 1))) {
        M(K.slice(0, K.length - 1));
        return;
      }
      g.value = a.tagValidator(K) && !C.value ? [K] : [], v.value = a.tagValidator(K) ? [] : [K], h.value = C.value ? [K] : [], o("tag-state", g.value, v.value, h.value);
    }, le = (A) => {
      a.addOnChange && (R(A), C.value || M(m.value));
    }, N = (A) => {
      if (A.key === "Enter" && !a.noAddOnEnter) {
        M(m.value);
        return;
      }
      (A.key === "Backspace" || A.key === "Delete") && a.removeOnDelete && m.value === "" && y.value && f.value.length > 0 ? j(f.value[f.value.length - 1]) : y.value = !0;
    };
    Re(N, { target: u });
    const S = B(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), E = B(() => {
      if (S.value)
        return new RegExp(`[${Or(S.value)}]+`);
    }), M = (A) => {
      A = (A ?? m.value).trim();
      const K = E.value ? A.split(E.value).map((q) => q.trim()) : [A], G = [];
      for (const q of K)
        if (!(q === "" || C.value || !a.tagValidator(q))) {
          if (s.value && _.value)
            break;
          G.push(q);
        }
      const ie = [...r.value, ...G];
      m.value = "", y.value = !0, r.value = ie, d.value = !0;
    }, j = (A) => {
      const K = f.value.indexOf((A == null ? void 0 : A.toString()) ?? "");
      K !== -1 && (c.value = f.value.splice(K, 1).toString(), r.value = f.value);
    };
    return e({
      blur: () => {
        d.value = !1;
      },
      element: u,
      focus: () => {
        d.value = !0;
      }
    }), (A, K) => (b(), V("div", {
      id: O(n),
      class: D(["b-form-tags form-control h-auto", k.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: W,
      onFocusout: K[1] || (K[1] = (G) => o("focusout", G))
    }, [
      Z("output", {
        id: `${O(n)}selected_tags__`,
        class: "visually-hidden",
        for: p.value,
        "aria-live": O(d) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, Y(f.value.join(", ")), 9, ju),
      Z("div", {
        id: `${O(n)}removed_tags__`,
        role: "status",
        "aria-live": O(d) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + Y(A.tagRemovedLabel) + ") " + Y(c.value), 9, qu),
      T(A.$slots, "default", me(we(Q.value)), () => [
        Z("ul", {
          id: `${O(n)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (b(!0), V(de, null, Ce(f.value, (G, ie) => T(A.$slots, "tag", {
            key: ie,
            tag: G,
            tagClass: A.tagClass,
            tagVariant: A.tagVariant,
            tagPills: a.tagPills,
            removeTag: j
          }, () => [
            (b(), I(yn, {
              key: G,
              class: D(A.tagClass),
              tag: "li",
              variant: A.tagVariant,
              pill: A.tagPills,
              onRemove: j
            }, {
              default: P(() => [
                se(Y(G), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          Z("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${O(n)}tag_list__`
          }, [
            Z("div", Uu, [
              Z("input", X({
                id: p.value,
                ref_key: "input",
                ref: u,
                disabled: a.disabled,
                value: m.value,
                type: A.inputType,
                placeholder: A.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, A.inputAttrs, {
                form: A.form,
                required: a.required || void 0,
                "aria-required": a.required || void 0,
                onInput: R,
                onChange: le,
                onFocus: L,
                onBlur: J
              }), null, 16, Xu),
              F.value ? (b(), V("button", {
                key: 0,
                type: "button",
                class: D(["btn b-form-tags-button py-0", [
                  A.inputClass,
                  {
                    [`btn-${A.addButtonVariant}`]: A.addButtonVariant !== null,
                    "disabled invisible": m.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: a.disabled || m.value.length === 0 || _.value,
                onClick: K[0] || (K[0] = (G) => M(m.value))
              }, [
                T(A.$slots, "add-button-text", {}, () => [
                  se(Y(A.addButtonText), 1)
                ])
              ], 10, Ku)) : ae("", !0)
            ])
          ], 8, Gu)
        ], 8, Wu),
        Z("div", Yu, [
          w.value ? (b(), V("div", Ju, Y(A.invalidTagText) + ": " + Y(m.value), 1)) : ae("", !0),
          C.value ? (b(), V("small", Zu, Y(A.duplicateTagText) + ": " + Y(m.value), 1)) : ae("", !0),
          f.value.length === A.limit ? (b(), V("small", Qu, Y(A.limitTagsText), 1)) : ae("", !0)
        ])
      ]),
      A.name ? (b(!0), V(de, { key: 0 }, Ce(f.value, (G, ie) => (b(), V("input", {
        key: ie,
        type: "hidden",
        name: A.name,
        value: G
      }, null, 8, ed))), 128)) : ae("", !0)
    ], 42, Du));
  }
}), ad = ["id", "name", "form", "value", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], ld = /* @__PURE__ */ H({
  __name: "BFormTextarea",
  props: {
    noResize: { type: Boolean, default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    trim: { type: Boolean, default: !1 },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  },
  emits: ["update:modelValue"],
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, { input: r, computedId: n, computedAriaInvalid: s, onInput: i, onChange: u, onBlur: d, focus: p, blur: f } = Wo(a, o), m = Ct(() => a.state), y = B(() => [
      m.value,
      a.plaintext ? "form-control-plaintext" : "form-control",
      {
        [`form-control-${a.size}`]: !!a.size
      }
    ]), c = B(() => ({
      resize: a.noResize ? "none" : void 0
    }));
    return e({
      blur: f,
      element: r,
      focus: p
    }), (g, v) => (b(), V("textarea", {
      id: O(n),
      ref_key: "input",
      ref: r,
      class: D(y.value),
      name: g.name || void 0,
      form: g.form || void 0,
      value: g.modelValue ?? void 0,
      disabled: a.disabled,
      placeholder: g.placeholder,
      required: a.required || void 0,
      autocomplete: g.autocomplete || void 0,
      readonly: a.readonly || a.plaintext,
      "aria-required": g.required || void 0,
      "aria-invalid": O(s),
      rows: g.rows,
      style: Ee(c.value),
      wrap: g.wrap || void 0,
      onInput: v[0] || (v[0] = (h) => O(i)(h)),
      onChange: v[1] || (v[1] = (h) => O(u)(h)),
      onBlur: v[2] || (v[2] = (h) => O(d)(h))
    }, null, 46, ad));
  }
}), od = {
  key: 0,
  class: "input-group-text"
}, nd = ["innerHTML"], sd = { key: 1 }, rd = {
  key: 0,
  class: "input-group-text"
}, id = ["innerHTML"], ud = { key: 1 }, dd = /* @__PURE__ */ H({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`input-group-${e.size}`]: e.size !== "md"
    })), a = $(() => !!e.append || !!e.appendHtml), o = $(() => !!e.prepend || !!e.prependHtml);
    return (r, n) => (b(), I(re(r.tag), {
      id: r.id,
      class: D(["input-group", l.value]),
      role: "group"
    }, {
      default: P(() => [
        T(r.$slots, "prepend", {}, () => [
          o.value ? (b(), V("span", od, [
            r.prependHtml ? (b(), V("span", {
              key: 0,
              innerHTML: r.prependHtml
            }, null, 8, nd)) : (b(), V("span", sd, Y(r.prepend), 1))
          ])) : ae("", !0)
        ]),
        T(r.$slots, "default"),
        T(r.$slots, "append", {}, () => [
          a.value ? (b(), V("span", rd, [
            r.appendHtml ? (b(), V("span", {
              key: 0,
              innerHTML: r.appendHtml
            }, null, 8, id)) : (b(), V("span", ud, Y(r.append), 1))
          ])) : ae("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), gn = /* @__PURE__ */ H({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "input-group-text" }, {
      default: P(() => [
        T(e.$slots, "default", {}, () => [
          se(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), ll = /* @__PURE__ */ H({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t;
    return (l, a) => e.isText ? (b(), I(gn, { key: 0 }, {
      default: P(() => [
        T(l.$slots, "default")
      ]),
      _: 3
    })) : T(l.$slots, "default", { key: 1 });
  }
}), cd = /* @__PURE__ */ H({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, l) => (b(), I(ll, me(we(e.$props)), {
      default: P(() => [
        T(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fd = /* @__PURE__ */ H({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, l) => (b(), I(ll, me(we(e.$props)), {
      default: P(() => [
        T(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vd = /* @__PURE__ */ H({
  __name: "BListGroup",
  props: {
    flush: { type: Boolean, default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = B(() => {
      const o = e.flush ? !1 : e.horizontal;
      return {
        "list-group-flush": e.flush,
        "list-group-horizontal": o === !0,
        [`list-group-horizontal-${o}`]: typeof o == "string",
        "list-group-numbered": e.numbered
      };
    }), a = $(() => e.numbered === !0 ? "ol" : e.tag);
    return tt(So, {
      numbered: $(() => e.numbered)
    }), (o, r) => (b(), I(re(a.value), {
      class: D(["list-group", l.value])
    }, {
      default: P(() => [
        T(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), pd = /* @__PURE__ */ H({
  __name: "BListGroupItem",
  props: {
    action: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    tag: { default: "div" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, l = Mt(), a = Ve(So, null), { computedLink: o } = wt(e), r = $(() => !e.button && o.value), n = $(
      () => a != null && a.numbered.value ? "li" : e.button ? "button" : r.value ? lt : e.tag
    ), s = B(
      () => e.action || r.value || e.button || ["a", "router-link", "button", "b-link"].includes(e.tag)
    ), i = B(() => ({
      [`list-group-item-${e.variant}`]: e.variant !== null && e.variant !== void 0,
      "list-group-item-action": s.value,
      active: e.active,
      disabled: e.disabled
    })), u = B(() => {
      const d = {};
      return e.button && ((!l || !l.type) && (d.type = "button"), e.disabled && (d.disabled = !0)), d;
    });
    return (d, p) => (b(), I(re(n.value), X({
      class: ["list-group-item", i.value],
      "aria-current": e.active ? !0 : void 0,
      "aria-disabled": e.disabled ? !0 : void 0,
      target: r.value ? d.target : void 0,
      href: e.button ? void 0 : d.href,
      to: e.button ? void 0 : d.to
    }, u.value), {
      default: P(() => [
        T(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), md = { id: "__BVID__modal-container" }, bd = /* @__PURE__ */ H({
  __name: "BModalOrchestrator",
  props: {
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(t, { expose: e }) {
    const l = t, { modals: a, remove: o, show: r, confirm: n } = Uo(), s = (i) => va(i, ["_promise", "_self", "_isConfirm", "_modelValue"]);
    return e({
      modals: a,
      show: r,
      confirm: n
    }), (i, u) => (b(), I(ht, {
      to: i.teleportTo,
      disabled: l.teleportDisabled
    }, [
      Z("div", md, [
        (b(!0), V(de, null, Ce(O(a), (d, p) => (b(), I(re(d.value.component), X({
          key: p,
          modelValue: d.value.props._modelValue,
          "onUpdate:modelValue": (f) => d.value.props._modelValue = f
        }, s(d.value.props), {
          "teleport-disabled": !0,
          onHide: (f) => {
            if (d.value.props._isConfirm === !0) {
              if (f.trigger === "ok") {
                d.value.props._promise.resolve(!0);
                return;
              }
              if (f.trigger === "cancel") {
                d.value.props._promise.resolve(!1);
                return;
              }
              d.value.props._promise.resolve(null);
            }
            d.value.props._promise.resolve(!0);
          },
          onHidden: (f) => {
            var m;
            return (m = O(o)) == null ? void 0 : m(d.value.props._self);
          }
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onHide", "onHidden"]))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), yd = /* @__PURE__ */ H({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tabs: { type: Boolean, default: !1 },
    tag: { default: "ul" },
    underline: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = Dt(() => e.align), a = B(() => ({
      "nav-tabs": e.tabs,
      "nav-pills": e.pills && !e.tabs,
      "card-header-tabs": !e.vertical && e.cardHeader && e.tabs,
      "card-header-pills": !e.vertical && e.cardHeader && e.pills && !e.tabs,
      "flex-column": e.vertical,
      "nav-fill": !e.vertical && e.fill,
      "nav-justified": !e.vertical && e.justified,
      [l.value]: !e.vertical && e.align !== void 0,
      small: e.small,
      "nav-underline": e.underline
    }));
    return (o, r) => (b(), I(re(o.tag), {
      class: D(["nav", a.value])
    }, {
      default: P(() => [
        T(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), gd = { class: "d-flex flex-row align-items-center flex-wrap" }, hd = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    floating: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: void 0 },
    validated: { type: Boolean, default: void 0 }
  },
  emits: ["submit"],
  setup(t, { emit: e }) {
    const l = e, a = (o) => {
      l("submit", o);
    };
    return (o, r) => (b(), V("li", gd, [
      ve(cn, X(o.$attrs, {
        id: o.id,
        floating: o.floating,
        role: o.role,
        novalidate: o.novalidate,
        validated: o.validated,
        class: "d-flex",
        onSubmit: ft(a, ["prevent"])
      }), {
        default: P(() => [
          T(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated"])
    ]));
  }
}), Bd = { class: "nav-item" }, wd = /* @__PURE__ */ H({
  __name: "BNavItem",
  props: {
    linkAttrs: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = B(
      () => Ja(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return o.value.activeClass, (r, n) => (b(), V("li", Bd, [
      ve(lt, X({
        class: ["nav-link", r.linkClass],
        tabindex: l.disabled ? -1 : void 0,
        "aria-disabled": l.disabled ? !0 : void 0
      }, { ...o.value, ...r.linkAttrs }, {
        onClick: n[0] || (n[0] = (s) => a("click", s))
      }), {
        default: P(() => [
          T(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
}), Cd = { class: "nav-item dropdown" }, kd = /* @__PURE__ */ H({
  __name: "BNavItemDropdown",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !0 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "modelValue"), n = x(null), s = () => {
      var d;
      (d = n.value) == null || d.hide();
    }, i = () => {
      var d;
      (d = n.value) == null || d.show();
    };
    return e({
      hide: s,
      show: i,
      toggle: () => {
        var d;
        (d = n.value) == null || d.toggle();
      }
    }), (d, p) => (b(), V("li", Cd, [
      ve(dn, X({
        ref_key: "dropdown",
        ref: n
      }, a, {
        modelValue: r.value,
        "onUpdate:modelValue": p[0] || (p[0] = (f) => r.value = f),
        "is-nav": "",
        onShow: p[1] || (p[1] = (f) => o("show", f)),
        onShown: p[2] || (p[2] = (f) => o("shown")),
        onHide: p[3] || (p[3] = (f) => o("hide", f)),
        onHidden: p[4] || (p[4] = (f) => o("hidden")),
        onHidePrevented: p[5] || (p[5] = (f) => o("hide-prevented")),
        onShowPrevented: p[6] || (p[6] = (f) => o("show-prevented")),
        onClick: p[7] || (p[7] = (f) => o("click", f)),
        onToggle: p[8] || (p[8] = (f) => o("toggle"))
      }), {
        "button-content": P(() => [
          T(d.$slots, "button-content")
        ]),
        "toggle-text": P(() => [
          T(d.$slots, "toggle-text")
        ]),
        default: P(() => [
          T(d.$slots, "default", {
            hide: s,
            show: i
          })
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), $d = { class: "navbar-text" }, Td = /* @__PURE__ */ H({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), V("li", $d, [
      T(e.$slots, "default", {}, () => [
        se(Y(e.text), 1)
      ])
    ]));
  }
}), Sd = /* @__PURE__ */ H({
  __name: "BNavbar",
  props: {
    autoClose: { type: Boolean, default: !0 },
    container: { type: [Boolean, String], default: "fluid" },
    fixed: { default: void 0 },
    print: { type: Boolean, default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = $(() => e.tag === "nav" ? void 0 : "navigation"), a = Er(() => e.container), o = B(() => ({
      "d-print": e.print,
      [`sticky-${e.sticky}`]: e.sticky !== void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`fixed-${e.fixed}`]: e.fixed !== void 0,
      "navbar-expand": e.toggleable === !1,
      [`navbar-expand-${e.toggleable}`]: typeof e.toggleable == "string"
    }));
    return tt(Ya, {
      tag: $(() => e.tag),
      autoClose: $(() => e.autoClose)
    }), (r, n) => (b(), I(re(r.tag), {
      class: D(["navbar", o.value]),
      role: l.value
    }, {
      default: P(() => [
        r.container !== !1 ? (b(), V("div", {
          key: 0,
          class: D(O(a))
        }, [
          T(r.$slots, "default")
        ], 2)) : T(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Vd = /* @__PURE__ */ H({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, { computedLink: l, computedLinkProps: a } = wt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), o = $(() => l.value ? lt : e.tag);
    return (r, n) => (b(), I(re(o.value), X({ class: "navbar-brand" }, O(a)), {
      default: P(() => [
        T(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _d = /* @__PURE__ */ H({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "ul" }
  },
  setup(t) {
    const e = t, l = Dt(() => e.align), a = B(() => ({
      "nav-fill": e.fill,
      "nav-justified": e.justified,
      [l.value]: e.align !== void 0,
      small: e.small
    }));
    return (o, r) => (b(), V("ul", {
      class: D(["navbar-nav", a.value])
    }, [
      T(o.$slots, "default")
    ], 2));
  }
}), Il = (t, e) => t.setAttribute("data-bs-theme", e), Ad = {
  mounted(t, e) {
    Il(t, e.value);
  },
  updated(t, e) {
    Il(t, e.value);
  }
}, Od = (t, e) => {
  const { modifiers: l, arg: a, value: o } = t, r = Object.keys(l || {}), n = typeof o == "string" ? o.split(Jt) : o;
  if (e.tagName.toLowerCase() === "a") {
    const s = e.getAttribute("href") || "";
    Tr.test(s) && r.push(s.replace($r, ""));
  }
  return Array.prototype.concat.apply([], [a, n]).forEach((s) => typeof s == "string" && r.push(s)), r.filter((s, i, u) => s && u.indexOf(s) === i);
}, Nd = (t, e) => {
  t.forEach((l) => {
    const a = document.getElementById(l);
    a !== null && a.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => hn(t, e), 50);
}, hn = (t, e) => {
  let l = !1;
  t.forEach((a) => {
    const o = document.getElementById(a);
    o != null && o.classList.contains("show") && (l = !0), o != null && o.classList.contains("closing") && (l = !1);
  }), e.setAttribute("aria-expanded", l ? "true" : "false"), e.classList.remove(l ? "collapsed" : "not-collapsed"), e.classList.add(l ? "not-collapsed" : "collapsed");
}, Pl = (t, e) => {
  const l = Od(e, t);
  l.length !== 0 && (t.__toggle && t.removeEventListener("click", t.__toggle), t.__toggle = () => Nd(l, t), t.addEventListener("click", t.__toggle), t.setAttribute("aria-controls", l.join(" ")), hn(l, t));
}, Na = {
  mounted: Pl,
  updated: Pl,
  unmounted(t) {
    t.removeEventListener("click", t.__toggle), t.removeAttribute("aria-controls"), t.removeAttribute("aria-expanded");
  }
}, Id = {
  mounted(t, e) {
    if (!Ht(e.value))
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || sa(t, e, {
      ...na(e, t),
      ...a
    });
  },
  updated(t, e) {
    if (!Ht(e.value))
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || (ra(t), sa(t, e, {
      ...na(e, t),
      ...a
    }));
  },
  beforeUnmount(t) {
    ra(t);
  }
}, El = (t, e) => {
  t.$__scrollspy && t.$__scrollspy.cleanup();
  const { arg: l, value: a } = e, o = typeof a == "object" && a !== null, r = l || (typeof a == "string" ? a : o ? a.content || a.element : null);
  t.$__scrollspy = Ko(r, t, o ? va(a, ["content", "element"]) : {});
}, Pd = {
  mounted: El,
  updated: El,
  beforeUnmount(t) {
    t.$__scrollspy && t.$__scrollspy.cleanup();
  }
}, Ed = {
  mounted(t, e) {
    const l = Ht(e.value);
    if (!l)
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || sa(t, e, {
      noninteractive: !0,
      ...na(e, t),
      title: a.title ?? a.content ?? "",
      tooltip: l
    });
  },
  updated(t, e) {
    const l = Ht(e.value);
    if (!l)
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || (ra(t), sa(t, e, {
      noninteractive: !0,
      ...na(e, t),
      title: a.title ?? a.content ?? "",
      tooltip: l
    }));
  },
  beforeUnmount(t) {
    ra(t);
  }
}, Ll = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Ad,
  vBModal: Na,
  vBPopover: Id,
  vBScrollspy: Pd,
  vBToggle: Na,
  vBTooltip: Ed
}, Symbol.toStringTag, { value: "Module" })), Ld = ["disabled", "aria-label"], Fd = /* @__PURE__ */ Z("span", { class: "navbar-toggler-icon" }, null, -1), zd = /* @__PURE__ */ H({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: Boolean, default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = B(() => ({
      disabled: l.disabled
    })), r = (n) => {
      l.disabled || a("click", n);
    };
    return (n, s) => ut((b(), V("button", {
      class: D(["navbar-toggler", o.value]),
      type: "button",
      disabled: l.disabled,
      "aria-label": n.label,
      onClick: r
    }, [
      T(n.$slots, "default", {}, () => [
        Fd
      ])
    ], 10, Ld)), [
      [O(Na), l.disabled ? void 0 : n.target]
    ]);
  }
}), Hd = ["id", "aria-labelledby"], Rd = ["id"], Md = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: /* @__PURE__ */ pe({
    backdrop: { type: Boolean, default: !0 },
    backdropBlur: { default: void 0 },
    backdropVariant: { default: "dark" },
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: Boolean, default: !1 },
    footerClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFocus: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noHeaderClose: { type: Boolean, default: !1 },
    placement: { default: "start" },
    shadow: { type: Boolean, default: !1 },
    title: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["close", "esc", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Fe(), n = he(t, "modelValue"), s = Be(() => a.id, "offcanvas");
    Xo(n, () => a.bodyScrolling);
    const i = x(null);
    Re(
      "Escape",
      () => {
        w("esc");
      },
      { target: i }
    );
    const { focused: u } = Pe(i, {
      initialValue: n.value && a.noFocus === !1
    }), d = x(n.value), p = x(!1), f = $(() => a.backdrop === !0 && n.value === !0), m = $(
      () => a.lazy === !1 || a.lazy === !0 && p.value === !0 || a.lazy === !0 && n.value === !0
    ), y = $(() => !Ae(r["header-close"])), c = B(() => [
      { "text-reset": !y.value },
      a.headerCloseClass
    ]), g = B(() => ({
      variant: y.value ? a.headerCloseVariant : void 0,
      class: c.value
    })), v = $(() => !Ae(r.footer)), h = B(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: n.value && d.value === !0,
        [`shadow-${a.shadow}`]: !!a.shadow
      }
    ]), k = B(() => ({
      visible: n.value,
      placement: a.placement,
      hide: w
    })), C = (R, le = {}) => new Bt(R, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ...le,
      componentId: s.value
    }), w = (R = "") => {
      if (R === "backdrop" && a.noCloseOnBackdrop || R === "esc" && a.noCloseOnEsc) {
        o("hide-prevented");
        return;
      }
      const le = C("hide", { cancelable: R !== "", trigger: R });
      if (R === "close" && o(R, le), R === "esc" && o(R, le), o("hide", le), le.defaultPrevented) {
        o("hide-prevented");
        return;
      }
      n.value = !1;
    }, _ = () => {
      const R = C("show", { cancelable: !0 });
      if (o("show", R), R.defaultPrevented) {
        n.value = !1, o("show-prevented");
        return;
      }
      n.value = !0;
    }, F = () => {
      _e(() => {
        a.noFocus === !1 && (u.value = !0);
      });
    }, Q = () => _(), W = () => {
      d.value = !0, F(), o("shown", C("shown")), a.lazy === !0 && (p.value = !0);
    }, L = () => {
      d.value = !1;
    }, J = () => {
      o("hidden", C("hidden")), a.lazy === !0 && (p.value = !1);
    };
    return ke(i, "bv-toggle", () => {
      n.value ? w() : _();
    }), e({
      hide: w,
      show: _
    }), (R, le) => (b(), I(ht, {
      to: R.teleportTo,
      disabled: a.teleportDisabled
    }, [
      ve(It, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: Q,
        onAfterEnter: W,
        onLeave: L,
        onAfterLeave: J
      }, {
        default: P(() => [
          ut(Z("div", X({
            id: O(s),
            ref_key: "element",
            ref: i,
            "aria-modal": "true",
            role: "dialog",
            class: h.value,
            tabindex: "-1",
            "aria-labelledby": `${O(s)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, R.$attrs), [
            m.value ? (b(), V(de, { key: 0 }, [
              a.noHeader ? ae("", !0) : (b(), V("div", {
                key: 0,
                class: D(["offcanvas-header", R.headerClass])
              }, [
                T(R.$slots, "header", me(we(k.value)), () => [
                  Z("h5", {
                    id: `${O(s)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    T(R.$slots, "title", me(we(k.value)), () => [
                      se(Y(R.title), 1)
                    ])
                  ], 8, Rd),
                  a.noHeaderClose ? ae("", !0) : (b(), V(de, { key: 0 }, [
                    y.value ? (b(), I(vt, X({ key: 0 }, g.value, {
                      onClick: le[0] || (le[0] = (N) => w("close"))
                    }), {
                      default: P(() => [
                        T(R.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (b(), I(Pt, X({
                      key: 1,
                      "aria-label": R.headerCloseLabel
                    }, g.value, {
                      onClick: le[1] || (le[1] = (N) => w("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              Z("div", X({
                class: ["offcanvas-body", R.bodyClass]
              }, R.bodyAttrs), [
                T(R.$slots, "default", me(we(k.value)))
              ], 16),
              v.value ? (b(), V("div", {
                key: 1,
                class: D(R.footerClass)
              }, [
                T(R.$slots, "footer", me(we(k.value)))
              ], 2)) : ae("", !0)
            ], 64)) : ae("", !0)
          ], 16, Hd), [
            [xt, n.value]
          ])
        ]),
        _: 3
      }),
      T(R.$slots, "backdrop", {}, () => [
        ve(ma, {
          blur: R.backdropBlur,
          variant: R.backdropVariant,
          show: f.value,
          fixed: "",
          "no-wrap": "",
          "no-spinner": "",
          onClick: le[2] || (le[2] = (N) => w("backdrop"))
        }, null, 8, ["blur", "variant", "show"])
      ])
    ], 8, ["to", "disabled"]));
  }
}), xd = ["aria-disabled", "aria-label"], Fl = 20, zl = 0, Dd = /* @__PURE__ */ H({
  __name: "BPagination",
  props: /* @__PURE__ */ pe({
    align: { default: "start" },
    ariaControls: { default: void 0 },
    ariaLabel: { default: "Pagination" },
    disabled: { type: Boolean, default: !1 },
    ellipsisClass: { default: void 0 },
    ellipsisText: { default: "" },
    firstClass: { default: void 0 },
    firstNumber: { type: Boolean, default: !1 },
    firstText: { default: "" },
    hideEllipsis: { type: Boolean, default: !1 },
    hideGotoEndButtons: { type: Boolean, default: !1 },
    labelFirstPage: { default: "Go to first page" },
    labelLastPage: { default: "Go to last page" },
    labelNextPage: { default: "Go to next page" },
    labelPage: { default: "Go to page" },
    labelPrevPage: { default: "Go to previous page" },
    lastClass: { default: void 0 },
    lastNumber: { type: Boolean, default: !1 },
    lastText: { default: "" },
    limit: { default: 5 },
    modelValue: {},
    nextClass: { default: void 0 },
    nextText: { default: "" },
    pageClass: { default: void 0 },
    perPage: { default: Fl },
    pills: { type: Boolean, default: !1 },
    prevClass: { default: void 0 },
    prevText: { default: "" },
    size: { default: void 0 },
    totalRows: { default: zl }
  }, {
    modelValue: { default: 1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["page-click"], ["update:modelValue"]),
  setup(t, { emit: e }) {
    const i = t, u = e, d = he(t, "modelValue"), p = be(() => i.limit, { nanToZero: !0, method: "parseInt" }), f = be(() => i.perPage, { nanToZero: !0, method: "parseInt" }), m = be(() => i.totalRows, { nanToZero: !0, method: "parseInt" }), y = be(d, { nanToZero: !0, method: "parseInt" }), c = $(() => Math.max(f.value || Fl, 1)), g = $(() => Math.max(m.value || zl, 0)), v = $(() => Math.ceil(g.value / c.value)), h = $(() => i.align === "fill"), k = $(() => i.align === "fill" ? "start" : i.align), C = Dt(k), w = (te) => te === y.value, _ = (te) => i.disabled ? null : w(te) ? "0" : "-1", F = (te) => i.disabled || w(te) || y.value < 1 || // Check if the number is out of bounds
    te < 1 || te > v.value, Q = B(() => F(1)), W = B(() => F(y.value - 1)), L = B(() => F(v.value)), J = B(() => F(y.value + 1)), R = ({
      page: te,
      classVal: ye,
      dis: ee,
      slotName: U,
      textValue: z,
      tabIndex: oe,
      label: fe,
      position: ce,
      isActive: Oe,
      role: $e,
      hidden: Te
    }) => ({
      li: {
        class: [
          "page-item",
          {
            active: Oe,
            disabled: ee,
            "flex-fill": h.value,
            "d-flex": h.value && !ee
          },
          ye
        ],
        role: $e,
        "aria-hidden": Te
      },
      button: {
        is: ee ? "span" : "button",
        class: ["page-link", { "flex-grow-1": !ee && h.value }],
        "aria-label": fe,
        "aria-controls": i.ariaControls || void 0,
        "aria-disabled": ee ? !0 : void 0,
        "aria-posinset": ce,
        "aria-setsize": ce ? v.value : void 0,
        role: "menuitem",
        type: ee ? void 0 : "button",
        tabindex: ee ? void 0 : oe
      },
      text: {
        name: U,
        active: Oe,
        value: z ?? te,
        page: te,
        disabled: ee,
        index: te - 1,
        content: z ? void 0 : te
      },
      clickHandler: (Ke) => ne(Ke, te)
    }), le = ({
      page: te,
      classVal: ye,
      dis: ee,
      slotName: U,
      textValue: z,
      label: oe
    }) => R({ page: te, classVal: ye, dis: ee, slotName: U, textValue: z, label: oe, tabIndex: "-1" }), N = (te) => R({
      page: te,
      dis: i.disabled,
      classVal: i.pageClass,
      slotName: "page",
      label: i.labelPage ? `${i.labelPage} ${te}` : void 0,
      tabIndex: _(te) ?? void 0,
      position: te,
      isActive: w(te)
    }), S = B(
      () => le({
        page: 1,
        dis: Q.value,
        classVal: i.firstClass,
        slotName: "first-text",
        textValue: i.firstText,
        label: i.labelFirstPage
      })
    ), E = B(
      () => le({
        page: Math.max(y.value - 1, 1),
        dis: W.value,
        classVal: i.prevClass,
        slotName: "prev-text",
        textValue: i.prevText,
        label: i.labelPrevPage
      })
    ), M = B(
      () => le({
        page: Math.min(y.value + 1, v.value),
        dis: J.value,
        classVal: i.nextClass,
        slotName: "next-text",
        textValue: i.nextText,
        label: i.labelNextPage
      })
    ), j = B(
      () => le({
        page: v.value,
        dis: L.value,
        classVal: i.lastClass,
        slotName: "last-text",
        textValue: i.lastText,
        label: i.labelLastPage
      })
    ), A = zt(), K = zt(), G = B(() => ({
      li: {
        class: [
          "page-item",
          "disabled",
          "bv-d-xs-down-none",
          h.value ? "flex-fill" : "",
          i.ellipsisClass
        ],
        role: "separator"
      },
      span: {
        class: ["page-link"]
      }
    })), ie = B(() => [
      C.value,
      {
        [`pagination-${i.size}`]: i.size !== void 0,
        "b-pagination-pills": i.pills
      }
    ]), q = B(() => ({
      pageSize: c.value,
      totalRows: m.value,
      numberOfPages: v.value
    })), ne = (te, ye) => {
      if (ye === y.value)
        return;
      const ee = new nt("page-click", {
        cancelable: !0,
        target: te.target
      });
      u("page-click", ee, ye), !ee.defaultPrevented && (d.value = ye);
    };
    ue(y, (te) => {
      const ee = ((U, z) => {
        const oe = U || 1;
        return oe > z ? z : oe < 1 ? 1 : oe;
      })(te, v.value);
      ee !== d.value && (d.value = ee);
    }), ue(q, (te, ye) => {
      (ye.pageSize !== te.pageSize && ye.totalRows === te.totalRows || ye.numberOfPages !== te.numberOfPages && y.value > ye.numberOfPages) && (d.value = 1);
    });
    const ge = B(() => {
      const te = v.value, { value: ye } = y, ee = p.value, U = i.firstNumber ? 1 : 0, z = i.lastNumber ? 1 : 0, oe = i.hideEllipsis || ee <= 3, fe = i.hideGotoEndButtons ? 1 : 0;
      if (te < ee + U + z)
        return [
          !U && !fe ? -1 : null,
          -2,
          ...Array.from({ length: te }, ($e, Te) => Te + 1),
          -3,
          !z && !fe ? -4 : null
        ].filter(($e) => $e !== null);
      const ce = Array.from({ length: ee + 4 - fe * 2 });
      fe ? (ce[0] = -2, ce[ce.length - 1] = -3) : (U ? (ce[0] = -2, ce[1] = 1) : (ce[0] = -1, ce[1] = -2), z ? (ce[ce.length - 1] = -3, ce[ce.length - 2] = te) : (ce[ce.length - 1] = -4, ce[ce.length - 2] = -3));
      const Oe = Math.floor(ee / 2);
      if (ye <= Oe + U) {
        for (let $e = 1; $e <= ee; $e++)
          ce[$e + 1 - fe] = $e + U;
        oe || (ce[ce.length - 3] = -5);
      }
      if (ye > te - Oe - z) {
        const $e = te - (ee - 1) - z;
        for (let Te = 0; Te < ee; Te++)
          ce[Te + 2 - fe] = $e + Te;
        oe || (ce[2] = -5);
      }
      if (!ce[2]) {
        const $e = ye - Math.floor(ee / 2);
        for (let Te = 0; Te < ee; Te++)
          ce[Te + 2 - fe] = $e + Te;
        oe || (ce[2] = -5, ce[ce.length - 3] = -5);
      }
      return ce;
    });
    return (te, ye) => (b(), V("ul", {
      class: D(["pagination", ie.value]),
      role: "menubar",
      "aria-disabled": i.disabled,
      "aria-label": te.ariaLabel || void 0
    }, [
      ve(O(A).define, null, {
        default: P(({ button: ee, li: U, text: z, clickHandler: oe }) => [
          Z("li", me(we(U)), [
            (b(), I(re(ee.is), X(ee, { onClick: oe }), {
              default: P(() => [
                T(te.$slots, z.name, {
                  disabled: z.disabled,
                  page: z.page,
                  index: z.index,
                  active: z.active,
                  content: z.value
                }, () => [
                  se(Y(z.value), 1)
                ])
              ]),
              _: 2
            }, 1040, ["onClick"]))
          ], 16)
        ]),
        _: 3
      }),
      ve(O(K).define, null, {
        default: P(() => [
          Z("li", me(we(G.value.li)), [
            Z("span", me(we(G.value.span)), [
              T(te.$slots, "ellipsis-text", {}, () => [
                se(Y(te.ellipsisText || "..."), 1)
              ])
            ], 16)
          ], 16)
        ]),
        _: 3
      }),
      (b(!0), V(de, null, Ce(ge.value, (ee) => (b(), V(de, {
        key: `page-${ee.number}`
      }, [
        ee === -1 ? (b(), I(O(A).reuse, me(X({ key: 0 }, S.value)), null, 16)) : ee === -2 ? (b(), I(O(A).reuse, me(X({ key: 1 }, E.value)), null, 16)) : ee === -3 ? (b(), I(O(A).reuse, me(X({ key: 2 }, M.value)), null, 16)) : ee === -4 ? (b(), I(O(A).reuse, me(X({ key: 3 }, j.value)), null, 16)) : ee === -5 ? (b(), I(O(K).reuse, { key: 4 })) : (b(), I(O(A).reuse, me(X({ key: 5 }, N(ee))), null, 16))
      ], 64))), 128))
    ], 10, xd));
  }
}), je = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    animation: { default: void 0 },
    cols: { default: 12 },
    size: { default: "md" },
    tag: { default: "span" },
    variant: { default: null },
    width: { default: void 0 },
    wrapperTag: { default: "span" }
  },
  setup(t) {
    const e = t, l = $(
      () => e.width === void 0 ? void 0 : typeof e.width == "number" ? e.width.toString() : e.width.replace("%", "")
    ), a = $(
      () => e.cols === void 0 ? void 0 : typeof e.cols == "number" ? e.cols.toString() : e.cols
    ), o = B(() => ({
      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`placeholder-${e.size}`]: e.size !== "md"
    })), r = B(() => ({
      [`placeholder-${e.animation}`]: e.animation !== void 0
    })), n = B(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (s, i) => (b(), I(re(s.wrapperTag), {
      class: D(r.value)
    }, {
      default: P(() => [
        (b(), I(re(s.tag), X(s.$attrs, {
          class: ["placeholder", o.value],
          style: n.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), Bn = /* @__PURE__ */ H({
  __name: "BPlaceholderButton",
  props: {
    animation: { default: void 0 },
    cols: { default: void 0 },
    tag: { default: "div" },
    variant: { default: "primary" },
    width: { default: void 0 }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`btn-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), I(je, {
      class: D(["btn disabled", l.value]),
      animation: a.animation,
      width: a.width,
      cols: a.cols,
      tag: a.tag,
      style: { cursor: "wait", "pointer-events": "auto" }
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
}), jd = /* @__PURE__ */ H({
  __name: "BPlaceholderCard",
  props: {
    animation: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    footerWidth: { default: 100 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    headerWidth: { default: 100 },
    imgBlankColor: { default: "#868e96" },
    imgBottom: { type: Boolean, default: !1 },
    imgHeight: { default: 100 },
    imgSrc: { default: void 0 },
    noButton: { type: Boolean, default: !1 },
    noFooter: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noImg: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, l = B(() => ({
      animation: e.animation,
      size: e.size,
      variant: e.variant
    })), a = $(() => e.noButton ? je : Bn);
    return (o, r) => (b(), I(un, { "img-bottom": o.imgBottom }, Fa({
      default: P(() => [
        T(o.$slots, "default", {}, () => [
          ve(je, X({ cols: "7" }, l.value), null, 16),
          ve(je, X({ cols: "4" }, l.value), null, 16),
          ve(je, X({ cols: "4" }, l.value), null, 16),
          ve(je, X({ cols: "6" }, l.value), null, 16),
          ve(je, X({ cols: "8" }, l.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      e.noImg ? void 0 : {
        name: "img",
        fn: P(() => [
          T(o.$slots, "img", {}, () => [
            ve(tl, {
              blank: !o.imgSrc,
              "blank-color": o.imgBlankColor,
              height: o.imgSrc ? void 0 : o.imgHeight,
              src: o.imgSrc,
              top: !o.imgBottom,
              bottom: o.imgBottom,
              style: { cursor: "wait" }
            }, null, 8, ["blank", "blank-color", "height", "src", "top", "bottom"])
          ])
        ]),
        key: "0"
      },
      e.noHeader ? void 0 : {
        name: "header",
        fn: P(() => [
          T(o.$slots, "header", {}, () => [
            ve(je, {
              width: o.headerWidth,
              variant: o.headerVariant,
              animation: o.headerAnimation,
              size: o.headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      e.noFooter ? void 0 : {
        name: "footer",
        fn: P(() => [
          T(o.$slots, "footer", {}, () => [
            (b(), I(re(a.value), {
              width: o.footerWidth,
              animation: o.footerAnimation,
              size: e.noButton ? o.footerSize : void 0,
              variant: o.footerVariant
            }, null, 8, ["width", "animation", "size", "variant"]))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), qd = "300px", ol = /* @__PURE__ */ H({
  __name: "BTableSimple",
  props: {
    bordered: { type: Boolean, default: !1 },
    borderless: { type: Boolean, default: !1 },
    borderVariant: { default: null },
    captionTop: { type: Boolean, default: !1 },
    dark: { type: Boolean, default: !1 },
    fixed: { type: Boolean, default: !1 },
    hover: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: !1 },
    outlined: { type: Boolean, default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: Boolean, default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    stickyHeader: { type: [Boolean, String, Number], default: !1 },
    striped: { type: Boolean, default: !1 },
    stripedColumns: { type: Boolean, default: !1 },
    tableClass: { default: void 0 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => [
      e.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": e.bordered,
        "table-borderless": e.borderless,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "caption-top": e.captionTop,
        "table-dark": e.dark,
        "table-hover": e.hover,
        "b-table-stacked": e.stacked === !0,
        [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
        "table-striped": e.striped,
        "table-sm": e.small,
        [`table-${e.variant}`]: e.variant !== null,
        "table-striped-columns": e.stripedColumns
      }
    ]), a = B(() => ({
      id: e.id,
      class: l.value
    })), o = ia(
      B(
        () => (e.stickyHeader === !0 ? qd : e.stickyHeader) || NaN
      )
    ), r = B(() => e.stickyHeader !== !1), n = B(() => e.responsive !== !1 || r.value), s = B(
      () => r.value ? { maxHeight: o.value } : void 0
    ), i = B(() => ({
      "table-responsive": e.responsive === !0,
      [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
      "b-table-sticky-header": r.value
    }));
    return (u, d) => n.value ? (b(), V("div", {
      key: 0,
      class: D(i.value),
      style: Ee(s.value)
    }, [
      Z("table", me(we(a.value)), [
        T(u.$slots, "default")
      ], 16)
    ], 6)) : (b(), V("table", me(X({ key: 1 }, a.value)), [
      T(u.$slots, "default")
    ], 16));
  }
}), Wd = /* @__PURE__ */ H({
  __name: "BPlaceholderTable",
  props: {
    animation: { default: void 0 },
    cellWidth: { default: 100 },
    columns: { default: 5 },
    footerAnimation: { default: void 0 },
    footerCellWidth: { default: 100 },
    footerColumns: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerCellWidth: { default: 100 },
    headerColumns: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    hideHeader: { type: Boolean, default: !1 },
    rows: { default: 3 },
    showFooter: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, l = be(() => e.columns), a = be(() => e.rows), o = $(() => e.headerColumns ?? NaN), r = $(() => e.footerColumns ?? NaN), n = be(o), s = be(r), i = $(() => l.value || 5), u = $(() => a.value || 3), d = $(
      () => e.headerColumns === void 0 ? i.value : n.value
    ), p = $(
      () => e.footerColumns === void 0 ? i.value : s.value
    );
    return (f, m) => (b(), I(ol, null, {
      default: P(() => [
        e.hideHeader ? ae("", !0) : T(f.$slots, "thead", { key: 0 }, () => [
          Z("thead", null, [
            Z("tr", null, [
              (b(!0), V(de, null, Ce(d.value, (y, c) => (b(), V("th", { key: c }, [
                ve(je, {
                  size: f.headerSize,
                  variant: f.headerVariant,
                  animation: f.headerAnimation,
                  width: f.headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        T(f.$slots, "default", {}, () => [
          Z("tbody", null, [
            (b(!0), V(de, null, Ce(u.value, (y, c) => (b(), V("tr", { key: c }, [
              (b(!0), V(de, null, Ce(i.value, (g, v) => (b(), V("td", { key: v }, [
                ve(je, {
                  size: f.size,
                  variant: f.variant,
                  animation: f.animation,
                  width: f.cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        e.showFooter ? T(f.$slots, "tfoot", { key: 1 }, () => [
          Z("tfoot", null, [
            Z("tr", null, [
              (b(!0), V(de, null, Ce(p.value, (y, c) => (b(), V("th", { key: c }, [
                ve(je, {
                  size: f.footerSize,
                  variant: f.footerVariant,
                  animation: f.footerAnimation,
                  width: f.footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : ae("", !0)
      ]),
      _: 3
    }));
  }
}), Gd = /* @__PURE__ */ H({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t;
    return (l, a) => e.loading ? T(l.$slots, "loading", { key: 0 }) : T(l.$slots, "default", { key: 1 });
  }
}), Hl = fa("cols", [""], { type: [String, Number], default: null }), Ud = H({
  name: "BRow",
  slots: Object,
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: Boolean, default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Hl
  },
  setup(t) {
    const e = Dt(() => t.alignH), l = B(() => Bo(t, Hl, "cols", "row-cols"));
    return {
      computedClasses: B(() => [
        l.value,
        {
          [`gx-${t.gutterX}`]: t.gutterX !== null,
          [`gy-${t.gutterY}`]: t.gutterY !== null,
          "g-0": t.noGutters,
          [`align-items-${t.alignV}`]: t.alignV !== null,
          [e.value]: t.alignH !== null,
          [`align-content-${t.alignContent}`]: t.alignContent !== null
        }
      ])
    };
  }
});
function Xd(t, e, l, a, o, r) {
  return b(), I(re(t.tag), {
    class: D(["row", t.computedClasses])
  }, {
    default: P(() => [
      T(t.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Kd = /* @__PURE__ */ qt(Ud, [["render", Xd]]), ot = (t) => typeof t == "object" && t !== null, Ia = (t) => typeof t == "object" && t !== null && "key" in t, wn = /* @__PURE__ */ H({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`thead-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), V("tbody", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), Yd = ["scope", "colspan", "rowspan", "data-label"], Jd = { key: 0 }, St = /* @__PURE__ */ H({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = $(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (o, r) => (b(), V("td", {
      scope: a.value,
      class: D(l.value),
      colspan: o.colspan,
      rowspan: o.rowspan,
      "data-label": o.stackedHeading
    }, [
      o.stackedHeading ? (b(), V("div", Jd, [
        T(o.$slots, "default")
      ])) : T(o.$slots, "default", { key: 1 })
    ], 10, Yd));
  }
}), Pa = /* @__PURE__ */ H({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), V("tfoot", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), Zd = ["scope", "colspan", "rowspan", "data-label"], Qd = { key: 0 }, Ea = /* @__PURE__ */ H({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = $(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (o, r) => (b(), V("th", {
      scope: a.value,
      class: D(l.value),
      colspan: o.colspan,
      rowspan: o.rowspan,
      "data-label": o.stackedHeading
    }, [
      o.stackedHeading !== void 0 ? (b(), V("div", Qd, [
        T(o.$slots, "default")
      ])) : T(o.$slots, "default", { key: 1 })
    ], 10, Zd));
  }
}), Cn = /* @__PURE__ */ H({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), V("thead", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), Ye = /* @__PURE__ */ H({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = B(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), V("tr", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), ec = {
  key: 0,
  class: "b-table-stacked-label"
}, tc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, ac = { key: 2 }, kn = /* @__PURE__ */ H({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: "There are no records matching your request" },
    emptyText: { default: "There are no records to show" },
    fieldColumnClass: { type: [Function, String, Object], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: !1 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: !1 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: !1 },
    tbodyClass: { default: void 0 },
    tbodyTrAttr: { default: void 0 },
    tbodyTrClass: { type: [Function, String, Object], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    tableClass: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = x(JSON.parse(JSON.stringify(l.items)));
    ue(
      () => l.items,
      (c) => {
        o.value = JSON.parse(JSON.stringify(c));
      }
    );
    const r = B(() => [
      l.tableClass,
      {
        [`align-${l.align}`]: l.align !== void 0
      }
    ]), n = B(() => {
      if (!l.fields.length && o.value.length) {
        const [c] = o.value;
        return ot(c) || Array.isArray(c) ? Object.keys(c).map((g) => {
          const v = ya(g);
          return {
            key: g,
            label: v,
            tdAttr: l.stacked === !0 ? { "data-label": v } : void 0
          };
        }) : [{ key: "", _noHeader: !0 }];
      }
      return l.fields.map((c) => {
        if (Ia(c))
          return {
            ...c,
            tdAttr: l.stacked === !0 ? { "data-label": ya(c.key), ...c.tdAttr } : c.tdAttr
          };
        const g = ya(c);
        return {
          key: c,
          label: g,
          tdAttr: l.stacked === !0 ? { "data-label": g } : void 0
        };
      });
    }), s = $(() => n.value.length), i = B(() => !(n.value.length > 0 && n.value.every((c) => c._noHeader === !0))), u = (c, g, v) => {
      const h = Je(c, g);
      return v && typeof v == "function" ? v(h, g, c) : v;
    }, d = (c, g, v = !1) => {
      a("head-clicked", c.key, c, g, v);
    }, p = (c) => {
      ot(c) && (c._showDetails = !c._showDetails);
    }, f = (c) => [
      c.class,
      c.thClass,
      {
        "b-table-sticky-column": c.stickyColumn
      },
      l.fieldColumnClass ? typeof l.fieldColumnClass == "function" ? l.fieldColumnClass(c) : l.fieldColumnClass : null
    ], m = (c, g) => {
      var v, h;
      return [
        c.class,
        c.tdClass,
        ot(g) && (v = g._cellVariants) != null && v[c.key] ? `table-${(h = g._cellVariants) == null ? void 0 : h[c.key]}` : null,
        {
          "b-table-sticky-column": c.stickyColumn
        }
      ];
    }, y = (c, g) => l.tbodyTrClass ? typeof l.tbodyTrClass == "function" ? l.tbodyTrClass(c, g) : l.tbodyTrClass : null;
    return (c, g) => (b(), I(ol, {
      id: c.id,
      bordered: c.bordered,
      borderless: c.borderless,
      "border-variant": c.borderVariant,
      "caption-top": c.captionTop,
      dark: c.dark,
      fixed: c.fixed,
      hover: c.hover,
      "no-border-collapse": c.noBorderCollapse,
      outlined: c.outlined,
      responsive: c.responsive,
      small: c.small,
      stacked: l.stacked,
      "sticky-header": c.stickyHeader,
      striped: c.striped,
      "table-class": r.value,
      variant: c.variant,
      "striped-columns": c.stripedColumns
    }, {
      default: P(() => [
        ut(ve(Cn, {
          variant: c.headVariant,
          class: D(c.theadClass)
        }, {
          default: P(() => [
            c.$slots["thead-top"] ? T(c.$slots, "thead-top", { key: 0 }) : ae("", !0),
            ve(Ye, {
              variant: c.headRowVariant,
              class: D(c.theadTrClass)
            }, {
              default: P(() => [
                (b(!0), V(de, null, Ce(n.value, (v) => (b(), I(Ea, X({
                  key: v.key,
                  scope: "col",
                  class: f(v),
                  title: v.headerTitle,
                  variant: v.variant,
                  abbr: v.headerAbbr,
                  style: v.thStyle
                }, v.thAttr, {
                  onClick: (h) => d(v, h)
                }), {
                  default: P(() => [
                    T(c.$slots, c.$slots[`head(${String(v.key)})`] ? `head(${String(v.key)})` : "head()", {
                      label: v.label,
                      column: v.key,
                      field: v,
                      isFoot: !1
                    }, () => [
                      se(Y(O(Zt)(v)), 1)
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "variant", "abbr", "style", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"]),
            c.$slots["thead-sub"] ? (b(), I(Ye, { key: 1 }, {
              default: P(() => [
                (b(!0), V(de, null, Ce(n.value, (v) => (b(), I(St, {
                  key: v.key,
                  scope: "col",
                  variant: v.variant,
                  class: D([v.class, v.thClass])
                }, {
                  default: P(() => [
                    T(c.$slots, "thead-sub", X({ items: n.value }, v), () => [
                      se(Y(v.label), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["variant", "class"]))), 128))
              ]),
              _: 3
            })) : ae("", !0)
          ]),
          _: 3
        }, 8, ["variant", "class"]), [
          [xt, i.value]
        ]),
        ve(wn, {
          class: D(c.tbodyClass)
        }, {
          default: P(() => [
            T(c.$slots, "custom-body", {
              fields: n.value,
              items: o.value,
              columns: n.value.length
            }, () => [
              !l.stacked && c.$slots["top-row"] ? (b(), I(Ye, { key: 0 }, {
                default: P(() => [
                  T(c.$slots, "top-row")
                ]),
                _: 3
              })) : ae("", !0),
              (b(!0), V(de, null, Ce(o.value, (v, h) => (b(), V(de, { key: h }, [
                ve(Ye, {
                  class: D(y(v, "row")),
                  variant: O(ot)(v) ? v._rowVariant : void 0,
                  onClick: (k) => !O(Gt)(k) && a("row-clicked", v, h, k),
                  onDblclick: (k) => !O(Gt)(k) && a("row-dbl-clicked", v, h, k),
                  onMouseenter: (k) => !O(Gt)(k) && a("row-hovered", v, h, k),
                  onMouseleave: (k) => !O(Gt)(k) && a("row-unhovered", v, h, k)
                }, {
                  default: P(() => [
                    (b(!0), V(de, null, Ce(n.value, (k) => {
                      var C;
                      return b(), I(St, X({
                        key: k.key,
                        variant: O(ot)(v) && (C = v._cellVariants) != null && C[k.key] ? null : k.variant,
                        class: m(k, v)
                      }, u(v, String(k.key), k.tdAttr)), {
                        default: P(() => [
                          l.stacked && l.labelStacked ? (b(), V("label", ec, Y(O(Zt)(k)), 1)) : ae("", !0),
                          T(
                            c.$slots,
                            c.$slots[`cell(${String(k.key)})`] ? `cell(${String(k.key)})` : "cell()",
                            {
                              value: O(Je)(v, String(k.key)),
                              index: h,
                              item: v,
                              field: k,
                              items: o.value,
                              toggleDetails: () => {
                                p(v);
                              },
                              detailsShowing: O(ot)(v) ? v._showDetails ?? !1 : !1
                            },
                            () => [
                              !c.$slots[`cell(${String(k.key)})`] && !c.$slots["cell()"] ? (b(), V(de, { key: 0 }, [
                                se(Y(O(ho)(v, String(k.key), k.formatter)), 1)
                              ], 64)) : ae("", !0)
                            ]
                          )
                        ]),
                        _: 2
                      }, 1040, ["variant", "class"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "variant", "onClick", "onDblclick", "onMouseenter", "onMouseleave"]),
                O(ot)(v) && v._showDetails === !0 && c.$slots["row-details"] ? (b(), V(de, { key: 0 }, [
                  ve(Ye, {
                    "aria-hidden": "true",
                    role: "presentation",
                    class: "d-none"
                  }),
                  ve(Ye, {
                    class: D(y(v, "row-details")),
                    variant: v._rowVariant
                  }, {
                    default: P(() => [
                      ve(St, { colspan: s.value }, {
                        default: P(() => [
                          T(c.$slots, "row-details", {
                            item: v,
                            toggleDetails: () => {
                              p(v);
                            },
                            fields: c.fields,
                            index: h
                          })
                        ]),
                        _: 2
                      }, 1032, ["colspan"])
                    ]),
                    _: 2
                  }, 1032, ["class", "variant"])
                ], 64)) : ae("", !0)
              ], 64))), 128)),
              l.showEmpty && o.value.length === 0 ? (b(), I(Ye, {
                key: 1,
                class: "b-table-empty-slot"
              }, {
                default: P(() => [
                  ve(St, { colspan: s.value }, {
                    default: P(() => [
                      T(c.$slots, "empty", { items: o.value }, () => [
                        se(Y(c.emptyText), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["colspan"])
                ]),
                _: 3
              })) : ae("", !0),
              !l.stacked && c.$slots["bottom-row"] ? (b(), I(Ye, { key: 2 }, {
                default: P(() => [
                  T(c.$slots, "bottom-row")
                ]),
                _: 3
              })) : ae("", !0)
            ])
          ]),
          _: 3
        }, 8, ["class"]),
        l.footClone ? (b(), I(Pa, {
          key: 0,
          variant: c.footVariant,
          class: D(c.tfootClass)
        }, {
          default: P(() => [
            ve(Ye, {
              variant: c.footRowVariant,
              class: D(c.tfootTrClass)
            }, {
              default: P(() => [
                (b(!0), V(de, null, Ce(n.value, (v) => (b(), I(Ea, X({
                  key: v.key,
                  scope: "col",
                  class: f(v),
                  title: v.headerTitle,
                  abbr: v.headerAbbr,
                  style: v.thStyle,
                  variant: v.variant
                }, v.thAttr, {
                  onClick: (h) => d(v, h, !0)
                }), {
                  default: P(() => [
                    Z("div", tc, [
                      Z("div", null, [
                        T(
                          c.$slots,
                          c.$slots[`foot(${String(v.key)})`] ? `foot(${String(v.key)})` : "foot()",
                          {
                            label: v.label,
                            column: v.key,
                            field: v,
                            isFoot: !0
                          },
                          () => [
                            se(Y(O(Zt)(v)), 1)
                          ]
                        )
                      ])
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "abbr", "style", "variant", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"])
          ]),
          _: 3
        }, 8, ["variant", "class"])) : c.$slots["custom-foot"] ? (b(), I(Pa, { key: 1 }, {
          default: P(() => [
            T(c.$slots, "custom-foot", {
              fields: n.value,
              items: o.value,
              columns: n.value.length
            })
          ]),
          _: 3
        })) : ae("", !0),
        c.$slots["table-caption"] || c.caption ? (b(), V("caption", ac, [
          T(c.$slots, "table-caption", {}, () => [
            se(Y(c.caption), 1)
          ])
        ])) : ae("", !0)
      ]),
      _: 3
    }, 8, ["id", "bordered", "borderless", "border-variant", "caption-top", "dark", "fixed", "hover", "no-border-collapse", "outlined", "responsive", "small", "stacked", "sticky-header", "striped", "table-class", "variant", "striped-columns"]));
  }
}), lc = /* @__PURE__ */ Z("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ Z("path", {
    "fill-rule": "evenodd",
    d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
  })
], -1), oc = /* @__PURE__ */ Z("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-down-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ Z("path", {
    "fill-rule": "evenodd",
    d: "M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"
  })
], -1), nc = {
  style: { opacity: 0.4 },
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, sc = /* @__PURE__ */ Z("path", {
  "fill-rule": "evenodd",
  d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
}, null, -1), rc = [
  sc
], ic = { class: "d-flex align-items-center gap-2 mt-5" }, uc = /* @__PURE__ */ H({
  __name: "BTable",
  props: /* @__PURE__ */ pe({
    provider: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: Boolean, default: !1 },
    noProviderSorting: { type: Boolean, default: !1 },
    noProviderFiltering: { type: Boolean, default: !1 },
    sortBy: {},
    mustSort: { type: [Boolean, Array], default: !1 },
    noSortReset: { type: Boolean },
    selectable: { type: Boolean, default: !1 },
    multisort: { type: Boolean, default: !1 },
    stickySelect: { type: Boolean, default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "multi" },
    selectionVariant: { default: "primary" },
    busy: { type: Boolean },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: Number.POSITIVE_INFINITY },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    noLocalSorting: { type: Boolean, default: !1 },
    noSelectOnClick: { type: Boolean, default: !1 },
    selectedItems: {},
    noSortableIcon: { type: Boolean, default: !1 },
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: void 0 },
    emptyText: { default: void 0 },
    fieldColumnClass: { type: [Function, String, Object], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: void 0 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: void 0 },
    tbodyClass: { default: void 0 },
    tbodyTrAttr: { default: void 0 },
    tbodyTrClass: { type: [Function, String, Object], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 }
  }, {
    sortBy: {
      default: void 0
    },
    sortByModifiers: {},
    busy: { type: Boolean, default: !1 },
    busyModifiers: {},
    selectedItems: {
      default: () => []
    },
    selectedItemsModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["filtered", "head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "selection", "sorted"], ["update:sortBy", "update:busy", "update:selectedItems"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "sortBy"), n = he(t, "busy"), s = he(t, "selectedItems"), i = B({
      get: () => /* @__PURE__ */ new Set([...s.value]),
      set: (S) => {
        s.value = [...S];
      }
    }), u = {
      add: (S) => {
        const E = new Set(i.value);
        E.add(S), i.value = E, o("row-selected", S);
      },
      clear: () => {
        i.value.forEach((S) => {
          u.delete(S);
        });
      },
      delete: (S) => {
        const E = new Set(i.value);
        E.delete(S), i.value = E, o("row-unselected", S);
      },
      /* TODO
      This has method and the delete method suffer from an error when using a non-reactive source as the items prop
      ```ts
      const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]
      ```
      For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine
      Getting the reference properly will fix all outstanding issues
      */
      has: (S) => {
        if (!a.primaryKey)
          return i.value.has(S);
        const E = a.primaryKey;
        for (const M of i.value) {
          const j = Je(M, E), A = Je(S, E);
          if (j && A && j === A)
            return !0;
        }
        return !1;
      }
    }, d = x([]), p = be(() => a.perPage, { method: "parseInt" }), f = be(() => a.currentPage, { method: "parseInt" }), m = $(() => !!a.filter), y = $(() => a.provider !== void 0), c = $(() => i.value.size > 0), g = B(
      () => r.value !== void 0 || a.fields.some(
        (S) => typeof S == "object" && S !== null && S.sortable === !0
      )
    ), v = B(
      () => a.fields.map((S) => {
        var j;
        if (!(typeof S == "object" && S !== null))
          return S;
        const E = (j = r.value) == null ? void 0 : j.find((A) => S.key === A.key), M = g.value === !1 ? void 0 : E === void 0 ? "none" : E.order === "desc" ? "descending" : "ascending";
        return {
          ...S,
          thAttr: {
            "aria-sort": M,
            ...S.thAttr
          }
        };
      })
    ), h = B(() => ({
      "b-table-busy": n.value,
      "b-table-selectable": a.selectable,
      "user-select-none": a.selectable && c.value
    })), k = B(() => [
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(null, "table-busy") : a.tbodyTrClass : null
    ]), C = (S) => [
      {
        "b-table-sortable-column": g.value && S.sortable
      }
    ], w = (S, E) => [
      {
        [`selected table-${a.selectionVariant}`]: a.selectable && S && u.has(S)
      },
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(S, E) : a.tbodyTrClass : null
    ], _ = B(() => {
      const S = (j) => {
        var K;
        const A = (K = r.value) == null ? void 0 : K.filter((G) => !!G.order);
        return !A || A.length === 0 ? j : [...j].sort((G, ie) => {
          for (let q = 0; q < (A.length ?? 0); q++) {
            const ne = A[q], ge = (U) => {
              if (!ot(U))
                return String(U);
              const z = v.value.find((fe) => Ia(fe) ? fe.key === ne.key : !1), oe = U[ne.key];
              if (Ia(z) && z.sortByFormatted) {
                const fe = typeof z.sortByFormatted == "function" ? z.sortByFormatted : z.formatter;
                if (fe)
                  return ho(U, String(z.key), fe);
              }
              return typeof oe == "object" && oe !== null ? JSON.stringify(oe) : (oe == null ? void 0 : oe.toString()) ?? "";
            }, te = ge(G), ye = ge(ie), ee = ne.comparer ? ne.comparer(te, ye) : te.localeCompare(ye, void 0, { numeric: !0 });
            if (ee !== 0)
              return ne.order === "asc" ? ee : -ee;
          }
          return 0;
        });
      }, E = (j) => j.filter(
        (A) => ot(A) ? Object.entries(A).some(([K, G]) => {
          var q, ne, ge;
          return G == null || K[0] === "_" || !((q = a.filterable) != null && q.includes(K)) && ((ne = a.filterable) != null && ne.length) ? !1 : (typeof G == "object" ? JSON.stringify(Object.values(G)) : G.toString()).toLowerCase().includes(((ge = a.filter) == null ? void 0 : ge.toLowerCase()) ?? "");
        }) : !0
      );
      let M = y.value ? d.value : a.items;
      return M = M.map((j) => {
        if (typeof j == "object" && j !== null) {
          let A = {};
          for (const K in j)
            K.includes(".") ? A = Ir(A, K, j[K]) : A[K] = j[K];
          return A;
        }
        return j;
      }), (m.value === !0 && !y.value || m.value === !0 && y.value && a.noProviderFiltering) && (M = E(M)), (g.value === !0 && !y.value && !a.noLocalSorting || g.value === !0 && y.value && a.noProviderSorting) && (M = S(M)), M;
    }), F = B(() => Number.isNaN(p.value) || y.value && !a.noProviderPaging ? _.value : _.value.slice(
      (f.value - 1) * (p.value || Number.POSITIVE_INFINITY),
      f.value * (p.value || Number.POSITIVE_INFINITY)
    )), Q = (S, E, M = !1, j = !1, A = !1) => {
      if (a.selectable) {
        if (a.selectMode === "single" || a.selectMode === "multi") {
          if (M || j)
            return;
          u.has(S) ? u.delete(S) : (a.selectMode === "single" && u.clear(), u.add(S));
        } else if (j || A)
          u.has(S) ? u.delete(S) : u.add(S);
        else if (M) {
          const K = [...i.value].pop(), G = a.items.findIndex((ne) => ne === K), ie = Math.min(G, E), q = Math.max(G, E);
          a.items.slice(ie, q + 1).forEach((ne) => {
            u.has(ne) || u.add(ne);
          });
        } else
          u.clear(), u.add(S);
        le();
      }
    }, W = (S, E, M) => {
      a.noSelectOnClick === !1 && Q(S, E, M.shiftKey, M.ctrlKey, M.metaKey), o("row-clicked", S, E, M);
    }, L = (S) => {
      var ne, ge;
      if (!g.value)
        return;
      const E = typeof S == "object" && S !== null ? S.key : S, M = typeof S == "object" && S !== null ? S.sortable : !1;
      if (!(g.value === !0 && M === !0))
        return;
      const j = (te) => {
        if (te === "asc")
          return "desc";
        if (te === void 0 || a.mustSort === !0 || Array.isArray(a.mustSort) && a.mustSort.includes(E))
          return "asc";
      }, A = ((ne = r.value) == null ? void 0 : ne.findIndex((te) => te.key === E)) ?? -1, K = (ge = r.value) == null ? void 0 : ge[A], G = (
        // If value is new, we default to ascending
        // Otherwise we make a temp copy of the value
        A === -1 || !K ? { key: E, order: "asc" } : { ...K }
      ), ie = () => {
        var ye, ee;
        let te = G;
        if (A === -1)
          r.value = [...r.value ?? [], G];
        else {
          const U = j(G.order);
          te = { ...G, order: U }, r.value = U ? (ye = r.value) == null ? void 0 : ye.map((z) => z.key === te.key ? te : z) : (ee = r.value) == null ? void 0 : ee.filter((z) => z.key !== te.key);
        }
        return te;
      }, q = () => {
        const te = {
          ...G,
          order: A === -1 ? G.order : j(G.order)
        };
        return r.value = [te], te;
      };
      o("sorted", a.multisort === !0 ? ie() : q());
    }, J = (S, E, M, j = !1) => {
      o("head-clicked", S, E, M, j), L(E);
    }, R = async () => {
      if (!y.value || a.provider === void 0 || n.value)
        return;
      n.value = !0;
      const S = a.provider({
        currentPage: f.value,
        filter: a.filter,
        sortBy: r.value,
        perPage: p.value
      });
      try {
        const E = S instanceof Promise ? await S : S;
        if (E === void 0)
          return;
        d.value = E;
      } finally {
        n.value = !1;
      }
    }, le = () => {
      a.selectable && o("selection", [...i.value]);
    }, N = async (S, E, M) => {
      if (E === M)
        return;
      const j = (ie) => {
        var q;
        return ((q = a.noProvider) == null ? void 0 : q.includes(ie)) === !0;
      }, A = (S === "currentPage" || S === "perPage") && (j("paging") || a.noProviderPaging === !0), K = S === "filter" && (j("filtering") || a.noProviderFiltering === !0), G = (S === "sortBy" || S === "sortDesc") && (j("sorting") || a.noProviderSorting === !0);
      A || K || G || (y.value === !0 && await R(), S === "currentPage" || S === "perPage" || o("filtered", [..._.value]));
    };
    return ue(
      () => a.filter,
      (S, E) => {
        N("filter", S, E), !(S === E || y.value) && (S || o("filtered", [..._.value]));
      }
    ), ue(f, (S, E) => {
      N("currentPage", S, E);
    }), ue(p, (S, E) => {
      N("perPage", S, E);
    }), ue(
      r,
      (S, E) => {
        N("sortBy", S, E);
      },
      { deep: !0 }
    ), ue(
      () => a.provider,
      (S) => {
        if (S === void 0) {
          d.value = [];
          return;
        }
        R();
      }
    ), Xe(R), e({
      // The row selection methods are really for compat. Users should probably use the v-model though
      clearSelected: () => {
        a.selectable && (u.clear(), le());
      },
      refresh: R,
      selectAllRows: () => {
        if (!a.selectable)
          return;
        const S = i.value.size > 0 ? [...i.value] : [];
        i.value = /* @__PURE__ */ new Set([..._.value]), i.value.forEach((E) => {
          S.includes(E) || o("row-selected", E);
        }), le();
      },
      selectRow: (S) => {
        if (!a.selectable)
          return;
        const E = _.value[S];
        !E || u.has(E) || (u.add(E), le());
      },
      unselectRow: (S) => {
        if (!a.selectable)
          return;
        const E = _.value[S];
        !E || !u.has(E) || (u.delete(E), le());
      }
    }), (S, E) => (b(), I(kn, X(a, {
      "aria-busy": n.value,
      items: F.value,
      fields: v.value,
      "table-class": h.value,
      "tbody-tr-class": w,
      "field-column-class": C,
      onHeadClicked: J,
      onRowDblClicked: E[0] || (E[0] = (M, j, A) => {
        o("row-dbl-clicked", M, j, A);
      }),
      onRowClicked: W,
      onRowHovered: E[1] || (E[1] = (M, j, A) => {
        o("row-hovered", M, j, A);
      }),
      onRowUnhovered: E[2] || (E[2] = (M, j, A) => {
        o("row-unhovered", M, j, A);
      })
    }), Fa({
      "head()": P((M) => {
        var j, A, K, G;
        return [
          se(Y(O(Zt)(M.field)) + " ", 1),
          g.value && M.field.sortable && a.noSortableIcon === !1 ? (b(), V(de, { key: 0 }, [
            ((A = (j = r.value) == null ? void 0 : j.find((ie) => ie.key === M.field.key)) == null ? void 0 : A.order) === "asc" ? T(
              S.$slots,
              S.$slots[`sortAsc(${String(M.field.key)})`] ? `sortAsc(${String(M.field.key)})` : "sortAsc()",
              me(X({ key: 0 }, { ...M })),
              () => [
                lc
              ]
            ) : ((G = (K = r.value) == null ? void 0 : K.find((ie) => ie.key === M.field.key)) == null ? void 0 : G.order) === "desc" ? T(
              S.$slots,
              S.$slots[`sortDesc(${String(M.field.key)})`] ? `sortDesc(${String(M.field.key)})` : "sortDesc()",
              me(X({ key: 1 }, { ...M })),
              () => [
                oc
              ]
            ) : T(
              S.$slots,
              S.$slots[`sortDefault(${String(M.field.key)})`] ? `sortDefault(${String(M.field.key)})` : "sortDefault()",
              me(X({ key: 2 }, { ...M })),
              () => [
                (b(), V("svg", nc, rc))
              ]
            )
          ], 64)) : ae("", !0)
        ];
      }),
      "custom-body": P((M) => [
        n.value ? (b(), I(Ye, {
          key: 0,
          class: D(["b-table-busy-slot", k.value])
        }, {
          default: P(() => [
            ve(St, {
              colspan: M.fields.length
            }, {
              default: P(() => [
                T(S.$slots, "table-busy", {}, () => [
                  ve(ma, { show: "" }, {
                    overlay: P(() => [
                      Z("div", ic, [
                        ve(pa),
                        Z("strong", null, Y(S.busyLoadingText), 1)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 2
            }, 1032, ["colspan"])
          ]),
          _: 2
        }, 1032, ["class"])) : ae("", !0)
      ]),
      _: 2
    }, [
      Ce(S.$slots, (M, j) => ({
        name: j,
        fn: P((A) => [
          T(S.$slots, j, me(we(A)))
        ])
      }))
    ]), 1040, ["aria-busy", "items", "fields", "table-class"]));
  }
}), dc = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BTab",
  props: /* @__PURE__ */ pe({
    active: { type: Boolean },
    buttonId: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    lazyOnce: { type: Boolean, default: void 0 },
    noBody: { type: Boolean, default: !1 },
    tag: { default: "div" },
    title: { default: void 0 },
    titleItemClass: { default: void 0 },
    titleLinkAttrs: { default: void 0 },
    titleLinkClass: { default: void 0 }
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: ["update:active"],
  setup(t) {
    const e = t, l = Fe(), a = he(t, "active"), o = Ve($o, null), r = Be(() => e.id, "tabpane"), n = Be(() => e.buttonId, "tab"), s = x(!1), i = x(null), { onClick: u, ...d } = Mt(), p = B(
      () => ({
        id: r.value,
        buttonId: n.value,
        disabled: e.disabled,
        title: e.title,
        titleComponent: l.title,
        titleItemClass: e.titleItemClass,
        titleLinkAttrs: e.titleLinkAttrs,
        titleLinkClass: e.titleLinkClass,
        onClick: u,
        el: i.value
      })
    );
    Xe(() => {
      o && (o.registerTab(p), e.active && o.activateTab(r.value));
    }), En(() => {
      o && o.unregisterTab(r.value);
    });
    const f = $(() => (o == null ? void 0 : o.activeId.value) === r.value), m = x(f.value), y = $(() => !!(o != null && o.lazy.value || (e.lazyOnce ?? e.lazy))), c = $(() => e.lazyOnce !== void 0), g = $(() => f.value && !e.disabled), v = $(
      () => g.value || !y.value || y.value && c.value && s.value
    );
    ue(f, (k) => {
      if (k) {
        a.value = !0, setTimeout(() => {
          m.value = !0;
        }, 0);
        return;
      }
      m.value = !1, a.value = !1;
    }), ue(
      () => e.active,
      (k) => {
        if (o) {
          if (!k) {
            f.value && o.activateTab(void 0);
            return;
          }
          o.activateTab(r.value);
        }
      }
    );
    const h = B(() => [
      {
        active: f.value,
        show: m.value,
        "card-body": (o == null ? void 0 : o.card.value) && e.noBody === !1,
        fade: !(o != null && o.noFade.value)
      },
      m.value ? o == null ? void 0 : o.activeTabClass : o == null ? void 0 : o.inactiveTabClass,
      o == null ? void 0 : o.tabClass
    ]);
    return ue(v, (k) => {
      k && !s.value && (s.value = !0);
    }), (k, C) => (b(), I(re(k.tag), X({
      id: O(r),
      ref_key: "el",
      ref: i,
      class: ["tab-pane", h.value],
      role: "tabpanel",
      "aria-labelledby": O(n)
    }, d), {
      default: P(() => [
        v.value ? T(k.$slots, "default", { key: 0 }) : ae("", !0)
      ]),
      _: 3
    }, 16, ["id", "class", "aria-labelledby"]));
  }
}), cc = ["aria-orientation"], fc = ["id", "aria-controls", "aria-selected", "onClick"], vc = /* @__PURE__ */ H({
  __name: "BTabs",
  props: /* @__PURE__ */ pe({
    activeId: {},
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    end: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inactiveNavItemClass: { default: void 0 },
    inactiveTabClass: { default: void 0 },
    justified: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    modelValue: {},
    navClass: { default: void 0 },
    navItemClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    noNavStyle: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "div" },
    tabClass: { default: void 0 },
    vertical: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: -1
    },
    modelModifiers: {},
    activeId: {
      default: void 0
    },
    activeIdModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["activate-tab", "click"], ["update:modelValue", "update:activeId"]),
  setup(t, { emit: e }) {
    const l = t, a = e, o = he(t, "modelValue"), r = he(t, "activeId"), n = zt(), s = x([]), i = B(
      () => s.value.map((C) => {
        const w = O(C), _ = w.id === r.value;
        return {
          ...w,
          active: _,
          navItemClasses: [
            {
              active: _,
              disabled: w.disabled
            },
            _ ? l.activeNavItemClass : l.inactiveNavItemClass,
            l.navItemClass,
            w.titleLinkClass
          ]
        };
      })
    ), u = $(() => !(i != null && i.value && i.value.length > 0)), d = B(() => ({
      "d-flex": l.vertical,
      "align-items-start": l.vertical
    })), p = Dt(() => l.align), f = B(() => ({
      "nav-pills": l.pills,
      "flex-column me-3": l.vertical,
      [p.value]: l.align !== void 0,
      "nav-fill": l.fill,
      "card-header-tabs": l.card,
      "nav-justified": l.justified,
      "nav-tabs": !l.noNavStyle && !l.pills,
      small: l.small
    })), m = (C) => {
      var w;
      if (C !== void 0) {
        const _ = (w = i.value[C]) == null ? void 0 : w.id;
        if (C > -1 && C < i.value.length && !i.value[C].disabled && (o.value < 0 || r.value !== _ || o.value !== C)) {
          const F = new nt("activate-tab", { cancelable: !0 });
          a("activate-tab", C, o.value, F), F.defaultPrevented || (r.value !== _ && (r.value = _), o.value !== C && (o.value = C));
        }
      }
    }, y = (C, w) => {
      var _, F, Q;
      m(w), w >= 0 && !i.value[w].disabled && ((_ = i.value[w]) != null && _.onClick) && typeof i.value[w].onClick == "function" && ((Q = (F = i.value[w]).onClick) == null || Q.call(F, C));
    }, c = (C) => {
      var w, _;
      i.value.length <= 0 || (o.value = g(o.value + C, C), (_ = document.getElementById((w = i.value[o.value]) == null ? void 0 : w.buttonId)) == null || _.focus());
    }, g = (C, w) => {
      let _ = C, F = -1, Q = -1;
      for (let W = 0; W < i.value.length; W++)
        i.value[W].disabled || (F === -1 && (F = W), Q = W);
      for (; _ >= F && _ <= Q && i.value[_].disabled; )
        _ += w;
      return _ < F && (_ = F), _ > Q && (_ = Q), _;
    };
    ue(o, (C, w) => {
      if (C === w || i.value.length <= 0)
        return;
      const _ = g(C, C > w ? 1 : -1);
      _e(() => {
        m(_);
      });
    }), ue(r, (C, w) => {
      const _ = i.value.findIndex((F) => F.id === C);
      if (C !== w && !(i.value.length <= 0)) {
        if (_ === -1) {
          m(g(0, 1));
          return;
        }
        m(_);
      }
    });
    const v = (C) => {
      s.value.find((w) => w.value.id === C.value.id) ? s.value[s.value.findIndex((w) => w.value.id === C.value.id)] = C : s.value.push(C), s.value.sort((w, _) => {
        if (!Node || !w.value.el || !_.value.el)
          return 0;
        const F = w.value.el.compareDocumentPosition(_.value.el);
        return F & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : F & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
      });
    }, h = (C) => {
      s.value = s.value.filter((w) => w.value.id !== C);
    };
    ue(
      s,
      () => {
        k();
      },
      { deep: !0 }
    );
    const k = () => {
      var C;
      if (i.value.length === 0) {
        o.value = -1, r.value = void 0;
        return;
      }
      if (o.value >= 0 && !r.value && (r.value = (C = i.value[o.value]) == null ? void 0 : C.id), i.value.find((w) => w.id === r.value)) {
        m(i.value.findIndex((w) => w.id === r.value));
        return;
      }
      m(i.value.map((w) => !w.disabled).indexOf(!0));
    };
    return tt($o, {
      lazy: $(() => l.lazy),
      card: $(() => l.card),
      noFade: $(() => l.noFade),
      activeTabClass: $(() => l.activeTabClass),
      inactiveTabClass: $(() => l.inactiveTabClass),
      tabClass: $(() => l.tabClass),
      registerTab: v,
      unregisterTab: h,
      activeId: r,
      activateTab: (C) => {
        const w = i.value.findIndex((_) => _.id === C);
        if (C === void 0 || w === -1) {
          m(g(0, 1));
          return;
        }
        m(w);
      }
    }), (C, w) => (b(), I(re(C.tag), {
      id: C.id,
      class: D(["tabs", d.value])
    }, {
      default: P(() => [
        ve(O(n).define, null, {
          default: P(() => [
            Z("div", {
              class: D(["tab-content", C.contentClass])
            }, [
              T(C.$slots, "default"),
              u.value ? (b(), V("div", {
                key: "bv-empty-tab",
                class: D(["tab-pane active", { "card-body": l.card }])
              }, [
                T(C.$slots, "empty")
              ], 2)) : ae("", !0)
            ], 2)
          ]),
          _: 3
        }),
        l.end ? (b(), I(O(n).reuse, { key: 0 })) : ae("", !0),
        Z("div", {
          class: D([C.navWrapperClass, { "card-header": l.card, "ms-auto": C.vertical && l.end }])
        }, [
          Z("ul", {
            class: D(["nav", [f.value, C.navClass]]),
            role: "tablist",
            "aria-orientation": C.vertical ? "vertical" : "horizontal"
          }, [
            T(C.$slots, "tabs-start"),
            (b(!0), V(de, null, Ce(i.value, (_, F) => (b(), V("li", {
              key: _.id,
              class: D(["nav-item", _.titleItemClass]),
              role: "presentation"
            }, [
              Z("button", X({
                id: _.buttonId,
                class: ["nav-link", _.navItemClasses],
                role: "tab",
                "aria-controls": _.id,
                "aria-selected": _.active
              }, _.titleLinkAttrs, {
                onKeydown: [
                  w[0] || (w[0] = Wt(ft((Q) => c(-1), ["stop", "prevent"]), ["left"])),
                  w[1] || (w[1] = Wt(ft((Q) => c(1), ["stop", "prevent"]), ["right"])),
                  w[2] || (w[2] = Wt(ft((Q) => c(-999), ["stop", "prevent"]), ["page-up"])),
                  w[3] || (w[3] = Wt(ft((Q) => c(999), ["stop", "prevent"]), ["page-down"]))
                ],
                onClick: ft((Q) => y(Q, F), ["stop", "prevent"])
              }), [
                _.titleComponent ? (b(), I(re(_.titleComponent), { key: 0 })) : (b(), V(de, { key: 1 }, [
                  se(Y(_.title), 1)
                ], 64))
              ], 16, fc)
            ], 2))), 128)),
            T(C.$slots, "tabs-end")
          ], 10, cc)
        ], 2),
        l.end ? ae("", !0) : (b(), I(O(n).reuse, { key: 1 }))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), pc = { id: "__BVID__toaster-container" }, mc = /* @__PURE__ */ H({
  __name: "BToastOrchestrator",
  props: {
    appendToast: { type: Boolean, default: !1 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(t, { expose: e }) {
    const l = t, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, { remove: o, toasts: r, show: n, _setIsAppend: s } = Yo();
    ue(
      () => l.appendToast,
      (u) => {
        s == null || s(u);
      },
      { immediate: !0 }
    );
    const i = (u) => va(u, ["_modelValue", "_self", "pos"]);
    return e({
      remove: o,
      show: n,
      toasts: r
    }), (u, d) => (b(), I(ht, {
      to: u.teleportTo,
      disabled: l.teleportDisabled
    }, [
      Z("div", pc, [
        (b(), V(de, null, Ce(a, (p, f) => Z("div", {
          key: f,
          class: D([p, "toast-container position-fixed p-3"])
        }, [
          ve(jl, { name: "b-list" }, {
            default: P(() => {
              var m;
              return [
                (b(!0), V(de, null, Ce((m = O(r)) == null ? void 0 : m.filter((y) => y.value.props.pos === f), (y) => (b(), I(re(y.value.component), X({
                  key: y.value.props._self
                }, i(y.value.props), {
                  modelValue: y.value.props._modelValue,
                  "onUpdate:modelValue": (c) => y.value.props._modelValue = c,
                  "trans-props": { ...y.value.props.transProps, appear: !0 },
                  onHide: ft((c) => {
                    var g;
                    return (g = O(o)) == null ? void 0 : g(y.value.props._self);
                  }, ["prevent"])
                }), null, 16, ["modelValue", "onUpdate:modelValue", "trans-props", "onHide"]))), 128))
              ];
            }),
            _: 2
          }, 1024)
        ], 2)), 64))
      ])
    ], 8, ["to", "disabled"]));
  }
}), bc = /* @__PURE__ */ H({
  __name: "BTooltip",
  props: /* @__PURE__ */ pe({
    interactive: { type: Boolean, default: void 0 },
    boundary: {},
    boundaryPadding: {},
    click: { type: Boolean, default: void 0 },
    content: { default: void 0 },
    customClass: { default: void 0 },
    delay: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    hide: { type: Boolean, default: void 0 },
    html: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: void 0 },
    manual: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: void 0 },
    noFade: { type: Boolean, default: void 0 },
    noFlip: { type: Boolean, default: void 0 },
    noHide: { type: Boolean, default: void 0 },
    noShift: { type: Boolean, default: void 0 },
    noSize: { type: Boolean },
    noninteractive: { type: Boolean, default: void 0 },
    offset: { default: void 0 },
    placement: { default: void 0 },
    persistent: { type: Boolean },
    realtime: { type: Boolean, default: void 0 },
    reference: { default: void 0 },
    strategy: { default: void 0 },
    target: { default: void 0 },
    title: { default: void 0 },
    variant: { default: void 0 },
    teleportDisabled: { default: void 0 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    var n, s, i;
    const l = t, a = he(t, "modelValue"), o = B(() => {
      const { interactive: u, noninteractive: d, ...p } = l;
      return { noninteractive: d !== void 0 ? d : !u, ...p };
    }), r = x(null);
    return e({
      hide: (n = r.value) == null ? void 0 : n.hide,
      show: (s = r.value) == null ? void 0 : s.show,
      toggle: (i = r.value) == null ? void 0 : i.toggle
    }), (u, d) => (b(), I(Xa, X({
      ref_key: "popover",
      ref: r
    }, o.value, {
      modelValue: a.value,
      "onUpdate:modelValue": d[0] || (d[0] = (p) => a.value = p),
      tooltip: ""
    }), Fa({ _: 2 }, [
      Ce(u.$slots, (p, f) => ({
        name: f,
        fn: P((m) => [
          T(u.$slots, f, me(we(m)))
        ])
      }))
    ]), 1040, ["modelValue"]));
  }
}), Rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ti,
  BAccordionItem: li,
  BAlert: ni,
  BAvatar: ui,
  BAvatarGroup: di,
  BBadge: ci,
  BBreadcrumb: pi,
  BBreadcrumbItem: tn,
  BButton: vt,
  BButtonGroup: mi,
  BButtonToolbar: yi,
  BCard: un,
  BCardBody: sn,
  BCardFooter: rn,
  BCardGroup: Bi,
  BCardHeader: ln,
  BCardImg: tl,
  BCardSubtitle: nn,
  BCardText: wi,
  BCardTitle: on,
  BCarousel: Ai,
  BCarouselSlide: Ei,
  BCloseButton: Pt,
  BCol: Lt,
  BCollapse: en,
  BContainer: zi,
  BDropdown: dn,
  BDropdownDivider: xi,
  BDropdownForm: ji,
  BDropdownGroup: Gi,
  BDropdownHeader: Xi,
  BDropdownItem: Ki,
  BDropdownItemButton: Zi,
  BDropdownText: eu,
  BForm: cn,
  BFormCheckbox: vn,
  BFormCheckboxGroup: uu,
  BFormFile: mu,
  BFormFloatingLabel: ou,
  BFormGroup: ku,
  BFormInput: Tu,
  BFormInvalidFeedback: _a,
  BFormRadio: mn,
  BFormRadioGroup: Ou,
  BFormRow: Qt,
  BFormSelect: Fu,
  BFormSelectOption: al,
  BFormSelectOptionGroup: bn,
  BFormSpinbutton: Mu,
  BFormTag: yn,
  BFormTags: td,
  BFormText: Aa,
  BFormTextarea: ld,
  BFormValidFeedback: Oa,
  BImg: el,
  BInputGroup: dd,
  BInputGroupAddon: ll,
  BInputGroupAppend: cd,
  BInputGroupPrepend: fd,
  BInputGroupText: gn,
  BLink: lt,
  BListGroup: vd,
  BListGroupItem: pd,
  BModal: Va,
  BModalOrchestrator: bd,
  BNav: yd,
  BNavForm: hd,
  BNavItem: wd,
  BNavItemDropdown: kd,
  BNavText: Td,
  BNavbar: Sd,
  BNavbarBrand: Vd,
  BNavbarNav: _d,
  BNavbarToggle: zd,
  BOffcanvas: Md,
  BOverlay: ma,
  BPagination: Dd,
  BPlaceholder: je,
  BPlaceholderButton: Bn,
  BPlaceholderCard: jd,
  BPlaceholderTable: Wd,
  BPlaceholderWrapper: Gd,
  BPopover: Xa,
  BProgress: Zo,
  BProgressBar: Jo,
  BRow: Kd,
  BSpinner: pa,
  BTab: dc,
  BTable: uc,
  BTableLite: kn,
  BTableSimple: ol,
  BTabs: vc,
  BTbody: wn,
  BTd: St,
  BTfoot: Pa,
  BTh: Ea,
  BThead: Cn,
  BToast: Qo,
  BToastOrchestrator: mc,
  BTooltip: bc,
  BTr: Ye,
  BTransition: It
}, Symbol.toStringTag, { value: "Module" })), hc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: Ho,
  useColorMode: Pr,
  useModal: zr,
  useModalController: Uo,
  useScrollspy: Ko,
  useToast: Yo
}, Symbol.toStringTag, { value: "Module" })), Bc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: ql,
  BvEvent: nt,
  BvTriggerableEvent: Bt
}, Symbol.toStringTag, { value: "Module" })), wc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Cc = ({
  components: t = !1,
  directives: e = !1,
  plugins: l = {}
} = {}) => ({
  install(a) {
    const o = typeof t == "boolean" ? { all: t } : t, r = Object.keys(Rl);
    Bl(o, r).forEach((u) => {
      const d = Rl[u];
      a.component(u, d);
    });
    const n = typeof e == "boolean" ? { all: e } : e, s = Object.keys(Ll), i = (u) => u.toLowerCase().startsWith("v") ? u.slice(1) : u;
    Bl(n, s).forEach((u) => {
      const d = i(u), p = Ll[u];
      a.directive(d, p);
    }), ((l == null ? void 0 : l.breadcrumb) ?? !0) && a.use(Wr), (((l == null ? void 0 : l.id) ?? !0) || typeof l.id == "object") && a.use(Gr, l), ((l == null ? void 0 : l.modalController) ?? !0) && a.use(Jr), ((l == null ? void 0 : l.modalManager) ?? !0) && a.use(Zr), (((l == null ? void 0 : l.rtl) ?? !0) || typeof l.rtl == "object") && a.use(Qr, l), ((l == null ? void 0 : l.toast) ?? !0) && a.use(qr);
  }
});
export {
  ti as BAccordion,
  li as BAccordionItem,
  ni as BAlert,
  ui as BAvatar,
  di as BAvatarGroup,
  ci as BBadge,
  pi as BBreadcrumb,
  tn as BBreadcrumbItem,
  vt as BButton,
  mi as BButtonGroup,
  yi as BButtonToolbar,
  un as BCard,
  sn as BCardBody,
  rn as BCardFooter,
  Bi as BCardGroup,
  ln as BCardHeader,
  tl as BCardImg,
  nn as BCardSubtitle,
  wi as BCardText,
  on as BCardTitle,
  Ai as BCarousel,
  Ei as BCarouselSlide,
  Pt as BCloseButton,
  Lt as BCol,
  en as BCollapse,
  zi as BContainer,
  dn as BDropdown,
  xi as BDropdownDivider,
  ji as BDropdownForm,
  Gi as BDropdownGroup,
  Xi as BDropdownHeader,
  Ki as BDropdownItem,
  Zi as BDropdownItemButton,
  eu as BDropdownText,
  cn as BForm,
  vn as BFormCheckbox,
  uu as BFormCheckboxGroup,
  mu as BFormFile,
  ou as BFormFloatingLabel,
  ku as BFormGroup,
  Tu as BFormInput,
  _a as BFormInvalidFeedback,
  mn as BFormRadio,
  Ou as BFormRadioGroup,
  Qt as BFormRow,
  Fu as BFormSelect,
  al as BFormSelectOption,
  bn as BFormSelectOptionGroup,
  Mu as BFormSpinbutton,
  yn as BFormTag,
  td as BFormTags,
  Aa as BFormText,
  ld as BFormTextarea,
  Oa as BFormValidFeedback,
  el as BImg,
  dd as BInputGroup,
  ll as BInputGroupAddon,
  cd as BInputGroupAppend,
  fd as BInputGroupPrepend,
  gn as BInputGroupText,
  lt as BLink,
  vd as BListGroup,
  pd as BListGroupItem,
  Va as BModal,
  bd as BModalOrchestrator,
  yd as BNav,
  hd as BNavForm,
  wd as BNavItem,
  kd as BNavItemDropdown,
  Td as BNavText,
  Sd as BNavbar,
  Vd as BNavbarBrand,
  _d as BNavbarNav,
  zd as BNavbarToggle,
  Md as BOffcanvas,
  ma as BOverlay,
  Dd as BPagination,
  je as BPlaceholder,
  Bn as BPlaceholderButton,
  jd as BPlaceholderCard,
  Wd as BPlaceholderTable,
  Gd as BPlaceholderWrapper,
  Xa as BPopover,
  Zo as BProgress,
  Jo as BProgressBar,
  Kd as BRow,
  pa as BSpinner,
  dc as BTab,
  uc as BTable,
  kn as BTableLite,
  ol as BTableSimple,
  vc as BTabs,
  wn as BTbody,
  St as BTd,
  Pa as BTfoot,
  Ea as BTh,
  Cn as BThead,
  Qo as BToast,
  mc as BToastOrchestrator,
  bc as BTooltip,
  Ye as BTr,
  It as BTransition,
  ql as BvCarouselEvent,
  nt as BvEvent,
  Bt as BvTriggerableEvent,
  Rl as Components,
  hc as Composables,
  Ll as Directives,
  wc as Types,
  Bc as Utils,
  Cc as createBootstrap,
  Cc as default,
  Ho as useBreadcrumb,
  Pr as useColorMode,
  zr as useModal,
  Uo as useModalController,
  Ko as useScrollspy,
  Yo as useToast,
  Ad as vBColorMode,
  Na as vBModal,
  Id as vBPopover,
  Pd as vBScrollspy,
  Na as vBToggle,
  Ed as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
